"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/lib/utilities/is-ci.ts
function isCI() {
  return process.env.CI === "true" || process.env.TF_BUILD === "true" || process.env.GITHUB_ACTIONS === "true" || process.env.BUILDKITE === "true" || process.env.CIRCLECI === "true" || process.env.CIRRUS_CI === "true" || process.env.TRAVIS === "true" || !!process.env["bamboo.buildKey"] || !!process.env.CODEBUILD_BUILD_ID || !!process.env.GITLAB_CI || !!process.env.HEROKU_TEST_RUN_ID || !!process.env.BUILD_ID || !!process.env.BUILD_BUILDID || !!process.env.TEAMCITY_VERSION;
}
var init_is_ci = __esm({
  "src/lib/utilities/is-ci.ts"() {
    "use strict";
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path5 = require("path");
    var os = require("os");
    function log(message) {
      console.log(`[dotenv][DEBUG] ${message}`);
    }
    var NEWLINE = "\n";
    var RE_INI_KEY_VAL = /^\s*([\w.-]+)\s*=\s*(.*)?\s*$/;
    var RE_NEWLINES = /\\n/g;
    var NEWLINES_MATCH = /\r\n|\n|\r/;
    function parse2(src, options) {
      const debug = Boolean(options && options.debug);
      const obj = {};
      src.toString().split(NEWLINES_MATCH).forEach(function(line, idx) {
        const keyValueArr = line.match(RE_INI_KEY_VAL);
        if (keyValueArr != null) {
          const key = keyValueArr[1];
          let val = keyValueArr[2] || "";
          const end = val.length - 1;
          const isDoubleQuoted = val[0] === '"' && val[end] === '"';
          const isSingleQuoted = val[0] === "'" && val[end] === "'";
          if (isSingleQuoted || isDoubleQuoted) {
            val = val.substring(1, end);
            if (isDoubleQuoted) {
              val = val.replace(RE_NEWLINES, NEWLINE);
            }
          } else {
            val = val.trim();
          }
          obj[key] = val;
        } else if (debug) {
          log(`did not match key and value when parsing line ${idx + 1}: ${line}`);
        }
      });
      return obj;
    }
    function resolveHome(envPath) {
      return envPath[0] === "~" ? path5.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function config(options) {
      let dotenvPath = path5.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      let debug = false;
      if (options) {
        if (options.path != null) {
          dotenvPath = resolveHome(options.path);
        }
        if (options.encoding != null) {
          encoding = options.encoding;
        }
        if (options.debug != null) {
          debug = true;
        }
      }
      try {
        const parsed = parse2(fs.readFileSync(dotenvPath, { encoding }), { debug });
        Object.keys(parsed).forEach(function(key) {
          if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
            process.env[key] = parsed[key];
          } else if (debug) {
            log(`"${key}" is already defined in \`process.env\` and will not be overwritten`);
          }
        });
        return { parsed };
      } catch (e) {
        return { error: e };
      }
    }
    module2.exports.config = config;
    module2.exports.parse = parse2;
  }
});

// node_modules/node-machine-id/dist/index.js
var require_dist = __commonJS({
  "node_modules/node-machine-id/dist/index.js"(exports2, module2) {
    "use strict";
    !function(t, n) {
      "object" == typeof exports2 && "object" == typeof module2 ? module2.exports = n(require("child_process"), require("crypto")) : "function" == typeof define && define.amd ? define(["child_process", "crypto"], n) : "object" == typeof exports2 ? exports2["electron-machine-id"] = n(require("child_process"), require("crypto")) : t["electron-machine-id"] = n(t.child_process, t.crypto);
    }(exports2, function(t, n) {
      return function(t2) {
        function n2(e) {
          if (r[e])
            return r[e].exports;
          var o = r[e] = { exports: {}, id: e, loaded: false };
          return t2[e].call(o.exports, o, o.exports, n2), o.loaded = true, o.exports;
        }
        var r = {};
        return n2.m = t2, n2.c = r, n2.p = "", n2(0);
      }([function(t2, n2, r) {
        t2.exports = r(34);
      }, function(t2, n2, r) {
        var e = r(29)("wks"), o = r(33), i = r(2).Symbol, c = "function" == typeof i, u = t2.exports = function(t3) {
          return e[t3] || (e[t3] = c && i[t3] || (c ? i : o)("Symbol." + t3));
        };
        u.store = e;
      }, function(t2, n2) {
        var r = t2.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = r);
      }, function(t2, n2, r) {
        var e = r(9);
        t2.exports = function(t3) {
          if (!e(t3))
            throw TypeError(t3 + " is not an object!");
          return t3;
        };
      }, function(t2, n2, r) {
        t2.exports = !r(24)(function() {
          return 7 != Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(t2, n2, r) {
        var e = r(12), o = r(17);
        t2.exports = r(4) ? function(t3, n3, r2) {
          return e.f(t3, n3, o(1, r2));
        } : function(t3, n3, r2) {
          return t3[n3] = r2, t3;
        };
      }, function(t2, n2) {
        var r = t2.exports = { version: "2.4.0" };
        "number" == typeof __e && (__e = r);
      }, function(t2, n2, r) {
        var e = r(14);
        t2.exports = function(t3, n3, r2) {
          if (e(t3), void 0 === n3)
            return t3;
          switch (r2) {
            case 1:
              return function(r3) {
                return t3.call(n3, r3);
              };
            case 2:
              return function(r3, e2) {
                return t3.call(n3, r3, e2);
              };
            case 3:
              return function(r3, e2, o) {
                return t3.call(n3, r3, e2, o);
              };
          }
          return function() {
            return t3.apply(n3, arguments);
          };
        };
      }, function(t2, n2) {
        var r = {}.hasOwnProperty;
        t2.exports = function(t3, n3) {
          return r.call(t3, n3);
        };
      }, function(t2, n2) {
        t2.exports = function(t3) {
          return "object" == typeof t3 ? null !== t3 : "function" == typeof t3;
        };
      }, function(t2, n2) {
        t2.exports = {};
      }, function(t2, n2) {
        var r = {}.toString;
        t2.exports = function(t3) {
          return r.call(t3).slice(8, -1);
        };
      }, function(t2, n2, r) {
        var e = r(3), o = r(26), i = r(32), c = Object.defineProperty;
        n2.f = r(4) ? Object.defineProperty : function(t3, n3, r2) {
          if (e(t3), n3 = i(n3, true), e(r2), o)
            try {
              return c(t3, n3, r2);
            } catch (t4) {
            }
          if ("get" in r2 || "set" in r2)
            throw TypeError("Accessors not supported!");
          return "value" in r2 && (t3[n3] = r2.value), t3;
        };
      }, function(t2, n2, r) {
        var e = r(42), o = r(15);
        t2.exports = function(t3) {
          return e(o(t3));
        };
      }, function(t2, n2) {
        t2.exports = function(t3) {
          if ("function" != typeof t3)
            throw TypeError(t3 + " is not a function!");
          return t3;
        };
      }, function(t2, n2) {
        t2.exports = function(t3) {
          if (void 0 == t3)
            throw TypeError("Can't call method on  " + t3);
          return t3;
        };
      }, function(t2, n2, r) {
        var e = r(9), o = r(2).document, i = e(o) && e(o.createElement);
        t2.exports = function(t3) {
          return i ? o.createElement(t3) : {};
        };
      }, function(t2, n2) {
        t2.exports = function(t3, n3) {
          return { enumerable: !(1 & t3), configurable: !(2 & t3), writable: !(4 & t3), value: n3 };
        };
      }, function(t2, n2, r) {
        var e = r(12).f, o = r(8), i = r(1)("toStringTag");
        t2.exports = function(t3, n3, r2) {
          t3 && !o(t3 = r2 ? t3 : t3.prototype, i) && e(t3, i, { configurable: true, value: n3 });
        };
      }, function(t2, n2, r) {
        var e = r(29)("keys"), o = r(33);
        t2.exports = function(t3) {
          return e[t3] || (e[t3] = o(t3));
        };
      }, function(t2, n2) {
        var r = Math.ceil, e = Math.floor;
        t2.exports = function(t3) {
          return isNaN(t3 = +t3) ? 0 : (t3 > 0 ? e : r)(t3);
        };
      }, function(t2, n2, r) {
        var e = r(11), o = r(1)("toStringTag"), i = "Arguments" == e(/* @__PURE__ */ function() {
          return arguments;
        }()), c = function(t3, n3) {
          try {
            return t3[n3];
          } catch (t4) {
          }
        };
        t2.exports = function(t3) {
          var n3, r2, u;
          return void 0 === t3 ? "Undefined" : null === t3 ? "Null" : "string" == typeof (r2 = c(n3 = Object(t3), o)) ? r2 : i ? e(n3) : "Object" == (u = e(n3)) && "function" == typeof n3.callee ? "Arguments" : u;
        };
      }, function(t2, n2) {
        t2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      }, function(t2, n2, r) {
        var e = r(2), o = r(6), i = r(7), c = r(5), u = "prototype", s = function(t3, n3, r2) {
          var f, a, p, l = t3 & s.F, v = t3 & s.G, h = t3 & s.S, d = t3 & s.P, y = t3 & s.B, _ = t3 & s.W, x = v ? o : o[n3] || (o[n3] = {}), m = x[u], w = v ? e : h ? e[n3] : (e[n3] || {})[u];
          v && (r2 = n3);
          for (f in r2)
            a = !l && w && void 0 !== w[f], a && f in x || (p = a ? w[f] : r2[f], x[f] = v && "function" != typeof w[f] ? r2[f] : y && a ? i(p, e) : _ && w[f] == p ? function(t4) {
              var n4 = function(n5, r3, e2) {
                if (this instanceof t4) {
                  switch (arguments.length) {
                    case 0:
                      return new t4();
                    case 1:
                      return new t4(n5);
                    case 2:
                      return new t4(n5, r3);
                  }
                  return new t4(n5, r3, e2);
                }
                return t4.apply(this, arguments);
              };
              return n4[u] = t4[u], n4;
            }(p) : d && "function" == typeof p ? i(Function.call, p) : p, d && ((x.virtual || (x.virtual = {}))[f] = p, t3 & s.R && m && !m[f] && c(m, f, p)));
        };
        s.F = 1, s.G = 2, s.S = 4, s.P = 8, s.B = 16, s.W = 32, s.U = 64, s.R = 128, t2.exports = s;
      }, function(t2, n2) {
        t2.exports = function(t3) {
          try {
            return !!t3();
          } catch (t4) {
            return true;
          }
        };
      }, function(t2, n2, r) {
        t2.exports = r(2).document && document.documentElement;
      }, function(t2, n2, r) {
        t2.exports = !r(4) && !r(24)(function() {
          return 7 != Object.defineProperty(r(16)("div"), "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(t2, n2, r) {
        "use strict";
        var e = r(28), o = r(23), i = r(57), c = r(5), u = r(8), s = r(10), f = r(45), a = r(18), p = r(52), l = r(1)("iterator"), v = !([].keys && "next" in [].keys()), h = "@@iterator", d = "keys", y = "values", _ = function() {
          return this;
        };
        t2.exports = function(t3, n3, r2, x, m, w, g) {
          f(r2, n3, x);
          var b, O, j, S = function(t4) {
            if (!v && t4 in T)
              return T[t4];
            switch (t4) {
              case d:
                return function() {
                  return new r2(this, t4);
                };
              case y:
                return function() {
                  return new r2(this, t4);
                };
            }
            return function() {
              return new r2(this, t4);
            };
          }, E = n3 + " Iterator", P = m == y, M = false, T = t3.prototype, A = T[l] || T[h] || m && T[m], k = A || S(m), C = m ? P ? S("entries") : k : void 0, I = "Array" == n3 ? T.entries || A : A;
          if (I && (j = p(I.call(new t3())), j !== Object.prototype && (a(j, E, true), e || u(j, l) || c(j, l, _))), P && A && A.name !== y && (M = true, k = function() {
            return A.call(this);
          }), e && !g || !v && !M && T[l] || c(T, l, k), s[n3] = k, s[E] = _, m)
            if (b = { values: P ? k : S(y), keys: w ? k : S(d), entries: C }, g)
              for (O in b)
                O in T || i(T, O, b[O]);
            else
              o(o.P + o.F * (v || M), n3, b);
          return b;
        };
      }, function(t2, n2) {
        t2.exports = true;
      }, function(t2, n2, r) {
        var e = r(2), o = "__core-js_shared__", i = e[o] || (e[o] = {});
        t2.exports = function(t3) {
          return i[t3] || (i[t3] = {});
        };
      }, function(t2, n2, r) {
        var e, o, i, c = r(7), u = r(41), s = r(25), f = r(16), a = r(2), p = a.process, l = a.setImmediate, v = a.clearImmediate, h = a.MessageChannel, d = 0, y = {}, _ = "onreadystatechange", x = function() {
          var t3 = +this;
          if (y.hasOwnProperty(t3)) {
            var n3 = y[t3];
            delete y[t3], n3();
          }
        }, m = function(t3) {
          x.call(t3.data);
        };
        l && v || (l = function(t3) {
          for (var n3 = [], r2 = 1; arguments.length > r2; )
            n3.push(arguments[r2++]);
          return y[++d] = function() {
            u("function" == typeof t3 ? t3 : Function(t3), n3);
          }, e(d), d;
        }, v = function(t3) {
          delete y[t3];
        }, "process" == r(11)(p) ? e = function(t3) {
          p.nextTick(c(x, t3, 1));
        } : h ? (o = new h(), i = o.port2, o.port1.onmessage = m, e = c(i.postMessage, i, 1)) : a.addEventListener && "function" == typeof postMessage && !a.importScripts ? (e = function(t3) {
          a.postMessage(t3 + "", "*");
        }, a.addEventListener("message", m, false)) : e = _ in f("script") ? function(t3) {
          s.appendChild(f("script"))[_] = function() {
            s.removeChild(this), x.call(t3);
          };
        } : function(t3) {
          setTimeout(c(x, t3, 1), 0);
        }), t2.exports = { set: l, clear: v };
      }, function(t2, n2, r) {
        var e = r(20), o = Math.min;
        t2.exports = function(t3) {
          return t3 > 0 ? o(e(t3), 9007199254740991) : 0;
        };
      }, function(t2, n2, r) {
        var e = r(9);
        t2.exports = function(t3, n3) {
          if (!e(t3))
            return t3;
          var r2, o;
          if (n3 && "function" == typeof (r2 = t3.toString) && !e(o = r2.call(t3)))
            return o;
          if ("function" == typeof (r2 = t3.valueOf) && !e(o = r2.call(t3)))
            return o;
          if (!n3 && "function" == typeof (r2 = t3.toString) && !e(o = r2.call(t3)))
            return o;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(t2, n2) {
        var r = 0, e = Math.random();
        t2.exports = function(t3) {
          return "Symbol(".concat(void 0 === t3 ? "" : t3, ")_", (++r + e).toString(36));
        };
      }, function(t2, n2, r) {
        "use strict";
        function e(t3) {
          return t3 && t3.__esModule ? t3 : { default: t3 };
        }
        function o() {
          return "win32" !== process.platform ? "" : "ia32" === process.arch && process.env.hasOwnProperty("PROCESSOR_ARCHITEW6432") ? "mixed" : "native";
        }
        function i(t3) {
          return (0, l.createHash)("sha256").update(t3).digest("hex");
        }
        function c(t3) {
          switch (h) {
            case "darwin":
              return t3.split("IOPlatformUUID")[1].split("\n")[0].replace(/\=|\s+|\"/gi, "").toLowerCase();
            case "win32":
              return t3.toString().split("REG_SZ")[1].replace(/\r+|\n+|\s+/gi, "").toLowerCase();
            case "linux":
              return t3.toString().replace(/\r+|\n+|\s+/gi, "").toLowerCase();
            case "freebsd":
              return t3.toString().replace(/\r+|\n+|\s+/gi, "").toLowerCase();
            default:
              throw new Error("Unsupported platform: " + process.platform);
          }
        }
        function u(t3) {
          var n3 = c((0, p.execSync)(y[h]).toString());
          return t3 ? n3 : i(n3);
        }
        function s(t3) {
          return new a.default(function(n3, r2) {
            return (0, p.exec)(y[h], {}, function(e2, o2, u2) {
              if (e2)
                return r2(new Error("Error while obtaining machine id: " + e2.stack));
              var s2 = c(o2.toString());
              return n3(t3 ? s2 : i(s2));
            });
          });
        }
        Object.defineProperty(n2, "__esModule", { value: true });
        var f = r(35), a = e(f);
        n2.machineIdSync = u, n2.machineId = s;
        var p = r(70), l = r(71), v = process, h = v.platform, d = { native: "%windir%\\System32", mixed: "%windir%\\sysnative\\cmd.exe /c %windir%\\System32" }, y = { darwin: "ioreg -rd1 -c IOPlatformExpertDevice", win32: d[o()] + "\\REG.exe QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography /v MachineGuid", linux: "( cat /var/lib/dbus/machine-id /etc/machine-id 2> /dev/null || hostname ) | head -n 1 || :", freebsd: "kenv -q smbios.system.uuid || sysctl -n kern.hostuuid" };
      }, function(t2, n2, r) {
        t2.exports = { default: r(36), __esModule: true };
      }, function(t2, n2, r) {
        r(66), r(68), r(69), r(67), t2.exports = r(6).Promise;
      }, function(t2, n2) {
        t2.exports = function() {
        };
      }, function(t2, n2) {
        t2.exports = function(t3, n3, r, e) {
          if (!(t3 instanceof n3) || void 0 !== e && e in t3)
            throw TypeError(r + ": incorrect invocation!");
          return t3;
        };
      }, function(t2, n2, r) {
        var e = r(13), o = r(31), i = r(62);
        t2.exports = function(t3) {
          return function(n3, r2, c) {
            var u, s = e(n3), f = o(s.length), a = i(c, f);
            if (t3 && r2 != r2) {
              for (; f > a; )
                if (u = s[a++], u != u)
                  return true;
            } else
              for (; f > a; a++)
                if ((t3 || a in s) && s[a] === r2)
                  return t3 || a || 0;
            return !t3 && -1;
          };
        };
      }, function(t2, n2, r) {
        var e = r(7), o = r(44), i = r(43), c = r(3), u = r(31), s = r(64), f = {}, a = {}, n2 = t2.exports = function(t3, n3, r2, p, l) {
          var v, h, d, y, _ = l ? function() {
            return t3;
          } : s(t3), x = e(r2, p, n3 ? 2 : 1), m = 0;
          if ("function" != typeof _)
            throw TypeError(t3 + " is not iterable!");
          if (i(_)) {
            for (v = u(t3.length); v > m; m++)
              if (y = n3 ? x(c(h = t3[m])[0], h[1]) : x(t3[m]), y === f || y === a)
                return y;
          } else
            for (d = _.call(t3); !(h = d.next()).done; )
              if (y = o(d, x, h.value, n3), y === f || y === a)
                return y;
        };
        n2.BREAK = f, n2.RETURN = a;
      }, function(t2, n2) {
        t2.exports = function(t3, n3, r) {
          var e = void 0 === r;
          switch (n3.length) {
            case 0:
              return e ? t3() : t3.call(r);
            case 1:
              return e ? t3(n3[0]) : t3.call(r, n3[0]);
            case 2:
              return e ? t3(n3[0], n3[1]) : t3.call(r, n3[0], n3[1]);
            case 3:
              return e ? t3(n3[0], n3[1], n3[2]) : t3.call(r, n3[0], n3[1], n3[2]);
            case 4:
              return e ? t3(n3[0], n3[1], n3[2], n3[3]) : t3.call(r, n3[0], n3[1], n3[2], n3[3]);
          }
          return t3.apply(r, n3);
        };
      }, function(t2, n2, r) {
        var e = r(11);
        t2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(t3) {
          return "String" == e(t3) ? t3.split("") : Object(t3);
        };
      }, function(t2, n2, r) {
        var e = r(10), o = r(1)("iterator"), i = Array.prototype;
        t2.exports = function(t3) {
          return void 0 !== t3 && (e.Array === t3 || i[o] === t3);
        };
      }, function(t2, n2, r) {
        var e = r(3);
        t2.exports = function(t3, n3, r2, o) {
          try {
            return o ? n3(e(r2)[0], r2[1]) : n3(r2);
          } catch (n4) {
            var i = t3.return;
            throw void 0 !== i && e(i.call(t3)), n4;
          }
        };
      }, function(t2, n2, r) {
        "use strict";
        var e = r(49), o = r(17), i = r(18), c = {};
        r(5)(c, r(1)("iterator"), function() {
          return this;
        }), t2.exports = function(t3, n3, r2) {
          t3.prototype = e(c, { next: o(1, r2) }), i(t3, n3 + " Iterator");
        };
      }, function(t2, n2, r) {
        var e = r(1)("iterator"), o = false;
        try {
          var i = [7][e]();
          i.return = function() {
            o = true;
          }, Array.from(i, function() {
            throw 2;
          });
        } catch (t3) {
        }
        t2.exports = function(t3, n3) {
          if (!n3 && !o)
            return false;
          var r2 = false;
          try {
            var i2 = [7], c = i2[e]();
            c.next = function() {
              return { done: r2 = true };
            }, i2[e] = function() {
              return c;
            }, t3(i2);
          } catch (t4) {
          }
          return r2;
        };
      }, function(t2, n2) {
        t2.exports = function(t3, n3) {
          return { value: n3, done: !!t3 };
        };
      }, function(t2, n2, r) {
        var e = r(2), o = r(30).set, i = e.MutationObserver || e.WebKitMutationObserver, c = e.process, u = e.Promise, s = "process" == r(11)(c);
        t2.exports = function() {
          var t3, n3, r2, f = function() {
            var e2, o2;
            for (s && (e2 = c.domain) && e2.exit(); t3; ) {
              o2 = t3.fn, t3 = t3.next;
              try {
                o2();
              } catch (e3) {
                throw t3 ? r2() : n3 = void 0, e3;
              }
            }
            n3 = void 0, e2 && e2.enter();
          };
          if (s)
            r2 = function() {
              c.nextTick(f);
            };
          else if (i) {
            var a = true, p = document.createTextNode("");
            new i(f).observe(p, { characterData: true }), r2 = function() {
              p.data = a = !a;
            };
          } else if (u && u.resolve) {
            var l = u.resolve();
            r2 = function() {
              l.then(f);
            };
          } else
            r2 = function() {
              o.call(e, f);
            };
          return function(e2) {
            var o2 = { fn: e2, next: void 0 };
            n3 && (n3.next = o2), t3 || (t3 = o2, r2()), n3 = o2;
          };
        };
      }, function(t2, n2, r) {
        var e = r(3), o = r(50), i = r(22), c = r(19)("IE_PROTO"), u = function() {
        }, s = "prototype", f = function() {
          var t3, n3 = r(16)("iframe"), e2 = i.length, o2 = ">";
          for (n3.style.display = "none", r(25).appendChild(n3), n3.src = "javascript:", t3 = n3.contentWindow.document, t3.open(), t3.write("<script>document.F=Object</script" + o2), t3.close(), f = t3.F; e2--; )
            delete f[s][i[e2]];
          return f();
        };
        t2.exports = Object.create || function(t3, n3) {
          var r2;
          return null !== t3 ? (u[s] = e(t3), r2 = new u(), u[s] = null, r2[c] = t3) : r2 = f(), void 0 === n3 ? r2 : o(r2, n3);
        };
      }, function(t2, n2, r) {
        var e = r(12), o = r(3), i = r(54);
        t2.exports = r(4) ? Object.defineProperties : function(t3, n3) {
          o(t3);
          for (var r2, c = i(n3), u = c.length, s = 0; u > s; )
            e.f(t3, r2 = c[s++], n3[r2]);
          return t3;
        };
      }, function(t2, n2, r) {
        var e = r(55), o = r(17), i = r(13), c = r(32), u = r(8), s = r(26), f = Object.getOwnPropertyDescriptor;
        n2.f = r(4) ? f : function(t3, n3) {
          if (t3 = i(t3), n3 = c(n3, true), s)
            try {
              return f(t3, n3);
            } catch (t4) {
            }
          if (u(t3, n3))
            return o(!e.f.call(t3, n3), t3[n3]);
        };
      }, function(t2, n2, r) {
        var e = r(8), o = r(63), i = r(19)("IE_PROTO"), c = Object.prototype;
        t2.exports = Object.getPrototypeOf || function(t3) {
          return t3 = o(t3), e(t3, i) ? t3[i] : "function" == typeof t3.constructor && t3 instanceof t3.constructor ? t3.constructor.prototype : t3 instanceof Object ? c : null;
        };
      }, function(t2, n2, r) {
        var e = r(8), o = r(13), i = r(39)(false), c = r(19)("IE_PROTO");
        t2.exports = function(t3, n3) {
          var r2, u = o(t3), s = 0, f = [];
          for (r2 in u)
            r2 != c && e(u, r2) && f.push(r2);
          for (; n3.length > s; )
            e(u, r2 = n3[s++]) && (~i(f, r2) || f.push(r2));
          return f;
        };
      }, function(t2, n2, r) {
        var e = r(53), o = r(22);
        t2.exports = Object.keys || function(t3) {
          return e(t3, o);
        };
      }, function(t2, n2) {
        n2.f = {}.propertyIsEnumerable;
      }, function(t2, n2, r) {
        var e = r(5);
        t2.exports = function(t3, n3, r2) {
          for (var o in n3)
            r2 && t3[o] ? t3[o] = n3[o] : e(t3, o, n3[o]);
          return t3;
        };
      }, function(t2, n2, r) {
        t2.exports = r(5);
      }, function(t2, n2, r) {
        var e = r(9), o = r(3), i = function(t3, n3) {
          if (o(t3), !e(n3) && null !== n3)
            throw TypeError(n3 + ": can't set as prototype!");
        };
        t2.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function(t3, n3, e2) {
          try {
            e2 = r(7)(Function.call, r(51).f(Object.prototype, "__proto__").set, 2), e2(t3, []), n3 = !(t3 instanceof Array);
          } catch (t4) {
            n3 = true;
          }
          return function(t4, r2) {
            return i(t4, r2), n3 ? t4.__proto__ = r2 : e2(t4, r2), t4;
          };
        }({}, false) : void 0), check: i };
      }, function(t2, n2, r) {
        "use strict";
        var e = r(2), o = r(6), i = r(12), c = r(4), u = r(1)("species");
        t2.exports = function(t3) {
          var n3 = "function" == typeof o[t3] ? o[t3] : e[t3];
          c && n3 && !n3[u] && i.f(n3, u, { configurable: true, get: function() {
            return this;
          } });
        };
      }, function(t2, n2, r) {
        var e = r(3), o = r(14), i = r(1)("species");
        t2.exports = function(t3, n3) {
          var r2, c = e(t3).constructor;
          return void 0 === c || void 0 == (r2 = e(c)[i]) ? n3 : o(r2);
        };
      }, function(t2, n2, r) {
        var e = r(20), o = r(15);
        t2.exports = function(t3) {
          return function(n3, r2) {
            var i, c, u = String(o(n3)), s = e(r2), f = u.length;
            return s < 0 || s >= f ? t3 ? "" : void 0 : (i = u.charCodeAt(s), i < 55296 || i > 56319 || s + 1 === f || (c = u.charCodeAt(s + 1)) < 56320 || c > 57343 ? t3 ? u.charAt(s) : i : t3 ? u.slice(s, s + 2) : (i - 55296 << 10) + (c - 56320) + 65536);
          };
        };
      }, function(t2, n2, r) {
        var e = r(20), o = Math.max, i = Math.min;
        t2.exports = function(t3, n3) {
          return t3 = e(t3), t3 < 0 ? o(t3 + n3, 0) : i(t3, n3);
        };
      }, function(t2, n2, r) {
        var e = r(15);
        t2.exports = function(t3) {
          return Object(e(t3));
        };
      }, function(t2, n2, r) {
        var e = r(21), o = r(1)("iterator"), i = r(10);
        t2.exports = r(6).getIteratorMethod = function(t3) {
          if (void 0 != t3)
            return t3[o] || t3["@@iterator"] || i[e(t3)];
        };
      }, function(t2, n2, r) {
        "use strict";
        var e = r(37), o = r(47), i = r(10), c = r(13);
        t2.exports = r(27)(Array, "Array", function(t3, n3) {
          this._t = c(t3), this._i = 0, this._k = n3;
        }, function() {
          var t3 = this._t, n3 = this._k, r2 = this._i++;
          return !t3 || r2 >= t3.length ? (this._t = void 0, o(1)) : "keys" == n3 ? o(0, r2) : "values" == n3 ? o(0, t3[r2]) : o(0, [r2, t3[r2]]);
        }, "values"), i.Arguments = i.Array, e("keys"), e("values"), e("entries");
      }, function(t2, n2) {
      }, function(t2, n2, r) {
        "use strict";
        var e, o, i, c = r(28), u = r(2), s = r(7), f = r(21), a = r(23), p = r(9), l = (r(3), r(14)), v = r(38), h = r(40), d = (r(58).set, r(60)), y = r(30).set, _ = r(48)(), x = "Promise", m = u.TypeError, w = u.process, g = u[x], w = u.process, b = "process" == f(w), O = function() {
        }, j = !!function() {
          try {
            var t3 = g.resolve(1), n3 = (t3.constructor = {})[r(1)("species")] = function(t4) {
              t4(O, O);
            };
            return (b || "function" == typeof PromiseRejectionEvent) && t3.then(O) instanceof n3;
          } catch (t4) {
          }
        }(), S = function(t3, n3) {
          return t3 === n3 || t3 === g && n3 === i;
        }, E = function(t3) {
          var n3;
          return !(!p(t3) || "function" != typeof (n3 = t3.then)) && n3;
        }, P = function(t3) {
          return S(g, t3) ? new M(t3) : new o(t3);
        }, M = o = function(t3) {
          var n3, r2;
          this.promise = new t3(function(t4, e2) {
            if (void 0 !== n3 || void 0 !== r2)
              throw m("Bad Promise constructor");
            n3 = t4, r2 = e2;
          }), this.resolve = l(n3), this.reject = l(r2);
        }, T = function(t3) {
          try {
            t3();
          } catch (t4) {
            return { error: t4 };
          }
        }, A = function(t3, n3) {
          if (!t3._n) {
            t3._n = true;
            var r2 = t3._c;
            _(function() {
              for (var e2 = t3._v, o2 = 1 == t3._s, i2 = 0, c2 = function(n4) {
                var r3, i3, c3 = o2 ? n4.ok : n4.fail, u2 = n4.resolve, s2 = n4.reject, f2 = n4.domain;
                try {
                  c3 ? (o2 || (2 == t3._h && I(t3), t3._h = 1), c3 === true ? r3 = e2 : (f2 && f2.enter(), r3 = c3(e2), f2 && f2.exit()), r3 === n4.promise ? s2(m("Promise-chain cycle")) : (i3 = E(r3)) ? i3.call(r3, u2, s2) : u2(r3)) : s2(e2);
                } catch (t4) {
                  s2(t4);
                }
              }; r2.length > i2; )
                c2(r2[i2++]);
              t3._c = [], t3._n = false, n3 && !t3._h && k(t3);
            });
          }
        }, k = function(t3) {
          y.call(u, function() {
            var n3, r2, e2, o2 = t3._v;
            if (C(t3) && (n3 = T(function() {
              b ? w.emit("unhandledRejection", o2, t3) : (r2 = u.onunhandledrejection) ? r2({ promise: t3, reason: o2 }) : (e2 = u.console) && e2.error && e2.error("Unhandled promise rejection", o2);
            }), t3._h = b || C(t3) ? 2 : 1), t3._a = void 0, n3)
              throw n3.error;
          });
        }, C = function(t3) {
          if (1 == t3._h)
            return false;
          for (var n3, r2 = t3._a || t3._c, e2 = 0; r2.length > e2; )
            if (n3 = r2[e2++], n3.fail || !C(n3.promise))
              return false;
          return true;
        }, I = function(t3) {
          y.call(u, function() {
            var n3;
            b ? w.emit("rejectionHandled", t3) : (n3 = u.onrejectionhandled) && n3({ promise: t3, reason: t3._v });
          });
        }, R = function(t3) {
          var n3 = this;
          n3._d || (n3._d = true, n3 = n3._w || n3, n3._v = t3, n3._s = 2, n3._a || (n3._a = n3._c.slice()), A(n3, true));
        }, F = function(t3) {
          var n3, r2 = this;
          if (!r2._d) {
            r2._d = true, r2 = r2._w || r2;
            try {
              if (r2 === t3)
                throw m("Promise can't be resolved itself");
              (n3 = E(t3)) ? _(function() {
                var e2 = { _w: r2, _d: false };
                try {
                  n3.call(t3, s(F, e2, 1), s(R, e2, 1));
                } catch (t4) {
                  R.call(e2, t4);
                }
              }) : (r2._v = t3, r2._s = 1, A(r2, false));
            } catch (t4) {
              R.call({ _w: r2, _d: false }, t4);
            }
          }
        };
        j || (g = function(t3) {
          v(this, g, x, "_h"), l(t3), e.call(this);
          try {
            t3(s(F, this, 1), s(R, this, 1));
          } catch (t4) {
            R.call(this, t4);
          }
        }, e = function(t3) {
          this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
        }, e.prototype = r(56)(g.prototype, { then: function(t3, n3) {
          var r2 = P(d(this, g));
          return r2.ok = "function" != typeof t3 || t3, r2.fail = "function" == typeof n3 && n3, r2.domain = b ? w.domain : void 0, this._c.push(r2), this._a && this._a.push(r2), this._s && A(this, false), r2.promise;
        }, catch: function(t3) {
          return this.then(void 0, t3);
        } }), M = function() {
          var t3 = new e();
          this.promise = t3, this.resolve = s(F, t3, 1), this.reject = s(R, t3, 1);
        }), a(a.G + a.W + a.F * !j, { Promise: g }), r(18)(g, x), r(59)(x), i = r(6)[x], a(a.S + a.F * !j, x, { reject: function(t3) {
          var n3 = P(this), r2 = n3.reject;
          return r2(t3), n3.promise;
        } }), a(a.S + a.F * (c || !j), x, { resolve: function(t3) {
          if (t3 instanceof g && S(t3.constructor, this))
            return t3;
          var n3 = P(this), r2 = n3.resolve;
          return r2(t3), n3.promise;
        } }), a(a.S + a.F * !(j && r(46)(function(t3) {
          g.all(t3).catch(O);
        })), x, { all: function(t3) {
          var n3 = this, r2 = P(n3), e2 = r2.resolve, o2 = r2.reject, i2 = T(function() {
            var r3 = [], i3 = 0, c2 = 1;
            h(t3, false, function(t4) {
              var u2 = i3++, s2 = false;
              r3.push(void 0), c2++, n3.resolve(t4).then(function(t5) {
                s2 || (s2 = true, r3[u2] = t5, --c2 || e2(r3));
              }, o2);
            }), --c2 || e2(r3);
          });
          return i2 && o2(i2.error), r2.promise;
        }, race: function(t3) {
          var n3 = this, r2 = P(n3), e2 = r2.reject, o2 = T(function() {
            h(t3, false, function(t4) {
              n3.resolve(t4).then(r2.resolve, e2);
            });
          });
          return o2 && e2(o2.error), r2.promise;
        } });
      }, function(t2, n2, r) {
        "use strict";
        var e = r(61)(true);
        r(27)(String, "String", function(t3) {
          this._t = String(t3), this._i = 0;
        }, function() {
          var t3, n3 = this._t, r2 = this._i;
          return r2 >= n3.length ? { value: void 0, done: true } : (t3 = e(n3, r2), this._i += t3.length, { value: t3, done: false });
        });
      }, function(t2, n2, r) {
        r(65);
        for (var e = r(2), o = r(5), i = r(10), c = r(1)("toStringTag"), u = ["NodeList", "DOMTokenList", "MediaList", "StyleSheetList", "CSSRuleList"], s = 0; s < 5; s++) {
          var f = u[s], a = e[f], p = a && a.prototype;
          p && !p[c] && o(p, c, f), i[f] = i.Array;
        }
      }, function(t2, n2) {
        t2.exports = require("child_process");
      }, function(t2, n2) {
        t2.exports = require("crypto");
      }]);
    });
  }
});

// src/lib/utilities/light-client-require.ts
var light_client_require_exports = {};
__export(light_client_require_exports, {
  configureLightClientRequire: () => configureLightClientRequire,
  lightClientRequire: () => lightClientRequire
});
function lightClientRequire(moduleName) {
  let paths;
  try {
    paths = JSON.parse(process.env.NX_CLOUD_LIGHT_CLIENT_RESOLUTION_PATHS);
  } catch (e) {
    paths = [];
  }
  if (paths.length === 0) {
    throw new Error(
      "Light client require must have paths configured with `configureLightClientRequire`."
    );
  }
  let path5;
  try {
    path5 = require.resolve(moduleName, { paths });
  } catch (e) {
    if (process.env.NX_VERBOSE_LOGGING === "true") {
      console.error(
        `Was not able to require.resolve module ${moduleName} from the following paths: ${paths}. This may be expected.`
      );
    }
    throw e;
  }
  try {
    return require(path5);
  } catch (e) {
    if (process.env.NX_VERBOSE_LOGGING === "true") {
      console.error(
        `Was not able require module ${moduleName} from path ${path5}. This may be expected. `
      );
    }
    throw e;
  }
}
function configureLightClientRequire(paths) {
  process.env.NX_CLOUD_LIGHT_CLIENT_RESOLUTION_PATHS = JSON.stringify(paths);
}
var init_light_client_require = __esm({
  "src/lib/utilities/light-client-require.ts"() {
    "use strict";
  }
});

// src/lib/utilities/nx-imports-light.ts
var require_nx_imports_light = __commonJS({
  "src/lib/utilities/nx-imports-light.ts"(exports2) {
    "use strict";
    init_light_client_require();
    try {
      try {
        const { output: output37 } = lightClientRequire("nx/src/utils/output");
        let workspaceRoot7;
        try {
          workspaceRoot7 = lightClientRequire("nx/src/utils/app-root").workspaceRoot;
        } catch (_a2) {
          workspaceRoot7 = lightClientRequire(
            "nx/src/utils/workspace-root"
          ).workspaceRoot;
        }
        exports2.workspaceRoot = workspaceRoot7;
        exports2.output = output37;
      } catch (e) {
        const { output: output37 } = lightClientRequire(
          "@nrwl/workspace/src/utilities/output"
        );
        const { appRootPath } = lightClientRequire("@nrwl/tao/src/utils/app-root");
        exports2.workspaceRoot = appRootPath;
        exports2.output = output37;
      }
    } catch (e) {
      const formatMessage2 = (input) => {
        var _a2;
        return `${input.title}

${(_a2 = input.bodyLines) == null ? void 0 : _a2.join("\n")}`;
      };
      exports2.output = {
        note: (input) => console.info(formatMessage2(input)),
        error: (input) => console.error(formatMessage2(input)),
        warn: (input) => console.warn(formatMessage2(input)),
        success: (input) => console.log(formatMessage2(input)),
        addVerticalSeparator: () => "",
        addNewline: () => console.log("\n")
      };
      exports2.workspaceRoot = process.cwd();
    }
  }
});

// src/lib/utilities/environment.ts
function agentRunningInDistributedExecution(distributedExecutionId) {
  return !!distributedExecutionId;
}
function nxInvokedByRunner() {
  return process.env.NX_INVOKED_BY_RUNNER === "true" || process.env.NX_CLOUD === "false";
}
function extractGitSha() {
  try {
    return (0, import_child_process.execSync)(`git rev-parse HEAD`, { stdio: "pipe" }).toString().trim();
  } catch (e) {
    return void 0;
  }
}
function extractGitRef() {
  try {
    return (0, import_child_process.execSync)(`git rev-parse --symbolic-full-name HEAD`, {
      stdio: "pipe"
    }).toString().trim();
  } catch (e) {
    return void 0;
  }
}
function parseEnv() {
  try {
    const envContents = (0, import_fs.readFileSync)((0, import_path.join)(workspaceRoot, "nx-cloud.env"));
    return dotenv.parse(envContents);
  } catch (e) {
    return {};
  }
}
function loadEnvVars() {
  const parsed = parseEnv();
  ACCESS_TOKEN = process.env.NX_CLOUD_AUTH_TOKEN || process.env.NX_CLOUD_ACCESS_TOKEN || parsed.NX_CLOUD_AUTH_TOKEN || parsed.NX_CLOUD_ACCESS_TOKEN;
  ENCRYPTION_KEY = process.env.NX_CLOUD_ENCRYPTION_KEY || parsed.NX_CLOUD_ENCRYPTION_KEY;
  VERBOSE_LOGGING = process.env.NX_VERBOSE_LOGGING === "true" || parsed.NX_VERBOSE_LOGGING === "true";
  NX_CLOUD_NO_TIMEOUTS = process.env.NX_CLOUD_NO_TIMEOUTS === "true" || parsed.NX_CLOUD_NO_TIMEOUTS === "true";
  NX_CLOUD_CONTRIBUTOR_TESTING = process.env.NX_CLOUD_CONTRIBUTOR_TESTING === "true" || parsed.NX_CLOUD_CONTRIBUTOR_TESTING === "true";
}
function getCIExecutionId() {
  return _ciExecutionId();
}
function _ciExecutionId() {
  if (process.env.NX_CI_EXECUTION_ID !== void 0) {
    return process.env.NX_CI_EXECUTION_ID;
  }
  if (process.env.NX_RUN_GROUP !== void 0) {
    return process.env.NX_RUN_GROUP;
  }
  if (process.env.CIRCLECI !== void 0 && process.env.CIRCLE_WORKFLOW_ID) {
    return process.env.CIRCLE_WORKFLOW_ID;
  }
  if (process.env.TRAVIS_BUILD_ID !== void 0) {
    return process.env.TRAVIS_BUILD_ID;
  }
  if (process.env.GITHUB_ACTIONS && process.env.GITHUB_RUN_ID) {
    return `${process.env.GITHUB_RUN_ID}-${process.env.GITHUB_RUN_ATTEMPT}`;
  }
  if (process.env.BUILD_BUILDID) {
    return process.env.BUILD_BUILDID;
  }
  if (process.env.BITBUCKET_BUILD_NUMBER !== void 0) {
    return process.env.BITBUCKET_BUILD_NUMBER;
  }
  if (process.env.VERCEL_GIT_COMMIT_SHA !== void 0) {
    return process.env.VERCEL_GIT_COMMIT_SHA;
  }
  if (process.env.CI_PIPELINE_ID) {
    return process.env.CI_PIPELINE_ID;
  }
  if (process.env.BUILD_TAG) {
    return process.env.BUILD_TAG;
  }
  return null;
}
function getCIExecutionEnv() {
  return process.env.NX_CI_EXECUTION_ENV ?? "";
}
function getRunGroup() {
  if (process.env.NX_RUN_GROUP !== void 0) {
    return process.env.NX_RUN_GROUP;
  }
  const ciExecutionId = _ciExecutionId();
  if (ciExecutionId) {
    if (getCIExecutionEnv()) {
      return `${ciExecutionId}-${getCIExecutionEnv()}`;
    } else {
      return ciExecutionId;
    }
  }
  return extractGitSha();
}
function getBranch() {
  if (process.env.NX_BRANCH !== void 0) {
    return process.env.NX_BRANCH;
  }
  if (process.env.CIRCLECI !== void 0) {
    if (process.env.CIRCLE_PR_NUMBER !== void 0) {
      return process.env.CIRCLE_PR_NUMBER;
    } else if (process.env.CIRCLE_PULL_REQUEST !== void 0) {
      const p = process.env.CIRCLE_PULL_REQUEST.split("/");
      return p[p.length - 1];
    } else if (process.env.CIRCLE_BRANCH !== void 0) {
      return process.env.CIRCLE_BRANCH;
    }
  }
  if (process.env.TRAVIS_PULL_REQUEST !== void 0) {
    return process.env.TRAVIS_PULL_REQUEST;
  }
  if (process.env.GITHUB_ACTIONS) {
    if (process.env.GITHUB_REF) {
      const ref = process.env.GITHUB_REF.match(/refs\/pull\/(\d+)\/merge/);
      if (ref) {
        return ref[1];
      }
    }
    if (process.env.GITHUB_HEAD_REF) {
      return process.env.GITHUB_HEAD_REF;
    }
    if (process.env.GITHUB_REF_NAME) {
      return process.env.GITHUB_REF_NAME;
    }
    return "";
  }
  if (process.env.BITBUCKET_PR_ID !== void 0) {
    return process.env.BITBUCKET_PR_ID;
  }
  if (process.env.BITBUCKET_BRANCH !== void 0) {
    return process.env.BITBUCKET_BRANCH;
  }
  if (process.env.BUILD_SOURCEBRANCHNAME !== void 0) {
    return process.env.BUILD_SOURCEBRANCHNAME;
  }
  if (process.env.VERCEL_GIT_COMMIT_REF !== void 0) {
    return process.env.VERCEL_GIT_COMMIT_REF;
  }
  if (process.env.CI_MERGE_REQUEST_IID) {
    return process.env.CI_MERGE_REQUEST_IID;
  }
  if (process.env.CI_COMMIT_BRANCH) {
    return process.env.CI_COMMIT_BRANCH;
  }
  if (process.env.GIT_BRANCH) {
    return process.env.GIT_BRANCH;
  }
  return null;
}
function getMachineInfo() {
  const os = require("os");
  const hasher = (0, import_crypto.createHash)("md5");
  hasher.update(machineIdSync());
  const machineId = hasher.digest("base64");
  return {
    machineId,
    platform: os.platform(),
    version: os.version ? os.version() : "",
    cpuCores: os.cpus().length
  };
}
function parseCommand() {
  const cmdBase = (0, import_path.parse)(process.argv[1]).name;
  const args5 = `${process.argv.slice(2).join(" ")}`;
  return `${cmdBase} ${args5}`;
}
function getNxVersion() {
  const packageJson = JSON.parse((0, import_fs.readFileSync)("package.json").toString());
  const deps = {
    ...packageJson.dependencies || {},
    ...packageJson.devDependencies || {}
  };
  return deps["nx"].trim().match(VERSION_REGEX);
}
function getCiEnvVars(envVarsFromArgs) {
  const allEnvVarsInCurrentProcess = definedEnvVars();
  let envVarsToUseInExecution = {};
  if (envVarsFromArgs == "auto") {
    envVarsToUseInExecution = allEnvVarsInCurrentProcess;
  } else if (envVarsFromArgs) {
    envVarsFromArgs.split(",").map((k) => k.trim()).forEach((key) => {
      if (allEnvVarsInCurrentProcess[key]) {
        envVarsToUseInExecution[key] = allEnvVarsInCurrentProcess[key];
      }
    });
  }
  Object.keys(allEnvVarsInCurrentProcess).filter((key) => key.startsWith("NX_")).forEach((key) => {
    envVarsToUseInExecution[key] = allEnvVarsInCurrentProcess[key];
  });
  if (VERBOSE_LOGGING) {
    output.note({
      title: `Environment variables passed to cloud:`,
      bodyLines: Object.keys(envVarsToUseInExecution)
    });
    output.addNewline();
  }
  return envVarsToUseInExecution;
}
function definedEnvVars() {
  const definedVars = {};
  for (const envName of Object.keys(process.env)) {
    if (envName != void 0 && !DO_NOT_COPY_ENV_VARS.includes(envName) && process.env[envName]) {
      definedVars[envName] = process.env[envName];
    }
  }
  return definedVars;
}
var import_child_process, import_crypto, import_fs, import_path, dotenv, machineIdSync, output, workspaceRoot, UNLIMITED_TIMEOUT, NO_MESSAGES_TIMEOUT, NO_COMPLETED_TASKS_TIMEOUT, UNLIMITED_FILE_SIZE, NX_CLOUD_UNLIMITED_OUTPUT, DEFAULT_FILE_SIZE_LIMIT, DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE, NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT, NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE, NUMBER_OF_AXIOS_RETRIES, NX_NO_CLOUD, NX_CLOUD_RETRY_FLAKY_TASKS, ACCESS_TOKEN, ENCRYPTION_KEY, VERBOSE_LOGGING, NX_CLOUD_NO_TIMEOUTS, NX_CLOUD_CONTRIBUTOR_TESTING, VERSION_REGEX, DO_NOT_COPY_ENV_VARS;
var init_environment = __esm({
  "src/lib/utilities/environment.ts"() {
    "use strict";
    import_child_process = require("child_process");
    import_crypto = require("crypto");
    import_fs = require("fs");
    import_path = require("path");
    init_is_ci();
    dotenv = require_main();
    ({ machineIdSync } = require_dist());
    ({ output, workspaceRoot } = require_nx_imports_light());
    UNLIMITED_TIMEOUT = 9999999;
    NO_MESSAGES_TIMEOUT = process.env.NX_CLOUD_AGENT_TIMEOUT_MS ? Number(process.env.NX_CLOUD_AGENT_TIMEOUT_MS) : 36e5;
    NO_COMPLETED_TASKS_TIMEOUT = process.env.NX_CLOUD_ORCHESTRATOR_TIMEOUT_MS ? Number(process.env.NX_CLOUD_ORCHESTRATOR_TIMEOUT_MS) : 36e5;
    UNLIMITED_FILE_SIZE = 1e3 * 1e3 * 1e4;
    NX_CLOUD_UNLIMITED_OUTPUT = process.env.NX_CLOUD_UNLIMITED_OUTPUT === "true";
    DEFAULT_FILE_SIZE_LIMIT = 1e3 * 1e3 * 300;
    DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE = 166;
    NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT ? Number(process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT) : null;
    NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE != "false";
    NUMBER_OF_AXIOS_RETRIES = process.env.NX_CLOUD_NUMBER_OF_RETRIES ? Number(process.env.NX_CLOUD_NUMBER_OF_RETRIES) : isCI() ? 10 : 1;
    NX_NO_CLOUD = process.env.NX_NO_CLOUD === "true";
    NX_CLOUD_RETRY_FLAKY_TASKS = process.env.NX_CLOUD_RETRY_FLAKY_TASKS !== "false";
    loadEnvVars();
    VERSION_REGEX = /(0|[1-9]\d*)(?:\.(0|[1-9]\d*))(?:\.(0|[1-9]\d*))?(?:-.*)?/;
    DO_NOT_COPY_ENV_VARS = [
      "PWD",
      "HOME",
      "SHELL",
      "LOGNAME",
      "UID",
      "HOSTNAME",
      "MAIL",
      "EDITOR",
      "LANG",
      "TEMP",
      "PATH",
      "TERM",
      "USER",
      "COMMAND_MODE",
      "TMPDIR",
      "TERMINAL_EMULATOR",
      "TERM_SESSION_ID",
      "OLDPWD",
      "MANPATH",
      "PAGER",
      "LESS",
      "LSCOLORS",
      "PNPM_HOME",
      "ZSH",
      "GOPATH",
      "GOROOT",
      "NVM_DIR",
      "NVM_BIN",
      "NVM_INC"
    ];
  }
});

// src/lib/utilities/print-message.ts
function printMessage(message) {
  const padding = includePadding() ? "   " : "";
  if (newTerminalOutput()) {
    process.stdout.write(`${padding}${formatMessage(message)}`);
    output2.addNewline();
    output2.addNewline();
  } else {
    if (runOneCommand()) {
      output2.addNewline();
      process.stdout.write(`${padding}${formatMessage(message)}`);
      output2.addNewline();
      output2.addNewline();
    } else {
      process.stdout.write(`${padding}${formatMessage(message)}`);
      output2.addNewline();
      output2.addNewline();
    }
  }
}
function includePadding() {
  try {
    const packageJson = JSON.parse((0, import_fs2.readFileSync)("package.json").toString());
    const deps = {
      ...packageJson.dependencies || {},
      ...packageJson.devDependencies || {}
    };
    const version = deps["nx"].trim().match(VERSION_REGEX2);
    const major = +version[1];
    if (major < 18) {
      return true;
    }
    if (major > 18) {
      return false;
    }
    const minor = version[2] ? +version[2] : 9999;
    const patch = version[3] ? +version[3] : 9999;
    if (minor === 0 && patch < 5) {
      return true;
    } else {
      return false;
    }
  } catch (e) {
    return false;
  }
}
function newTerminalOutput() {
  try {
    lightClientRequire(
      "nx/src/tasks-runner/life-cycles/dynamic-run-many-terminal-output-life-cycle"
    );
    return true;
  } catch (e) {
    try {
      lightClientRequire(
        "@nrwl/workspace/src/tasks-runner/life-cycles/dynamic-run-many-terminal-output-life-cycle"
      );
      return true;
    } catch (ee) {
      return false;
    }
  }
}
function formatMessage(message) {
  let formattedMessage;
  if (typeof output2.dim === "function") {
    return output2.dim(message);
  } else {
    try {
      return output2.colors.gray(message);
    } catch (e) {
      return message;
    }
  }
}
function runOneCommand() {
  return process.argv.indexOf("run-many") === -1 && process.argv.indexOf("affected") === -1;
}
function formatStringWithPeriod(text) {
  const trimmedText = text.trim();
  return trimmedText.endsWith(".") ? trimmedText : `${trimmedText}.`;
}
var import_fs2, output2, VERSION_REGEX2;
var init_print_message = __esm({
  "src/lib/utilities/print-message.ts"() {
    "use strict";
    import_fs2 = require("fs");
    init_light_client_require();
    ({ output: output2 } = require_nx_imports_light());
    VERSION_REGEX2 = /(0|[1-9]\d*)(?:\.(0|[1-9]\d*))(?:\.(0|[1-9]\d*))?(?:-.*)?/;
  }
});

// src/lib/utilities/waiter.ts
function wait(time) {
  return new Promise((res) => {
    setTimeout(() => res(null), time);
  });
}
var init_waiter = __esm({
  "src/lib/utilities/waiter.ts"() {
    "use strict";
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args5) {
        this.emit.apply(this, args5);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args5) {
      if (this._released) {
        this.emit.apply(this, args5);
        return;
      }
      if (args5[0] === "data") {
        this.dataSize += args5[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args5);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value2 = stream;
      this.write(value2);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
        this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
        this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path5) {
      if (!path5 || typeof path5 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path5).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    "use strict";
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    "use strict";
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    "use strict";
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    "use strict";
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output37) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output37;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    "use strict";
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    "use strict";
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    "use strict";
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    "use strict";
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path5 = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var populate = require_populate();
    module2.exports = FormData2;
    util.inherits(FormData2, CombinedStream);
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value2, options) {
      options = options || {};
      if (typeof options == "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value2 == "number") {
        value2 = "" + value2;
      }
      if (util.isArray(value2)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value2, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value2);
      append(footer);
      this._trackLength(header, value2, options);
    };
    FormData2.prototype._trackLength = function(header, value2, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += +options.knownLength;
      } else if (Buffer.isBuffer(value2)) {
        valueLength = value2.length;
      } else if (typeof value2 === "string") {
        valueLength = Buffer.byteLength(value2);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value2 || !value2.path && !(value2.readable && value2.hasOwnProperty("httpVersion")) && !(value2 instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value2);
      }
    };
    FormData2.prototype._lengthRetriever = function(value2, callback) {
      if (value2.hasOwnProperty("fd")) {
        if (value2.end != void 0 && value2.end != Infinity && value2.start != void 0) {
          callback(null, value2.end + 1 - (value2.start ? value2.start : 0));
        } else {
          fs.stat(value2.path, function(err, stat) {
            var fileSize;
            if (err) {
              callback(err);
              return;
            }
            fileSize = stat.size - (value2.start ? value2.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (value2.hasOwnProperty("httpVersion")) {
        callback(null, +value2.headers["content-length"]);
      } else if (value2.hasOwnProperty("httpModule")) {
        value2.on("response", function(response) {
          value2.pause();
          callback(null, +response.headers["content-length"]);
        });
        value2.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value2, options) {
      if (typeof options.header == "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value2, options);
      var contentType = this._getContentType(value2, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header == "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (!headers.hasOwnProperty(prop))
          continue;
        header = headers[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value2, options) {
      var filename, contentDisposition;
      if (typeof options.filepath === "string") {
        filename = path5.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value2.name || value2.path) {
        filename = path5.basename(options.filename || value2.name || value2.path);
      } else if (value2.readable && value2.hasOwnProperty("httpVersion")) {
        filename = path5.basename(value2.client._httpMessage.path || "");
      }
      if (filename) {
        contentDisposition = 'filename="' + filename + '"';
      }
      return contentDisposition;
    };
    FormData2.prototype._getContentType = function(value2, options) {
      var contentType = options.contentType;
      if (!contentType && value2.name) {
        contentType = mime.lookup(value2.name);
      }
      if (!contentType && value2.path) {
        contentType = mime.lookup(value2.path);
      }
      if (!contentType && value2.readable && value2.hasOwnProperty("httpVersion")) {
        contentType = value2.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && typeof value2 == "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (userHeaders.hasOwnProperty(header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      var boundary = "--------------------------";
      for (var i = 0; i < 24; i++) {
        boundary += Math.floor(Math.random() * 10).toString(16);
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request, options, defaults = { method: "post" };
      if (typeof params == "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol == "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol == "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// ../../../node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS({
  "../../../node_modules/debug/node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../../node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env3) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env3).forEach((key) => {
        createDebug[key] = env3[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args5) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args5[0] = createDebug.coerce(args5[0]);
          if (typeof args5[0] !== "string") {
            args5.unshift("%O");
          }
          let index = 0;
          args5[0] = args5[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args5[index];
              match = formatter.call(self2, val);
              args5.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args5);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args5);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../../../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../../../node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args5) {
      args5[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args5[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args5.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args5[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args5.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../../node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv2 = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv2.indexOf(prefix + flag);
      const terminatorPosition = argv2.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../../node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env3 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env3) {
      if (env3.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env3.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env3.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env3.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env3.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env3) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env3) || env3.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env3) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env3.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env3) {
        const version = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env3.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env3.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env3) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../../node_modules/debug/src/node.js
var require_node = __commonJS({
  "../../../node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args5) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args5[0] = prefix + args5[0].split("\n").join("\n" + prefix);
        args5.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args5[0] = getDate() + name + " " + args5[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args5) {
      return process.stderr.write(util.format(...args5) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../../../node_modules/debug/src/index.js
var require_src = __commonJS({
  "../../../node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    "use strict";
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var useNativeURL = false;
    try {
      assert(new URL2());
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value2) {
      this._options.headers[name] = value2;
      this._currentRequest.setHeader(name, value2);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL2(relative, base) : parseUrl(url.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    }
    function isFunction(value2) {
      return typeof value2 === "function";
    }
    function isBuffer(value2) {
      return typeof value2 === "object" && "length" in value2;
    }
    function isURL(value2) {
      return URL2 && value2 instanceof URL2;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/node/axios.cjs"(exports2, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var EventEmitter = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    var EventEmitter__default = /* @__PURE__ */ _interopDefaultLegacy(EventEmitter);
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      const pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function merge() {
      const result = {};
      const assignValue = (val, key) => {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      let i = thing.length;
      if (!isNumber(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[_-\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        if (reducer(descriptor, name, obj) !== false) {
          reducedDescriptors[name] = descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        const value2 = obj[name];
        if (!isFunction(value2))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value2) => {
          obj[value2] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value2, defaultValue) => {
      value2 = +value2;
      return Number.isFinite(value2) ? value2 : defaultValue;
    };
    var utils = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils.isPlainObject(thing) || utils.isArray(thing);
    }
    function removeBrackets(key) {
      return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path5, key, dots) {
      if (!path5)
        return key;
      return path5.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function isSpecCompliant(thing) {
      return thing && utils.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
    }
    function toFormData(obj, formData, options) {
      if (!utils.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && isSpecCompliant(formData);
      if (!utils.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value2) {
        if (value2 === null)
          return "";
        if (utils.isDate(value2)) {
          return value2.toISOString();
        }
        if (!useBlob && utils.isBlob(value2)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils.isArrayBuffer(value2) || utils.isTypedArray(value2)) {
          return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
        }
        return value2;
      }
      function defaultVisitor(value2, key, path5) {
        let arr = value2;
        if (value2 && !path5 && typeof value2 === "object") {
          if (utils.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value2 = JSON.stringify(value2);
          } else if (utils.isArray(value2) && isFlatArray(value2) || (utils.isFileList(value2) || utils.endsWith(key, "[]") && (arr = utils.toArray(value2)))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value2)) {
          return true;
        }
        formData.append(renderKey(path5, key, dots), convertValue(value2));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value2, path5) {
        if (utils.isUndefined(value2))
          return;
        if (stack.indexOf(value2) !== -1) {
          throw Error("Circular reference detected in " + path5.join("."));
        }
        stack.push(value2);
        utils.forEach(value2, function each(el, key) {
          const result = !(utils.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils.isString(key) ? key.trim() : key,
            path5,
            exposedHelpers
          );
          if (result === true) {
            build(el, path5 ? path5.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value2) {
      this._pairs.push([name, value2]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value2) {
        return encoder.call(this, value2, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams = url__default["default"].URLSearchParams;
    var platform = {
      isNode: true,
      classes: {
        URLSearchParams,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      protocols: ["http", "https", "file", "data"]
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value2, key, path5, helpers) {
          if (utils.isBuffer(value2)) {
            this.append(key, value2.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path5, value2, target, index) {
        let name = path5[index++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path5.length;
        name = !name && utils.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils.hasOwnProp(target, name)) {
            target[name] = [target[name], value2];
          } else {
            target[name] = value2;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path5, value2, target[name], index);
        if (result && utils.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
        const obj = {};
        utils.forEachEntry(formData, (name, value2) => {
          buildPath(parsePropPath(name), value2, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function settle(resolve2, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.1.3";
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match = DATA_URL_PATTERN.exec(uri);
        if (!match) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match[1];
        const isBase64 = match[2];
        const body = match[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    var ignoreDuplicateOf = utils.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser3(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    var $defaults = Symbol("defaults");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value2) {
      if (value2 === false || value2 == null) {
        return value2;
      }
      return utils.isArray(value2) ? value2.map(normalizeValue) : String(value2);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    function matchHeaderValue(context, value2, header, filter) {
      if (utils.isFunction(filter)) {
        return filter.call(this, value2, header);
      }
      if (!utils.isString(value2))
        return;
      if (utils.isString(filter)) {
        return value2.indexOf(filter) !== -1;
      }
      if (utils.isRegExp(filter)) {
        return filter.test(value2);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    function AxiosHeaders(headers, defaults2) {
      headers && this.set(headers);
      this[$defaults] = defaults2 || null;
    }
    Object.assign(AxiosHeaders.prototype, {
      set: function(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = findKey(self2, lHeader);
          if (key && _rewrite !== true && (self2[key] === false || _rewrite === false)) {
            return;
          }
          self2[key || _header] = normalizeValue(_value);
        }
        if (utils.isPlainObject(header)) {
          utils.forEach(header, (_value, _header) => {
            setHeader(_value, _header, valueOrRewrite);
          });
        } else {
          setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      },
      get: function(header, parser3) {
        header = normalizeHeader(header);
        if (!header)
          return void 0;
        const key = findKey(this, header);
        if (key) {
          const value2 = this[key];
          if (!parser3) {
            return value2;
          }
          if (parser3 === true) {
            return parseTokens(value2);
          }
          if (utils.isFunction(parser3)) {
            return parser3.call(this, value2, key);
          }
          if (utils.isRegExp(parser3)) {
            return parser3.exec(value2);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      },
      has: function(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = findKey(this, header);
          return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      },
      delete: function(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      },
      clear: function() {
        return Object.keys(this).forEach(this.delete.bind(this));
      },
      normalize: function(format2) {
        const self2 = this;
        const headers = {};
        utils.forEach(this, (value2, header) => {
          const key = findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value2);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value2);
          headers[normalized] = true;
        });
        return this;
      },
      toJSON: function(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils.forEach(
          Object.assign({}, this[$defaults] || null, this),
          (value2, header) => {
            if (value2 == null || value2 === false)
              return;
            obj[header] = asStrings && utils.isArray(value2) ? value2.join(", ") : value2;
          }
        );
        return obj;
      }
    });
    Object.assign(AxiosHeaders, {
      from: function(thing) {
        if (utils.isString(thing)) {
          return new this(parseHeaders(thing));
        }
        return thing instanceof this ? thing : new this(thing);
      },
      accessor: function(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    });
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
    utils.freezeMethods(AxiosHeaders.prototype);
    utils.freezeMethods(AxiosHeaders);
    function throttle(fn, freq) {
      let timestamp = 0;
      const threshold = 1e3 / freq;
      let timer = null;
      return function throttled(force, args5) {
        const now = Date.now();
        if (force || now - timestamp > threshold) {
          if (timer) {
            clearTimeout(timer);
            timer = null;
          }
          timestamp = now;
          return fn.apply(null, args5);
        }
        if (!timer) {
          timer = setTimeout(() => {
            timer = null;
            timestamp = Date.now();
            return fn.apply(null, args5);
          }, threshold - (now - timestamp));
        }
      };
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    var kInternals = Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const self2 = this;
        const internals = this[kInternals] = {
          length: options.length,
          timeWindow: options.timeWindow,
          ticksRate: options.ticksRate,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
        let bytesNotified = 0;
        internals.updateProgress = throttle(function throttledHandler() {
          const totalBytes = internals.length;
          const bytesTransferred = internals.bytesSeen;
          const progressBytes = bytesTransferred - bytesNotified;
          if (!progressBytes || self2.destroyed)
            return;
          const rate = _speedometer(progressBytes);
          bytesNotified = bytesTransferred;
          process.nextTick(() => {
            self2.emit("progress", {
              "loaded": bytesTransferred,
              "total": totalBytes,
              "progress": totalBytes ? bytesTransferred / totalBytes : void 0,
              "bytes": progressBytes,
              "rate": rate ? rate : void 0,
              "estimated": rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : void 0
            });
          });
        }, internals.ticksRate);
        const onFinish = () => {
          internals.updateProgress(true);
        };
        this.once("end", onFinish);
        this.once("error", onFinish);
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const self2 = this;
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        function pushChunk(_chunk, _callback) {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          if (internals.isCaptured) {
            internals.updateProgress();
          }
          if (self2.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        }
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
      setLength(length) {
        this[kInternals].length = +length;
        return this;
      }
    };
    var isBrotliSupported = utils.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    function dispatchBeforeRedirect(options) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv.getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base64;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        let data = config.data;
        const responseType = config.responseType;
        const responseEncoding = config.responseEncoding;
        const method = config.method.toUpperCase();
        let isFinished;
        let isDone;
        let rejected = false;
        let req;
        const emitter = new EventEmitter__default["default"]();
        function onFinished() {
          if (isFinished)
            return;
          isFinished = true;
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(abort);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", abort);
          }
          emitter.removeAllListeners();
        }
        function done(value2, isRejected) {
          if (isDone)
            return;
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
          }
          isRejected ? rejectPromise(value2) : resolvePromise(value2);
        }
        const resolve2 = function resolve3(value2) {
          done(value2);
        };
        const reject = function reject2(value2) {
          done(value2, true);
        };
        function abort(reason) {
          emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req) : reason);
        }
        emitter.once("abort", reject);
        if (config.cancelToken || config.signal) {
          config.cancelToken && config.cancelToken.subscribe(abort);
          if (config.signal) {
            config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
          }
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        const parsed = new URL(fullPath);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          let convertedData;
          if (method !== "GET") {
            return settle(resolve2, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config
            });
          }
          try {
            convertedData = fromDataURI(config.url, responseType === "blob", {
              Blob: config.env && config.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              data = utils.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve2, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: {},
            config
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        const headers = AxiosHeaders.from(config.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const onDownloadProgress = config.onDownloadProgress;
        const onUploadProgress = config.onUploadProgress;
        const maxRate = config.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
        } else if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data))
            ;
          else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          headers.set("Content-Length", data.length, false);
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
        }
        const contentLength = +headers.getContentLength();
        if (utils.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream({
            length: utils.toFiniteNumber(contentLength),
            maxRate: utils.toFiniteNumber(maxUploadRate)
          })], utils.noop);
          onUploadProgress && data.on("progress", (progress) => {
            onUploadProgress(Object.assign(progress, {
              upload: true
            }));
          });
        }
        let auth = void 0;
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path5;
        try {
          path5 = buildURL(
            parsed.pathname + parsed.search,
            config.params,
            config.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set("Accept-Encoding", "gzip, deflate, br", false);
        const options = {
          path: path5,
          method,
          headers: headers.toJSON(),
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth,
          protocol,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {}
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsRequest ? https__default["default"] : http__default["default"];
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          if (config.beforeRedirect) {
            options.beforeRedirects.config = config.beforeRedirect;
          }
          transport = isHttpsRequest ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed)
            return;
          const streams = [res];
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config.decompress !== false) {
            if (data && data.length === 0 && res.headers["content-encoding"]) {
              delete res.headers["content-encoding"];
            }
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                streams.push(zlib__default["default"].createUnzip());
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress());
                  delete res.headers["content-encoding"];
                }
            }
          }
          if (onDownloadProgress) {
            const responseLength = +res.headers["content-length"];
            const transformStream = new AxiosTransformStream({
              length: utils.toFiniteNumber(responseLength),
              maxRate: utils.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", (progress) => {
              onDownloadProgress(Object.assign(progress, {
                download: true
              }));
            });
            streams.push(transformStream);
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils.noop) : streams[0];
          const offListeners = stream__default["default"].finished(responseStream, () => {
            offListeners();
            onFinished();
          });
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders(res.headers),
            config,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve2, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                reject(new AxiosError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed)
                return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve2, reject, response);
            });
          }
          emitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        emitter.once("abort", (err) => {
          reject(err);
          req.destroy(err);
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          const timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone)
              return;
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              req
            ));
            abort();
          });
        }
        if (utils.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config, req));
            }
          });
          data.pipe(req);
        } else {
          req.end(data);
        }
      });
    }
    var cookies = platform.isStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      /* @__PURE__ */ function standardBrowserEnv() {
        return {
          write: function write(name, value2, expires, path5, domain, secure) {
            const cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value2));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path5)) {
              cookie.push("path=" + path5);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove2(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove2() {
          }
        };
      }()
    );
    var isURLSameOrigin = platform.isStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url2) {
          let href = url2;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders.from(config.headers).normalize();
        const responseType = config.responseType;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData) && platform.isStandardBrowserEnv) {
          requestHeaders.setContentType(false);
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value2) {
            resolve2(value2);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.isStandardBrowserEnv) {
          const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
          if (xsrfValue) {
            requestHeaders.set(config.xsrfHeaderName, xsrfValue);
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    }
    var adapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    var adapters$1 = {
      getAdapter: (nameOrAdapter) => {
        if (utils.isString(nameOrAdapter)) {
          const adapter = adapters[nameOrAdapter];
          if (!nameOrAdapter) {
            throw Error(
              utils.hasOwnProp(nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Can not resolve adapter '${nameOrAdapter}'`
            );
          }
          return adapter;
        }
        if (!utils.isFunction(nameOrAdapter)) {
          throw new TypeError("adapter is not a function");
        }
        return nameOrAdapter;
      },
      adapters
    };
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function getDefaultAdapter() {
      let adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = adapters$1.getAdapter("xhr");
      } else if (typeof process !== "undefined" && utils.kindOf(process) === "process") {
        adapter = adapters$1.getAdapter("http");
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser3, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser3 || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils.isObject(data);
        if (isObjectPayload && utils.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils.isFormData(data);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    function transformData(fns, response) {
      const config = this || defaults;
      const context = response || config;
      const headers = AxiosHeaders.from(context.headers);
      let data = context.data;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value2) {
      return !!(value2 && value2.__CANCEL__);
    }
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      const adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      const mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(prop);
        utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage2(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value2, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage2(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage2(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value2, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value2 = options[opt];
          const result = value2 === void 0 || validator2(value2, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer !== void 0) {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        const defaultHeaders = config.headers && utils.merge(
          config.headers.common,
          config.headers[config.method]
        );
        defaultHeaders && utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          function cleanHeaderConfig(method) {
            delete config.headers[method];
          }
        );
        config.headers = new AxiosHeaders(config.headers, defaultHeaders);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners)
            return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve2) => {
            token.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils.isObject(payload) && payload.isAxiosError === true;
    }
    function createInstance(defaultConfig) {
      const context = new Axios(defaultConfig);
      const instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context, { allOwnKeys: true });
      utils.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios3 = createInstance(defaults);
    axios3.Axios = Axios;
    axios3.CanceledError = CanceledError;
    axios3.CancelToken = CancelToken;
    axios3.isCancel = isCancel;
    axios3.VERSION = VERSION;
    axios3.toFormData = toFormData;
    axios3.AxiosError = AxiosError;
    axios3.Cancel = axios3.CanceledError;
    axios3.all = function all(promises) {
      return Promise.all(promises);
    };
    axios3.spread = spread;
    axios3.isAxiosError = isAxiosError;
    axios3.formToJSON = (thing) => {
      return formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
    };
    module2.exports = axios3;
  }
});

// src/lib/utilities/axios.ts
function createApiAxiosInstance(options, timeout = 1e4) {
  let axiosConfigBuilder = (axiosConfig) => axiosConfig;
  const baseUrl = process.env.NX_CLOUD_API || options.url || "https://cloud.nx.app";
  const accessToken = ACCESS_TOKEN ? ACCESS_TOKEN : options.accessToken;
  if (!accessToken) {
    throw new Error(
      `Unable to authenticate. Either define accessToken in nx.json or set the NX_CLOUD_ACCESS_TOKEN env variable.`
    );
  }
  if (options.customProxyConfigPath) {
    const { nxCloudProxyConfig } = require((0, import_path2.join)(process.cwd(), options.customProxyConfigPath));
    axiosConfigBuilder = nxCloudProxyConfig ?? axiosConfigBuilder;
  }
  return axios.create(
    axiosConfigBuilder({
      baseURL: baseUrl,
      timeout: NX_CLOUD_NO_TIMEOUTS ? UNLIMITED_TIMEOUT : timeout,
      headers: {
        authorization: accessToken,
        "Nx-Cloud-Client-Version": options.clientVersion || "unknown"
      }
    })
  );
}
async function printDuration(description, callback) {
  const b = /* @__PURE__ */ new Date();
  const res = await callback();
  const a = /* @__PURE__ */ new Date();
  if (VERBOSE_LOGGING) {
    console.log(`${description}: ${a.getTime() - b.getTime()}`);
  }
  return res;
}
async function axiosSingleTry(axiosCallCreator) {
  try {
    return await axiosCallCreator();
  } catch (e) {
    const code = e.response && e.response.status || e.code;
    let message = e.response ? e.response.data.message ? e.response.data.message : e.response.data : e.message;
    message = formatStringWithPeriod(message);
    let bodyLines = (message == null ? void 0 : message.split("\n")) || [];
    throw new AxiosException(
      "failure",
      generateExceptionMessage(code),
      e,
      bodyLines
    );
  }
}
async function axiosMultipleTries(axiosCallCreator, retriesLeft = NUMBER_OF_AXIOS_RETRIES) {
  var _a2, _b2, _c2;
  try {
    return await axiosSingleTry(axiosCallCreator);
  } catch (e) {
    const code = ((_a2 = e.axiosException) == null ? void 0 : _a2.code) ?? e.code;
    const message = ((_b2 = e.axiosException) == null ? void 0 : _b2.message) ?? e.message;
    if (retriesLeft === 0 || code === 401 || code === 403) {
      if (VERBOSE_LOGGING) {
        output3.note({
          title: `Connection to Nx Cloud failed with status code ${code}`,
          bodyLines: (_c2 = e.axiosException) == null ? void 0 : _c2.bodyLines
        });
      }
      throw e.axiosException ?? e;
    } else if (code === 429) {
      if (!error429Promise) {
        const retryAfter = 1e4 + (NUMBER_OF_AXIOS_RETRIES + 1 - retriesLeft) * 6e4 * Math.random();
        output3.note({
          title: `Received Code ${code}. ${message ? `${message}. ` : ""}Retrying in ${millisecondsToSeconds(
            retryAfter
          )}s.`
        });
        error429Promise = wait(retryAfter);
      }
      await error429Promise;
      error429Promise = null;
    } else {
      const retryAfter = 1e3 + (NUMBER_OF_AXIOS_RETRIES + 1 - retriesLeft) * 4e3 * Math.random();
      if (VERBOSE_LOGGING) {
        output3.note({
          title: `Received Code ${code}. Retrying in ${millisecondsToSeconds(
            retryAfter
          )}s.`
        });
      }
      await wait(retryAfter);
    }
    return axiosMultipleTries(axiosCallCreator, retriesLeft - 1);
  }
}
function millisecondsToSeconds(milliseconds) {
  return Math.round(milliseconds / 1e3);
}
function generateExceptionMessage(code) {
  let messagePrefix = `${code}:`;
  switch (code) {
    case 400:
      return `${messagePrefix} Invalid request to Nx Cloud.`;
    case 403:
      return `${messagePrefix} Access to resource is not authorized.`;
    case 404:
      return `${messagePrefix} Cannot find requested resource.`;
    case 500:
      return `${messagePrefix} Unexpected server error.`;
    case "ECONNABORTED":
    case "ETIMEOUT":
      return `${messagePrefix} Connection timed out, check for other network problems.`;
    case "ECONNRESET":
      return `${messagePrefix} The connection to Nx Cloud was closed suddenly.`;
    case "ECONNREFUSED":
      return `${messagePrefix} Cannot connect to server. Please check that you have the correct server address and port number.`;
    case "ENOTFOUND":
      return `${messagePrefix} DNS error due to invalid host. Are you accessing Nx Cloud from a network proxy?`;
    case "SELF_SIGNED_CERT_IN_CHAIN":
      return `${messagePrefix} Found a self-signed cert in certificate chain. Ensure you have verified trust for all certs in your network.`;
    default:
      return `${messagePrefix} Unable to connect to Nx Cloud.`;
  }
}
var import_path2, output3, axios, AxiosException, error429Promise;
var init_axios = __esm({
  "src/lib/utilities/axios.ts"() {
    "use strict";
    import_path2 = require("path");
    init_environment();
    init_print_message();
    init_waiter();
    ({ output: output3 } = require_nx_imports_light());
    axios = require_axios();
    AxiosException = class {
      constructor(type, message, axiosException, bodyLines) {
        this.type = type;
        this.message = message;
        this.axiosException = axiosException;
        this.bodyLines = bodyLines;
      }
    };
    error429Promise = null;
  }
});

// src/lib/utilities/get-vcs-context.ts
function getVcsContext() {
  for (const ciPlatformHelper of Object.values(ciPlatformHelpers)) {
    if (ciPlatformHelper.detectorFn(process.env)) {
      const vcsContext = ciPlatformHelper.contextRetrieverFn(process.env);
      if (VERBOSE_LOGGING) {
        console.log(JSON.stringify(vcsContext, null, 2));
      }
      return vcsContext;
    }
  }
  if (VERBOSE_LOGGING)
    console.log(
      "[Nx Cloud] Unable to detect a VCS context from the environment."
    );
  return null;
}
function detectCircleCi(env3) {
  return env3.CIRCLECI === "true";
}
function retrieveContextFromCircleCi(env3) {
  if (VERBOSE_LOGGING)
    console.log("[Nx Cloud] Detected Env: CircleCI");
  const getBranch3 = (env4) => {
    if (env4.CIRCLE_PR_NUMBER !== void 0) {
      return env4.CIRCLE_PR_NUMBER;
    }
    if (env4.CIRCLE_PULL_REQUEST !== void 0) {
      const p = env4.CIRCLE_PULL_REQUEST.split("/");
      return p[p.length - 1];
    }
    if (env4.CIRCLE_BRANCH !== void 0) {
      return env4.CIRCLE_BRANCH;
    }
    return "unknown";
  };
  const getAuthor = (env4) => {
    if (env4.CIRCLE_USERNAME !== void 0) {
      return env4.CIRCLE_USERNAME;
    }
    if (env4.CIRCLE_PR_USERNAME) {
      return env4.CIRCLE_PR_USERNAME;
    }
    return null;
  };
  return {
    branch: getBranch3(env3),
    ref: env3.CIRCLE_BRANCH ?? null,
    title: getLatestCommitMessage(),
    headSha: env3.CIRCLE_SHA1 ?? "unknown",
    baseSha: null,
    commitLink: env3.CIRCLE_PULL_REQUEST ?? null,
    author: getAuthor(env3),
    authorUrl: null,
    authorAvatarUrl: null,
    repositoryUrl: env3.CIRCLE_REPOSITORY_URL ?? null,
    platformName: "CIRCLE_CI"
  };
}
function detectTravisCi(env3) {
  return env3.TRAVIS === "true";
}
function retrieveContextFromTravisCi(env3) {
  if (VERBOSE_LOGGING)
    console.log("[Nx Cloud] Detected Env: TravisCI");
  const getBranch3 = (env4) => {
    if (env4.TRAVIS_EVENT_TYPE === "pull_request") {
      return env4.TRAVIS_PULL_REQUEST;
    }
    return env4.TRAVIS_BRANCH;
  };
  return {
    branch: getBranch3(env3),
    ref: null,
    title: getLatestCommitMessage(),
    headSha: env3.TRAVIS_COMMIT ?? "unknown",
    baseSha: null,
    commitLink: null,
    author: getLatestCommitAuthor(),
    authorUrl: null,
    authorAvatarUrl: null,
    repositoryUrl: null,
    platformName: "TRAVIS_CI"
  };
}
function detectGithubActions(env3) {
  return env3.GITHUB_ACTIONS === "true";
}
function retrieveContextFromGithubActions(env3) {
  if (VERBOSE_LOGGING)
    console.log("[Nx Cloud] Detected Env: GitHub Actions");
  const getBranch3 = (env4) => {
    if (env4.GITHUB_REF) {
      const ref = env4.GITHUB_REF.match(/refs\/pull\/(\d+)\/merge/);
      if (ref) {
        return ref[1];
      }
    }
    if (env4.GITHUB_HEAD_REF) {
      return env4.GITHUB_HEAD_REF;
    }
    if (env4.GITHUB_REF_NAME) {
      return env4.GITHUB_REF_NAME;
    }
    return "unknown";
  };
  const getCommitLink = (env4) => {
    const githubRepositoryBaseUrl = `${env4.GITHUB_SERVER_URL}/${env4.GITHUB_REPOSITORY}`;
    if (env4.GITHUB_EVENT_NAME === "pull_request") {
      return `${githubRepositoryBaseUrl}/pull/${getBranch3(env4)}`;
    }
    return `${githubRepositoryBaseUrl}/commit/${env4.GITHUB_SHA}`;
  };
  const getRef2 = (env4) => {
    if (env4.GITHUB_HEAD_REF) {
      return env4.GITHUB_HEAD_REF;
    }
    if (env4.GITHUB_REF) {
      return env4.GITHUB_REF;
    }
    return null;
  };
  return {
    branch: getBranch3(env3),
    ref: getRef2(env3),
    title: getLatestCommitMessage(),
    headSha: env3.GITHUB_SHA ?? "unknown",
    baseSha: null,
    commitLink: getCommitLink(env3),
    author: env3.GITHUB_ACTOR ?? null,
    authorUrl: `${env3.GITHUB_SERVER_URL}/${env3.GITHUB_ACTOR}`,
    authorAvatarUrl: `${env3.GITHUB_SERVER_URL}/${env3.GITHUB_ACTOR}.png`,
    repositoryUrl: `${env3.GITHUB_SERVER_URL}/${env3.GITHUB_REPOSITORY}`,
    platformName: "GITHUB_ACTIONS"
  };
}
function detectBitbucketPipelines(env3) {
  return env3.BITBUCKET_BUILD_NUMBER != null;
}
function retrieveContextFromBitbucketPipelines(env3) {
  if (VERBOSE_LOGGING)
    console.log("[Nx Cloud] Detected Env: BitBucket Pipelines");
  return {
    branch: env3.BITBUCKET_PR_ID ?? env3.BITBUCKET_BRANCH ?? "unknown",
    ref: null,
    title: getLatestCommitMessage(),
    headSha: env3.BITBUCKET_COMMIT ?? "unknown",
    baseSha: null,
    commitLink: null,
    author: getLatestCommitAuthor(),
    authorUrl: null,
    authorAvatarUrl: null,
    repositoryUrl: env3.BITBUCKET_GIT_HTTP_ORIGIN ?? null,
    platformName: "BITBUCKET_PIPELINES"
  };
}
function detectAzureDevops(env3) {
  return env3.BUILD_BUILDID !== void 0 && env3.AGENT_NAME !== void 0;
}
function retrieveContextFromAzureDevops(env3) {
  if (VERBOSE_LOGGING)
    console.log("[Nx Cloud] Detected Env: Azure DevOps");
  return {
    branch: env3.SYSTEM_PULLREQUEST_PULLREQUESTNUMBER ?? env3.BUILD_SOURCEBRANCHNAME ?? "unknown",
    ref: null,
    title: getLatestCommitMessage(),
    headSha: extractGitSha() ?? "unknown",
    baseSha: null,
    commitLink: null,
    author: env3.BUILD_REQUESTEDFOR ?? null,
    authorUrl: null,
    authorAvatarUrl: null,
    repositoryUrl: env3.SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI ?? env3.BUILD_REPOSITORY_URI ?? null,
    platformName: "AZURE_DEVOPS"
  };
}
function detectGitlabPipelines(env3) {
  return env3.GITLAB_CI === "true";
}
function retrieveContextFromGitlabPipelines(env3) {
  if (VERBOSE_LOGGING)
    console.log("[Nx Cloud] Detected Env: GitLab Pipelines");
  const getBranch3 = (env4) => {
    if (env4.CI_MERGE_REQUEST_IID) {
      return env4.CI_MERGE_REQUEST_IID;
    }
    if (env4.CI_COMMIT_BRANCH) {
      return env4.CI_COMMIT_BRANCH;
    }
    return "unknown";
  };
  return {
    branch: getBranch3(env3),
    ref: env3.CI_COMMIT_REF_NAME ?? null,
    title: getLatestCommitMessage(),
    headSha: extractGitSha() ?? "unknown",
    baseSha: null,
    commitLink: null,
    author: env3.GITLAB_USER_NAME ?? null,
    authorUrl: null,
    authorAvatarUrl: null,
    repositoryUrl: env3.CI_REPOSITORY_URL ?? null,
    platformName: "GITLAB_PIPELINES"
  };
}
function detectNxCloud(env3) {
  return env3.NX_CLOUD_VERSION != null && env3.NX_CLOUD_VERSION !== "";
}
function retrieveContextFromNxCloud(env3) {
  if (VERBOSE_LOGGING)
    console.log("[Nx Cloud] Detected Env: Nx Cloud");
  return {
    branch: getBranch2() ?? "unknown",
    ref: getRef(),
    title: getLatestCommitMessage(),
    headSha: extractGitSha() ?? "unknown",
    baseSha: null,
    commitLink: null,
    author: getLatestCommitAuthor(),
    authorUrl: null,
    authorAvatarUrl: null,
    repositoryUrl: null,
    platformName: "NX_CLOUD"
  };
}
function getLatestCommitMessage() {
  try {
    const output37 = (0, import_child_process2.execSync)("git log -1 --pretty=%B", { encoding: "utf-8" });
    return output37.trim();
  } catch {
    return null;
  }
}
function getLatestCommitAuthor() {
  try {
    const output37 = (0, import_child_process2.execSync)("git log -1 --pretty=%aN", { encoding: "utf-8" });
    return output37.trim();
  } catch {
    return null;
  }
}
function getBranch2() {
  try {
    const output37 = (0, import_child_process2.execSync)("git branch --show-current", { encoding: "utf-8" });
    return output37.trim();
  } catch {
    return null;
  }
}
function getRef() {
  try {
    const output37 = (0, import_child_process2.execSync)("git rev-parse --abbrev-ref HEAD", {
      encoding: "utf-8"
    });
    return output37.trim();
  } catch {
    return null;
  }
}
var import_child_process2, ciPlatformHelpers;
var init_get_vcs_context = __esm({
  "src/lib/utilities/get-vcs-context.ts"() {
    "use strict";
    import_child_process2 = require("child_process");
    init_environment();
    ciPlatformHelpers = {
      CIRCLE_CI: {
        detectorFn: detectCircleCi,
        contextRetrieverFn: retrieveContextFromCircleCi
      },
      TRAVIS_CI: {
        detectorFn: detectTravisCi,
        contextRetrieverFn: retrieveContextFromTravisCi
      },
      GITHUB_ACTIONS: {
        detectorFn: detectGithubActions,
        contextRetrieverFn: retrieveContextFromGithubActions
      },
      BITBUCKET_PIPELINES: {
        detectorFn: detectBitbucketPipelines,
        contextRetrieverFn: retrieveContextFromBitbucketPipelines
      },
      AZURE_DEVOPS: {
        detectorFn: detectAzureDevops,
        contextRetrieverFn: retrieveContextFromAzureDevops
      },
      GITLAB_PIPELINES: {
        detectorFn: detectGitlabPipelines,
        contextRetrieverFn: retrieveContextFromGitlabPipelines
      },
      NX_CLOUD: {
        detectorFn: detectNxCloud,
        contextRetrieverFn: retrieveContextFromNxCloud
      }
    };
  }
});

// src/lib/core/api/run-group.api.ts
var import_util, import_zlib, output4, RunGroupApi;
var init_run_group_api = __esm({
  "src/lib/core/api/run-group.api.ts"() {
    "use strict";
    import_util = require("util");
    import_zlib = require("zlib");
    init_axios();
    init_get_vcs_context();
    ({ output: output4 } = require_nx_imports_light());
    RunGroupApi = class {
      constructor(options) {
        this.apiAxiosInstance = createApiAxiosInstance(options);
      }
      async createRunGroup(branch, runGroup, ciExecutionId, ciExecutionEnv, stopAgentsOnFailure, agentCount, stopAgentsAfter, distributeOn, commitSha, commitRef, affectedProjectRatio, envVars, requireExplicitCompletion = false, touchedProjects = []) {
        var _a2, _b2;
        try {
          await this.apiAxiosInstance.post(
            "/nx-cloud/executions/create-run-group",
            {
              branch,
              runGroup,
              ciExecutionId,
              ciExecutionEnv,
              stopAgentsOnFailure,
              agentCount,
              stopAgentsAfter,
              commitSha,
              distributeOn,
              affectedProjectRatio,
              vcsContext: getVcsContext(),
              envVars,
              requireExplicitCompletion,
              touchedProjects
            }
          );
        } catch (e) {
          output4.error({
            title: e.message,
            bodyLines: ((_b2 = (_a2 = e.response) == null ? void 0 : _a2.data) == null ? void 0 : _b2.split("\n")) || []
          });
          process.exit(1);
        }
      }
      async completeRunGroup(branch, runGroup, ciExecutionId, ciExecutionEnv) {
        try {
          await this.apiAxiosInstance.post(
            "/nx-cloud/executions/complete-run-group",
            {
              branch,
              runGroup,
              ciExecutionId,
              ciExecutionEnv,
              vcsContext: getVcsContext()
            }
          );
        } catch (e) {
          output4.error({
            title: e.message
          });
          process.exit(1);
        }
      }
      async sendHeartbeat(ciExecutionId, runGroup) {
        await this.apiAxiosInstance.post("/nx-cloud/heartbeat", {
          ciExecutionId,
          runGroup
        });
      }
      async sendHeartbeatLogs(logs, ciExecutionId, runGroup) {
        const reqBody = {
          logs,
          ciExecutionId,
          runGroup
        };
        const uncompressedBuffer = Buffer.from(JSON.stringify(reqBody));
        const compressedBuffer = await (0, import_util.promisify)(import_zlib.gzip)(uncompressedBuffer);
        await this.apiAxiosInstance.post(
          "/nx-cloud/heartbeat/logs",
          compressedBuffer,
          {
            // @ts-ignore
            headers: {
              ...this.apiAxiosInstance.defaults.headers,
              "Content-Encoding": "gzip",
              "Content-Type": "application/octet-stream"
            }
          }
        );
      }
      async fetchProjectGraph() {
        return await this.apiAxiosInstance.get(
          "/nx-cloud/executions/project-graph"
        );
      }
    };
  }
});

// src/lib/utilities/project-graph-metadata.ts
function getMetadataFromProjectGraphNodes(projectGraphNodes, tasks) {
  const projectsMetadata = {};
  tasks.forEach((task) => {
    var _a2;
    const project = projectGraphNodes[task.target.project];
    const projectTargetGroups = (_a2 = project == null ? void 0 : project.data.metadata) == null ? void 0 : _a2.targetGroups;
    const targetGroupMeta = {};
    if (projectTargetGroups) {
      for (const [name, targetGroup] of Object.entries(projectTargetGroups)) {
        if (targetGroup.includes(task.target.target) && targetGroup.length > 0) {
          targetGroupMeta[name] = targetGroup;
        }
      }
    }
    if (targetGroupMeta && Object.entries(targetGroupMeta).length > 0) {
      if (task.target.project in projectsMetadata) {
        projectsMetadata[task.target.project].targetGroups = {
          ...projectsMetadata[task.target.project].targetGroups,
          ...targetGroupMeta
        };
      } else {
        projectsMetadata[task.target.project] = {
          targetGroups: targetGroupMeta
        };
      }
    }
  });
  return {
    projects: Object.keys(projectsMetadata).length > 0 ? projectsMetadata : null
  };
}
function setTechnologiesOnTask(projectGraphNodes, task) {
  var _a2, _b2, _c2;
  const project = projectGraphNodes[task.projectName];
  const projectTechnologies = ((_a2 = project == null ? void 0 : project.data.metadata) == null ? void 0 : _a2.technologies) || [];
  const projectTarget = (_b2 = project == null ? void 0 : project.data.targets) == null ? void 0 : _b2[task.target];
  const targetTechnologies = ((_c2 = projectTarget == null ? void 0 : projectTarget.metadata) == null ? void 0 : _c2.technologies) || [];
  const technologies = new Set(
    projectTechnologies.concat(targetTechnologies)
  );
  task.meta = technologies.size > 0 ? { technologies: Array.from(technologies) } : null;
}
var init_project_graph_metadata = __esm({
  "src/lib/utilities/project-graph-metadata.ts"() {
    "use strict";
  }
});

// src/lib/utilities/remove-trailing-slash.ts
function removeTrailingSlash(apiUrl) {
  return apiUrl[apiUrl.length - 1] === "/" ? apiUrl.substr(0, apiUrl.length - 1) : apiUrl;
}
var init_remove_trailing_slash = __esm({
  "src/lib/utilities/remove-trailing-slash.ts"() {
    "use strict";
  }
});

// src/lib/core/api/error-reporter.api.ts
var output5, ErrorReporterApi;
var init_error_reporter_api = __esm({
  "src/lib/core/api/error-reporter.api.ts"() {
    "use strict";
    init_axios();
    ({ output: output5 } = require_nx_imports_light());
    ErrorReporterApi = class {
      constructor(options) {
        this.apiAxiosInstance = createApiAxiosInstance(options);
      }
      async reportError(message) {
        try {
          await axiosMultipleTries(
            () => this.apiAxiosInstance.post("/nx-cloud/report-client-error", {
              message
            })
          );
        } catch (e) {
          output5.warn({
            title: `Unable to record the following error: '${message}'`,
            bodyLines: [e.message]
          });
        }
      }
    };
  }
});

// src/lib/core/file-storage/e2e-encryption.ts
var import_crypto2, import_fs3, E2EEncryption;
var init_e2e_encryption = __esm({
  "src/lib/core/file-storage/e2e-encryption.ts"() {
    "use strict";
    import_crypto2 = require("crypto");
    import_fs3 = require("fs");
    E2EEncryption = class {
      constructor(key) {
        if (key) {
          this.encryptionKey = this.to32bytes(key);
        }
      }
      to32bytes(key) {
        let res = key;
        while (res.length < 32) {
          res += key;
        }
        return Buffer.from(res).slice(0, 32);
      }
      hasEncryption() {
        return !!this.encryptionKey;
      }
      encryptFile(file) {
        const iv = (0, import_crypto2.randomBytes)(16);
        const cipher = (0, import_crypto2.createCipheriv)("aes-256-cbc", this.encryptionKey, iv);
        const decryptedFileContents = (0, import_fs3.readFileSync)(file);
        const e = cipher.update(decryptedFileContents);
        const encryptedFileContents = Buffer.concat([iv, e, cipher.final()]);
        (0, import_fs3.writeFileSync)(file, encryptedFileContents);
      }
      decryptFile(file) {
        const encryptedFileContents = (0, import_fs3.readFileSync)(file);
        try {
          const decipher = (0, import_crypto2.createDecipheriv)(
            "aes-256-cbc",
            this.encryptionKey,
            encryptedFileContents.slice(0, 16)
            // iv
          );
          const encryptedText = encryptedFileContents.slice(16);
          const d = decipher.update(encryptedText);
          const decryptedFileContents = Buffer.concat([d, decipher.final()]);
          (0, import_fs3.writeFileSync)(file, decryptedFileContents);
        } catch (e) {
          throw new Error(
            `Could not decrypt the artifact. Please check your encryption key.`
          );
        }
      }
    };
  }
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/tar/lib/high-level-opt.js"(exports2, module2) {
    "use strict";
    var argmap = /* @__PURE__ */ new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), /* @__PURE__ */ Object.create(null)) : {};
  }
});

// node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/minipass/index.js"(exports2, module2) {
    "use strict";
    var proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    var EE = require("events");
    var Stream = require("stream");
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var EMITTED_ERROR = Symbol("emittedError");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var EMITDATA = Symbol("emitData");
    var EMITEND = Symbol("emitEnd");
    var EMITEND2 = Symbol("emitEnd2");
    var ASYNC = Symbol("async");
    var defer = (fn) => Promise.resolve().then(fn);
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    var Pipe = class {
      constructor(src, dest, opts) {
        this.src = src;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src[RESUME]();
        dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // istanbul ignore next - only here for the prototype
      proxyErrors() {
      }
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    var PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src, dest, opts) {
        super(src, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src.on("error", this.proxyErrors);
      }
    };
    module2.exports = class Minipass extends Stream {
      constructor(options) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = [];
        this.buffer = [];
        this[OBJECTMODE] = options && options.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options && options.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[ASYNC] = options && !!options.async || false;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this[EMITTED_ERROR] = null;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      get ["async"]() {
        return this[ASYNC];
      }
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          ));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer : (f) => f();
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (this[OBJECTMODE]) {
          if (this.flowing && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this.flowing)
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this.flowing;
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this.buffer.length > 1 && !this[OBJECTMODE]) {
          if (this.encoding)
            this.buffer = [this.buffer.join("")];
          else
            this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
        }
        const ret = this[READ](n || null, this.buffer[0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer[0] = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer[0].length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      unpipe(dest) {
        const p = this.pipes.find((p2) => p2.dest === dest);
        if (p) {
          this.pipes.splice(this.pipes.indexOf(p), 1);
          p.unpipe();
        }
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        const ret = super.on(ev, fn);
        if (ev === "data" && !this.pipes.length && !this.flowing)
          this[RESUME]();
        else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
          super.emit("readable");
        else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          if (this[ASYNC])
            defer(() => fn.call(this, this[EMITTED_ERROR]));
          else
            fn.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data, ...extra) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          const ret2 = super.emit("error", data);
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, data, ...extra);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this.pipes) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return;
        this[EMITTED_END] = true;
        this.readable = false;
        if (this[ASYNC])
          defer(() => this[EMITEND2]());
        else
          this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this.pipes) {
              p.dest.write(data);
            }
            super.emit("data", data);
          }
        }
        for (const p of this.pipes) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      // const all = await stream.collect()
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      // const data = await stream.concat()
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      // stream.promise().then(() => done, er => emitted error)
      promise() {
        return new Promise((resolve2, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve2());
        });
      }
      // for await (let chunk of stream)
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve2 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value2) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve2({ value: value2, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve2({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve2 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      // for (let chunk of stream)
      [ITERATOR]() {
        const next = () => {
          const value2 = this.read();
          const done = value2 === null;
          return { value: value2, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer.length = 0;
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || // readable
        typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/constants.js
var require_constants = __commonJS({
  "node_modules/minizlib/constants.js"(exports2, module2) {
    "use strict";
    var realZlibConstants = require("zlib").constants || /* istanbul ignore next */
    { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/minizlib/index.js"(exports2) {
    "use strict";
    var assert = require("assert");
    var Buffer2 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants = exports2.constants = require_constants();
    var Minipass = require_minipass();
    var OriginalBufferConcat = Buffer2.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer2.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer2.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer2.concat = (args5) => args5;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer2.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer2.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer2.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer2.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH);
          assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports2.Deflate = Deflate;
    exports2.Inflate = Inflate;
    exports2.Gzip = Gzip;
    exports2.Gunzip = Gunzip;
    exports2.DeflateRaw = DeflateRaw;
    exports2.InflateRaw = InflateRaw;
    exports2.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports2.BrotliCompress = BrotliCompress;
      exports2.BrotliDecompress = BrotliDecompress;
    } else {
      exports2.BrotliCompress = exports2.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "node_modules/tar/lib/normalize-windows-path.js"(exports2, module2) {
    "use strict";
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module2.exports = platform !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
  }
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/tar/lib/read-entry.js"(exports2, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends MiniPass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode)
          this.mode = this.mode & 4095;
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex)
          this[SLURP](ex);
        if (gex)
          this[SLURP](gex, true);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore)
          return true;
        if (r >= writeLen)
          return super.write(data);
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
        }
      }
    };
  }
});

// node_modules/tar/lib/types.js
var require_types = __commonJS({
  "node_modules/tar/lib/types.js"(exports2) {
    "use strict";
    exports2.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      // same as File
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      // Devices and FIFOs aren't fully supported
      // they are parsed, but skipped when unpacking
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      // same as File
      ["7", "ContiguousFile"],
      // pax headers
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      // vendor-specific stuff
      // skip
      ["A", "SolarisACL"],
      // like 5, but with data, which should be skipped
      ["D", "GNUDumpDir"],
      // metadata only, skip
      ["I", "Inode"],
      // data = link path of next file
      ["K", "NextFileHasLongLinkpath"],
      // data = path of next file
      ["L", "NextFileHasLongPath"],
      // skip
      ["M", "ContinuationFile"],
      // like L
      ["N", "OldGnuLongPath"],
      // skip
      ["S", "SparseFile"],
      // skip
      ["V", "TapeVolumeHeader"],
      // like x
      ["X", "OldExtendedHeader"]
    ]);
    exports2.code = new Map(Array.from(exports2.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/tar/lib/large-numbers.js"(exports2, module2) {
    "use strict";
    var encode = (num, buf) => {
      if (!Number.isSafeInteger(num))
        throw Error("cannot encode number outside of javascript safe integer range");
      else if (num < 0)
        encodeNegative(num, buf);
      else
        encodePositive(num, buf);
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped)
          buf[i - 1] = onesComp(byte);
        else if (byte === 0)
          buf[i - 1] = 0;
        else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse2 = (buf) => {
      const pre = buf[0];
      const value2 = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value2 === null)
        throw Error("invalid base256 encoding");
      if (!Number.isSafeInteger(value2))
        throw Error("parsed number outside of javascript safe integer range");
      return value2;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped)
          f = onesComp(byte);
        else if (byte === 0)
          f = byte;
        else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0)
          sum -= f * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0)
          sum += byte * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module2.exports = {
      encode,
      parse: parse2
    };
  }
});

// node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/tar/lib/header.js"(exports2, module2) {
    "use strict";
    var types = require_types();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data))
          this.decode(data, off || 0, ex, gex);
        else if (data)
          this.set(data);
      }
      decode(buf, off, ex, gex) {
        if (!off)
          off = 0;
        if (!buf || !(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "")
          this[TYPE] = "0";
        if (this[TYPE] === "0" && this.path.substr(-1) === "/")
          this[TYPE] = "5";
        if (this[TYPE] === "5")
          this.size = 0;
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix)
              this.path = prefix + "/" + this.path;
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++)
          sum += buf[i];
        for (let i = off + 156; i < off + 512; i++)
          sum += buf[i];
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32)
          this.nullBlock = true;
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = ex[k];
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off)
          off = 0;
        if (!(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || "", prefixSize);
        const path5 = split[0];
        const prefix = split[1];
        this.needPax = split[2];
        this.needPax = encString(buf, off, 100, path5) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0)
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++)
          sum += buf[i];
        for (let i = off + 156; i < off + 512; i++)
          sum += buf[i];
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (const i in data) {
          if (data[i] !== null && data[i] !== void 0)
            this[i] = data[i];
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type))
          this[TYPE] = types.code.get(type);
        else
          this[TYPE] = type;
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize)
        ret = [pp, prefix, false];
      else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp, prefix, false];
          else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp.substr(0, pathSize - 1), prefix, true];
          else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret)
          ret = [p.substr(0, pathSize - 1), "", true];
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value2) => isNaN(value2) ? null : value2;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(
      buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(),
      8
    ));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number) => number === null ? false : number > MAXNUM[size] || number < 0 ? (large.encode(number, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number), false);
    var encSmallNumber = (buf, off, size, number) => buf.write(octalString(number, size), off, size, "ascii");
    var octalString = (number, size) => padOctal(Math.floor(number).toString(8), size);
    var padOctal = (string, size) => (string.length === size - 1 ? string : new Array(size - string.length - 1).join("0") + string + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string) => string === null ? false : (buf.write(string + NULLS, off, size, "utf8"), string.length !== Buffer.byteLength(string) || string.length > size);
    module2.exports = Header;
  }
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/tar/lib/pax.js"(exports2, module2) {
    "use strict";
    var Header = require_header();
    var path5 = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "")
          return null;
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++)
          buf[i] = 0;
        new Header({
          // XXX split the path
          // then the path should be PaxHeader + basename, but less than 99,
          // prepend with the dirname
          path: ("PaxHeader/" + path5.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++)
          buf[i] = 0;
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0)
          return "";
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits2 = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits2 >= Math.pow(10, digits2))
          digits2 += 1;
        const len = digits2 + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g);
    var merge = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string) => string.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1)
        return set;
      line = line.substr((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k)
        return set;
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  }
});

// node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "node_modules/tar/lib/strip-trailing-slashes.js"(exports2, module2) {
    "use strict";
    module2.exports = (str) => {
      let i = str.length - 1;
      let slashesStart = -1;
      while (i > -1 && str.charAt(i) === "/") {
        slashesStart = i;
        i--;
      }
      return slashesStart === -1 ? str : str.slice(0, slashesStart);
    };
  }
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/tar/lib/warn-mixin.js"(exports2, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file)
          data.file = this.file;
        if (this.cwd)
          data.cwd = this.cwd;
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error)
          this.emit("error", Object.assign(message, data));
        else
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
      }
    };
  }
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/tar/lib/winchars.js"(exports2, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "node_modules/tar/lib/strip-absolute-path.js"(exports2, module2) {
    "use strict";
    var { isAbsolute, parse: parse2 } = require("path").win32;
    module2.exports = (path5) => {
      let r = "";
      let parsed = parse2(path5);
      while (isAbsolute(path5) || parsed.root) {
        const root = path5.charAt(0) === "/" && path5.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path5 = path5.substr(root.length);
        r += root;
        parsed = parse2(path5);
      }
      return [r, path5];
    };
  }
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/tar/lib/mode-fix.js"(exports2, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable)
        mode = (mode | 384) & ~18;
      if (isDir) {
        if (mode & 256)
          mode |= 64;
        if (mode & 32)
          mode |= 8;
        if (mode & 4)
          mode |= 1;
      }
      return mode;
    };
  }
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/tar/lib/write-entry.js"(exports2, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var fs = require("fs");
    var path5 = require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path6, prefix) => {
      if (!prefix)
        return normPath(path6);
      path6 = normPath(path6).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix) + "/" + path6;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends MiniPass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string")
          throw new TypeError("path is required");
        this.path = normPath(p);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path5.resolve(this.cwd, p));
        if (this.path === "")
          this.path = "./";
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute))
          this[ONLSTAT](this.statCache.get(this.absolute));
        else
          this[LSTAT]();
      }
      emit(ev, ...data) {
        if (ev === "error")
          this[HAD_ERROR] = true;
        return super.emit(ev, ...data);
      }
      [LSTAT]() {
        fs.lstat(this.absolute, (er, stat) => {
          if (er)
            return this.emit("error", er);
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile())
          stat.size = 0;
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path6) {
        return prefixPath(path6, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.header = new Header({
          path: this[PREFIX](this.path),
          // only apply the prefix to hard links.
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.substr(-1) !== "/")
          this.path += "/";
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs.readlink(this.absolute, (er, linkpath) => {
          if (er)
            return this.emit("error", er);
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path5.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0)
              return this[HARDLINK](linkpath);
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0)
          return this.end();
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs.open(this.absolute, "r", (er, fd) => {
          if (er)
            return this.emit("error", er);
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR])
          return this[CLOSE]();
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset, length, pos } = this;
        fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](() => this.emit("error", er));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead > this.remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead === this.remain) {
          for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
            this.buf[i + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed)
          this[AWAITDRAIN](() => this[ONDRAIN]());
        else
          this[ONDRAIN]();
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er = new Error("writing more data than expected");
          er.path = this.absolute;
          return this.emit("error", er);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain)
            super.write(Buffer.alloc(this.blockRemain));
          return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset, length, pos } = this;
          const bytesRead = fs.readSync(fd, buf, offset, length, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          // only the permissions and setuid/setgid/sticky bitflags
          // not the higher-order bits that specify file type
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path6) {
        return prefixPath(path6, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain)
          super.write(Buffer.alloc(this.blockRemain));
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value2) {
      var inserted = node === self2.head ? new Node(value2, null, node, self2) : new Node(value2, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value2, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value2, prev, next, list);
      }
      this.list = list;
      this.value = value2;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/tar/lib/pack.js"(exports2, module2) {
    "use strict";
    var PackJob = class {
      constructor(path6, absolute) {
        this.path = path6 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var MiniPass = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs = require("fs");
    var path5 = require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends MiniPass {
      constructor(opt) {
        super(opt);
        opt = opt || /* @__PURE__ */ Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip) {
          if (typeof opt.gzip !== "object")
            opt.gzip = {};
          if (this.portable)
            opt.gzip.portable = true;
          this.zip = new zlib.Gzip(opt.gzip);
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else
          this.on("drain", this[ONDRAIN]);
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path6) {
        this.write(path6);
        return this;
      }
      end(path6) {
        if (path6)
          this.write(path6);
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path6) {
        if (this[ENDED])
          throw new Error("write after end");
        if (path6 instanceof ReadEntry)
          this[ADDTARENTRY](path6);
        else
          this[ADDFSENTRY](path6);
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = normPath(path5.resolve(this.cwd, p.path));
        if (!this.filter(p.path, p))
          p.resume();
        else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = normPath(path5.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            this.emit("error", er);
          else
            this[ONSTAT](job, stat2);
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat))
          job.ignore = true;
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            return this.emit("error", er);
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING])
          return;
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip)
            this.zip.end(EOF);
          else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending)
          return;
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped)
            this[PIPE](job);
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute))
            this[ONSTAT](job, this.statCache.get(job.absolute));
          else
            this[STAT](job);
        }
        if (!job.stat)
          return;
        if (job.ignore)
          return;
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute))
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          else
            this[READDIR](job);
          if (!job.readdir)
            return;
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job);
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry)
          this[CURRENT].entry.resume();
      }
      // like .pipe() but using super, because our write() is special
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source = job.entry;
        const zip = this.zip;
        if (zip) {
          source.on("data", (chunk) => {
            if (!zip.write(chunk))
              source.pause();
          });
        } else {
          source.on("data", (chunk) => {
            if (!super.write(chunk))
              source.pause();
          });
        }
      }
      pause() {
        if (this.zip)
          this.zip.pause();
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      // pause/resume are no-ops in sync streams.
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs.readdirSync(job.absolute));
      }
      // gotta get it all in this tick
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip) {
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        } else {
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/fs-minipass/index.js"(exports2) {
    "use strict";
    var MiniPass = require_minipass();
    var EE = require("events").EventEmitter;
    var fs = require("fs");
    var writev = fs.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path5, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path5 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path5;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path5, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path5;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs.open(
          this[_path],
          this[_flags],
          this[_mode],
          (er, fd) => this[_onopen](er, fd)
        );
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(
            this[_fd],
            iovec,
            this[_pos],
            (er, bw) => this[_onwrite](er, bw)
          );
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](
            null,
            fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos])
          );
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports2.ReadStream = ReadStream;
    exports2.ReadStreamSync = ReadStreamSync;
    exports2.WriteStream = WriteStream;
    exports2.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/tar/lib/parse.js
var require_parse = __commonJS({
  "node_modules/tar/lib/parse.js"(exports2, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var noop = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone)
          this.on(DONE, opt.ondone);
        else {
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
            this.emit("close");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        if (typeof opt.onentry === "function")
          this.on("entry", opt.onentry);
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null)
          this[SAW_VALID_ENTRY] = false;
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin")
              this[STATE] = "header";
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid)
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          else if (!header.path)
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid)
                      this[SAW_VALID_ENTRY] = true;
                  };
                  entry.on("end", onend);
                } else
                  this[SAW_VALID_ENTRY] = true;
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain)
                    this[STATE] = "body";
                  else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else
                    this[QUEUE].push(entry);
                }
              }
            }
          }
        }
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry))
          this.emit.apply(this, entry);
        else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING])
              this.emit("drain");
          } else
            re.once("drain", (_) => this.emit("drain"));
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY])
          this[EMITMETA](entry);
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY])
          this.emit(ev, data, extra);
        else
          this[QUEUE].push([ev, data, extra]);
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED])
          return;
        if (this[UNZIP] === null && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i])
              this[UNZIP] = false;
          }
          if (this[UNZIP] === null) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = new zlib.Unzip();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP])
          this[UNZIP].write(chunk);
        else
          this[CONSUMECHUNK](chunk);
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length)
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED])
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER])
              entry.write(this[BUFFER]);
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING])
          this[BUFFERCONCAT](chunk);
        else if (!chunk && !this[BUFFER])
          this[MAYBEEND]();
        else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else
            this[CONSUMECHUNKSUB](chunk);
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED])
          this[MAYBEEND]();
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER])
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          else
            this[BUFFER] = chunk.slice(position);
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP])
            this[UNZIP].end(chunk);
          else {
            this[ENDED] = true;
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/tar/lib/list.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser2 = require_parse();
    var fs = require("fs");
    var fsm = require_fs_minipass();
    var path5 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      if (!opt.noResume)
        onentryFunction(opt);
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path5.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path5.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p = list(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize)
          p.end(fs.readFileSync(file));
        else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs.openSync(file, "r");
          while (pos < stat.size) {
            const bytesRead = fs.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse2 = new Parser2(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve2, reject) => {
        parse2.on("error", reject);
        parse2.on("end", resolve2);
        fs.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse2);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list = (opt) => new Parser2(opt);
  }
});

// node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/tar/lib/create.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t = require_list();
    var path5 = require("path");
    module2.exports = (opt_, files, cb) => {
      if (typeof files === "function")
        cb = files;
      if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path5.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path5.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else
          p.add(file);
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/tar/lib/replace.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path5 = require("path");
    var Header = require_header();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT")
            fd = fs.openSync(opt.file, "w+");
          else
            throw er;
        }
        const st = fs.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION:
          for (position = 0; position < st.size; position += 512) {
            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {
              bytes = fs.readSync(
                fd,
                headBuf,
                bufPos,
                headBuf.length - bufPos,
                position + bufPos
              );
              if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
                throw new Error("cannot append to compressed archives");
              if (!bytes)
                break POSITION;
            }
            const h = new Header(headBuf);
            if (!h.cksumValid)
              break;
            const entryBlockSize = 512 * Math.ceil(h.size / 512);
            if (position + entryBlockSize + 512 > st.size)
              break;
            position += entryBlockSize;
            if (opt.mtimeCache)
              opt.mtimeCache.set(h.path, h.mtime);
          }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er)
            fs.close(fd, (_) => cb_(er));
          else
            cb_(null, pos);
        };
        let position = 0;
        if (size === 0)
          return cb2(null, 0);
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes) => {
          if (er)
            return cb2(er);
          bufPos += bytes;
          if (bufPos < 512 && bytes) {
            return fs.read(
              fd,
              headBuf,
              bufPos,
              headBuf.length - bufPos,
              position + bufPos,
              onread
            );
          }
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
            return cb2(new Error("cannot append to compressed archives"));
          if (bufPos < 512)
            return cb2(null, position);
          const h = new Header(headBuf);
          if (!h.cksumValid)
            return cb2(null, position);
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size)
            return cb2(null, position);
          position += entryBlockSize + 512;
          if (position >= size)
            return cb2(null, position);
          if (opt.mtimeCache)
            opt.mtimeCache.set(h.path, h.mtime);
          bufPos = 0;
          fs.read(fd, headBuf, 0, 512, position, onread);
        };
        fs.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve2, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs.open(opt.file, flag, onopen);
          }
          if (er)
            return reject(er);
          fs.fstat(fd, (er2, st) => {
            if (er2)
              return fs.close(fd, () => reject(er2));
            getPos(fd, st.size, (er3, position) => {
              if (er3)
                return reject(er3);
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve2);
              addFilesAsync(p, files);
            });
          });
        };
        fs.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path5.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path5.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else
          p.add(file);
      }
      p.end();
    };
  }
});

// node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/tar/lib/update.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter = opt.filter;
      if (!opt.mtimeCache)
        opt.mtimeCache = /* @__PURE__ */ new Map();
      opt.filter = filter ? (path5, stat) => filter(path5, stat) && !(opt.mtimeCache.get(path5) > stat.mtime) : (path5, stat) => !(opt.mtimeCache.get(path5) > stat.mtime);
    };
  }
});

// node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/mkdirp/lib/opts-arg.js"(exports2, module2) {
    "use strict";
    var { promisify: promisify5 } = require("util");
    var fs = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs };
      else if (typeof opts === "object")
        opts = { mode: 511, fs, ...opts };
      else if (typeof opts === "number")
        opts = { mode: opts, fs };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir;
      opts.mkdirAsync = promisify5(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs.stat;
      opts.statAsync = promisify5(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/mkdirp/lib/path-arg.js"(exports2, module2) {
    "use strict";
    var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve: resolve2, parse: parse2 } = require("path");
    var pathArg = (path5) => {
      if (/\0/.test(path5)) {
        throw Object.assign(
          new TypeError("path must be a string without null bytes"),
          {
            path: path5,
            code: "ERR_INVALID_ARG_VALUE"
          }
        );
      }
      path5 = resolve2(path5);
      if (platform === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse2(path5);
        if (badWinChars.test(path5.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path5,
            code: "EINVAL"
          });
        }
      }
      return path5;
    };
    module2.exports = pathArg;
  }
});

// node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/mkdirp/lib/find-made.js"(exports2, module2) {
    "use strict";
    var { dirname: dirname3 } = require("path");
    var findMade = (opts, parent, path5 = void 0) => {
      if (path5 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then(
        (st) => st.isDirectory() ? path5 : void 0,
        // will fail later
        (er) => er.code === "ENOENT" ? findMade(opts, dirname3(parent), parent) : void 0
      );
    };
    var findMadeSync = (opts, parent, path5 = void 0) => {
      if (path5 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path5 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname3(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-manual.js"(exports2, module2) {
    "use strict";
    var { dirname: dirname3 } = require("path");
    var mkdirpManual = (path5, opts, made) => {
      opts.recursive = false;
      const parent = dirname3(path5);
      if (parent === path5) {
        return opts.mkdirAsync(path5, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path5, opts).then(() => made || path5, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path5, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path5).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path5, opts, made) => {
      const parent = dirname3(path5);
      opts.recursive = false;
      if (parent === path5) {
        try {
          return opts.mkdirSync(path5, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path5, opts);
        return made || path5;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path5, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path5).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/mkdirp/lib/mkdirp-native.js"(exports2, module2) {
    "use strict";
    var { dirname: dirname3 } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path5, opts) => {
      opts.recursive = true;
      const parent = dirname3(path5);
      if (parent === path5)
        return opts.mkdirAsync(path5, opts);
      return findMade(opts, path5).then((made) => opts.mkdirAsync(path5, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path5, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path5, opts) => {
      opts.recursive = true;
      const parent = dirname3(path5);
      if (parent === path5)
        return opts.mkdirSync(path5, opts);
      const made = findMadeSync(opts, path5);
      try {
        opts.mkdirSync(path5, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path5, opts);
        else
          throw er;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/mkdirp/lib/use-native.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports2, module2) {
    "use strict";
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp = (path5, opts) => {
      path5 = pathArg(path5);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path5, opts) : mkdirpManual(path5, opts);
    };
    var mkdirpSync = (path5, opts) => {
      path5 = pathArg(path5);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path5, opts) : mkdirpManualSync(path5, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path5, opts) => mkdirpNative(pathArg(path5), optsArg(opts));
    mkdirp.manual = (path5, opts) => mkdirpManual(pathArg(path5), optsArg(opts));
    mkdirp.nativeSync = (path5, opts) => mkdirpNativeSync(pathArg(path5), optsArg(opts));
    mkdirp.manualSync = (path5, opts) => mkdirpManualSync(pathArg(path5), optsArg(opts));
    module2.exports = mkdirp;
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path5 = require("path");
    var LCHOWN = fs.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path6, uid, gid) => {
      try {
        return fs[LCHOWNSYNC](path6, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path6, uid, gid) => {
      try {
        return fs.chownSync(path6, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path6, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs.chown(path6, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path6, uid, gid) => {
      try {
        return lchownSync(path6, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path6, uid, gid);
      }
    } : (path6, uid, gid) => lchownSync(path6, uid, gid);
    var nodeVersion2 = process.version;
    var readdir = (path6, options, cb) => fs.readdir(path6, options, cb);
    var readdirSync2 = (path6, options) => fs.readdirSync(path6, options);
    if (/^v4\./.test(nodeVersion2))
      readdir = (path6, options, cb) => fs.readdir(path6, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs.lstat(path5.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path5.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path5.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path5.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs.lstatSync(path5.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path5.resolve(p, child.name), uid, gid);
      handleEISDirSync(path5.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync2(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/tar/lib/mkdir.js"(exports2, module2) {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs = require("fs");
    var path5 = require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink, path6) {
        super("Cannot extract through symbolic link");
        this.path = path6;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path6, code) {
        super(code + ": Cannot cd into '" + path6 + "'");
        this.path = path6;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache, key) => cache.get(normPath(key));
    var cSet = (cache, key, val) => cache.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs.stat(dir, (er, st) => {
        if (er || !st.isDirectory())
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        cb(er);
      });
    };
    module2.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = normPath(opt.cwd);
      const done = (er, created) => {
        if (er)
          cb(er);
        else {
          cSet(cache, dir, true);
          if (created && doChown)
            chownr(created, uid, gid, (er2) => done(er2));
          else if (needChmod)
            fs.chmod(dir, mode, cb);
          else
            cb();
        }
      };
      if (cache && cGet(cache, dir) === true)
        return done();
      if (dir === cwd)
        return checkCwd(dir, done);
      if (preserve)
        return mkdirp(dir, { mode }).then((made) => done(null, made), done);
      const sub = normPath(path5.relative(cwd, dir));
      const parts = sub.split("/");
      mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
      if (!parts.length)
        return cb(null, created);
      const p = parts.shift();
      const part = normPath(path5.resolve(base + "/" + p));
      if (cGet(cache, part))
        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
      if (er) {
        fs.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory())
            mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
          else if (unlink) {
            fs.unlink(part, (er2) => {
              if (er2)
                return cb(er2);
              fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
            });
          } else if (st.isSymbolicLink())
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          else
            cb(er);
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok)
          throw new CwdError(dir, code);
      }
    };
    module2.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache, dir, true);
        if (created2 && doChown)
          chownr.sync(created2, uid, gid);
        if (needChmod)
          fs.chmodSync(dir, mode);
      };
      if (cache && cGet(cache, dir) === true)
        return done();
      if (dir === cwd) {
        checkCwdSync(cwd);
        return done();
      }
      if (preserve)
        return done(mkdirp.sync(dir, mode));
      const sub = normPath(path5.relative(cwd, dir));
      const parts = sub.split("/");
      let created = null;
      for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
        part = normPath(path5.resolve(part));
        if (cGet(cache, part))
          continue;
        try {
          fs.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
        } catch (er) {
          const st = fs.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, true);
            continue;
          } else if (unlink) {
            fs.unlinkSync(part);
            fs.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
            continue;
          } else if (st.isSymbolicLink())
            return new SymlinkError(part, part + "/" + parts.join("/"));
        }
      }
      return done(created);
    };
  }
});

// node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "node_modules/tar/lib/normalize-unicode.js"(exports2, module2) {
    "use strict";
    var normalizeCache = /* @__PURE__ */ Object.create(null);
    var { hasOwnProperty } = Object.prototype;
    module2.exports = (s) => {
      if (!hasOwnProperty.call(normalizeCache, s))
        normalizeCache[s] = s.normalize("NFKD");
      return normalizeCache[s];
    };
  }
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/tar/lib/path-reservations.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var normalize2 = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join: join16 } = require("path");
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows = platform === "win32";
    module2.exports = () => {
      const queues = /* @__PURE__ */ new Map();
      const reservations = /* @__PURE__ */ new Map();
      const getDirs = (path5) => {
        const dirs = path5.split("/").slice(0, -1).reduce((set, path6) => {
          if (set.length)
            path6 = join16(set[set.length - 1], path6);
          set.push(path6 || "/");
          return set;
        }, []);
        return dirs;
      };
      const running = /* @__PURE__ */ new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res)
          throw new Error("function does not have any path reservations");
        return {
          paths: res.paths.map((path5) => queues.get(path5)),
          dirs: [...res.dirs].map((path5) => queues.get(path5))
        };
      };
      const check = (fn) => {
        const { paths, dirs } = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn))
          return false;
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn))
          return false;
        const { paths, dirs } = reservations.get(fn);
        const next = /* @__PURE__ */ new Set();
        paths.forEach((path5) => {
          const q = queues.get(path5);
          assert.equal(q[0], fn);
          if (q.length === 1)
            queues.delete(path5);
          else {
            q.shift();
            if (typeof q[0] === "function")
              next.add(q[0]);
            else
              q[0].forEach((fn2) => next.add(fn2));
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1)
            queues.delete(dir);
          else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else
            q[0].delete(fn);
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        paths = isWindows ? ["win32 parallelization disabled"] : paths.map((p) => {
          return normalize2(stripSlashes(join16(p))).toLowerCase();
        });
        const dirs = new Set(
          paths.map((path5) => getDirs(path5)).reduce((a, b) => a.concat(b))
        );
        reservations.set(fn, { dirs, paths });
        paths.forEach((path5) => {
          const q = queues.get(path5);
          if (!q)
            queues.set(path5, [fn]);
          else
            q.push(fn);
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q)
            queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
          else if (q[q.length - 1] instanceof Set)
            q[q.length - 1].add(fn);
          else
            q.push(/* @__PURE__ */ new Set([fn]));
        });
        return run(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/tar/lib/get-write-flag.js"(exports2, module2) {
    "use strict";
    var platform = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows = platform === "win32";
    var fs = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants;
    var fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/tar/lib/unpack.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var Parser2 = require_parse();
    var fs = require("fs");
    var fsm = require_fs_minipass();
    var path5 = require("path");
    var mkdir = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize2 = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto = require("crypto");
    var getFlag = require_get_write_flag();
    var platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows = platform === "win32";
    var unlinkFile = (path6, cb) => {
      if (!isWindows)
        return fs.unlink(path6, cb);
      const name = path6 + ".DELETE." + crypto.randomBytes(16).toString("hex");
      fs.rename(path6, name, (er) => {
        if (er)
          return cb(er);
        fs.unlink(name, cb);
      });
    };
    var unlinkFileSync = (path6) => {
      if (!isWindows)
        return fs.unlinkSync(path6);
      const name = path6 + ".DELETE." + crypto.randomBytes(16).toString("hex");
      fs.renameSync(path6, name);
      fs.unlinkSync(name);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var cacheKeyNormalize = (path6) => normalize2(stripSlash(normPath(path6))).toLowerCase();
    var pruneCache = (cache, abs) => {
      abs = cacheKeyNormalize(abs);
      for (const path6 of cache.keys()) {
        const pnorm = cacheKeyNormalize(path6);
        if (pnorm === abs || pnorm.indexOf(abs + "/") === 0)
          cache.delete(path6);
      }
    };
    var dropCache = (cache) => {
      for (const key of cache.keys())
        cache.delete(key);
    };
    var Unpack = class extends Parser2 {
      constructor(opt) {
        if (!opt)
          opt = {};
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number")
            throw new TypeError("cannot set owner without number uid and gid");
          if (opt.preserveOwner) {
            throw new TypeError(
              "cannot preserve owner in archive and also set owner explicitly"
            );
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number")
          this.preserveOwner = process.getuid && process.getuid() === 0;
        else
          this.preserveOwner = !!opt.preserveOwner;
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path5.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      // a bad or damaged archive is a warning for Parser, but an error
      // when extracting.  Mark those errors as unrecoverable, because
      // the Unpack contract cannot be met.
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT")
          data.recoverable = false;
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
          this.emit("close");
        }
      }
      [CHECKPATH](entry) {
        if (this.strip) {
          const parts = normPath(entry.path).split("/");
          if (parts.length < this.strip)
            return false;
          entry.path = parts.slice(this.strip).join("/");
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip)
              entry.linkpath = linkparts.slice(this.strip).join("/");
            else
              return false;
          }
        }
        if (!this.preservePaths) {
          const p = normPath(entry.path);
          const parts = p.split("/");
          if (parts.includes("..") || isWindows && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          const [root, stripped] = stripAbsolutePath(p);
          if (root) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (path5.isAbsolute(entry.path))
          entry.absolute = normPath(path5.resolve(entry.path));
        else
          entry.absolute = normPath(path5.resolve(this.cwd, entry.path));
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir")
          return false;
        if (this.win32) {
          const { root: aRoot } = path5.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length));
          const { root: pRoot } = path5.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry))
          return entry.resume();
        assert.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode)
              entry.mode = entry.mode | 448;
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError")
          this.emit("error", er);
        else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => {
          if (stream.fd)
            fs.close(stream.fd, () => {
            });
          stream.write = () => true;
          this[ONERROR](er, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er) => {
          if (er) {
            if (stream.fd)
              fs.close(stream.fd, () => {
              });
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs.close(stream.fd, (er2) => {
              if (er2)
                this[ONERROR](er2, entry);
              else
                this[UNPEND]();
              fullyDone();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            fs.futimes(fd, atime, mtime, (er) => er ? fs.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs.fchown(fd, uid, gid, (er) => er ? fs.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => {
            this[ONERROR](er, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs.utimes(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn(
          "TAR_ENTRY_UNSUPPORTED",
          `unsupported entry type: ${entry.type}`,
          { entry }
        );
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path5.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      // Check if we can reuse an existing filesystem entry safely and
      // overwrite it, rather than unlinking and recreating
      // Windows doesn't report a useful nlink, so we just never reuse entries
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;
      }
      // check if a thing is there, and if so, try to clobber it
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath)
          paths.push(entry.linkpath);
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink")
          dropCache(this.dirCache);
        else if (entry.type !== "Directory")
          pruneCache(this.dirCache, entry.absolute);
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
          this[PRUNECACHE](entry);
          fullyDone(er);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path5.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er) => {
                if (er) {
                  this[ONERROR](er, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st))
              return this[MAKEFS](null, entry, done);
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er) => this[MAKEFS](er, entry, done);
                if (!needChmod)
                  return afterChmod();
                return fs.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
              }
            }
            if (entry.absolute === this.cwd)
              return this[MAKEFS](null, entry, done);
            unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          });
        };
        if (this[CHECKED_CWD])
          start();
        else
          checkCwd();
      }
      [MAKEFS](er, entry, done) {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs[link](linkpath, entry.absolute, (er) => {
          if (er)
            this[ONERROR](er, entry);
          else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn) => {
      try {
        return [null, fn()];
      } catch (er) {
        return [er, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er2 = this[MKDIR](this.cwd, this.dmode);
          if (er2)
            return this[ONERROR](er2, entry);
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path5.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent)
              return this[ONERROR](mkParent, entry);
          }
        }
        const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime))
          return this[SKIP](entry);
        if (lstatEr || this[ISREUSABLE](entry, st))
          return this[MAKEFS](null, entry);
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er3] = needChmod ? callSync(() => {
              fs.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er3, entry);
          }
          const [er2] = callSync(() => fs.rmdirSync(entry.absolute));
          this[MAKEFS](er2, entry);
        }
        const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError)
            this[ONERROR](er || closeError, entry);
          done();
        };
        let fd;
        try {
          fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || /* @__PURE__ */ new Date();
            const mtime = entry.mtime;
            try {
              fs.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs.utimesSync(entry.absolute, entry.atime || /* @__PURE__ */ new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, done) {
        try {
          fs[link + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/tar/lib/extract.js"(exports2, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs = require("fs");
    var fsm = require_fs_minipass();
    var path5 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path5.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path5.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      const stat = fs.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve2, reject) => {
        u.on("error", reject);
        u.on("close", resolve2);
        fs.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract = (opt) => new Unpack(opt);
  }
});

// node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/tar/index.js"(exports2) {
    "use strict";
    exports2.c = exports2.create = require_create();
    exports2.r = exports2.replace = require_replace();
    exports2.t = exports2.list = require_list();
    exports2.u = exports2.update = require_update();
    exports2.x = exports2.extract = require_extract();
    exports2.Pack = require_pack();
    exports2.Unpack = require_unpack();
    exports2.Parse = require_parse();
    exports2.ReadEntry = require_read_entry();
    exports2.WriteEntry = require_write_entry();
    exports2.Header = require_header();
    exports2.Pax = require_pax();
    exports2.types = require_types();
  }
});

// src/lib/core/file-storage/file-storage.ts
var import_crypto3, import_fs4, path, import_path3, axios2, tar, output6, FileStorage;
var init_file_storage = __esm({
  "src/lib/core/file-storage/file-storage.ts"() {
    "use strict";
    import_crypto3 = require("crypto");
    import_fs4 = require("fs");
    path = __toESM(require("path"));
    import_path3 = require("path");
    init_axios();
    init_environment();
    init_waiter();
    axios2 = require_axios();
    tar = require_tar();
    ({ output: output6 } = require_nx_imports_light());
    FileStorage = class {
      constructor(encryption, errorReporter, options, context) {
        this.encryption = encryption;
        this.errorReporter = errorReporter;
        this.context = context;
        this.storedHashes = [];
        this.axiosConfigBuilder = (axiosConfig) => axiosConfig;
        if (options.customProxyConfigPath) {
          const { fileServerProxyConfig } = require((0, import_path3.join)(process.cwd(), options.customProxyConfigPath));
          this.axiosConfigBuilder = fileServerProxyConfig ?? this.axiosConfigBuilder;
        }
      }
      async retrieve(hash, cacheDirectory11, cacheFile) {
        if (process.env.NX_CLOUD_DEBUG_URLS == "true") {
          output6.note({
            title: `Nx Cloud: Downloading ${hash} ${cacheFile.fileType}`,
            bodyLines: [`RETRIEVAL URL: ${cacheFile.remoteUrl}`]
          });
        }
        const tgz = this.createFileName(hash, cacheDirectory11, cacheFile);
        const commitFilePath = this.createCommitFilePath(hash, cacheDirectory11);
        try {
          await this.downloadFile(cacheFile, tgz, commitFilePath);
          this.createCommitFile(commitFilePath);
          if (VERBOSE_LOGGING) {
            output6.note({ title: `Nx Cloud: Downloaded ${hash}` });
          }
        } catch (e) {
          const error = e.message || e.toString();
          let errorMessage;
          if (error.includes("zlib") || error.includes("gzip") || error.includes("TAR_BAD_ARCHIVE")) {
            errorMessage = `Failed to untar cached artifacts. The artifact may be corrupted. (Reference hash: ${hash})`;
          } else if (error.includes("decrypt")) {
            errorMessage = `Failed to decrypt artifact. Please review your encryption key. (Reference hash: ${hash})`;
          } else {
            errorMessage = `Failed to download cached artifacts. Enable NX_VERBOSE_LOGGING for more details. (Reference hash: ${hash})`;
          }
          if (VERBOSE_LOGGING) {
            output6.note({
              title: `${errorMessage}`,
              bodyLines: [
                `- ${e.message}`,
                `- Affected artifact: ${hash} in context ${this.context}.`
              ]
            });
          }
          if (this.context === "dte-agent" || this.context === "dte-main") {
            output6.note({
              title: `An error occurred while trying to retrieve artifacts in the ${this.context} context. Hash: ${hash}.`,
              bodyLines: [
                `- Please update the nx-cloud package to the latest version.`,
                `- Please update the nx package to 15.8.9 or higher. You can do it without updating the plugins.`,
                `- If you are not able to update the nx package, and you are passing --configuration to a run-many or an affected command, define that configuration for all the projects.`
              ]
            });
            if (process.env.NX_CLOUD_DEBUG_URLS == "true") {
              output6.note({ title: `URL: ${hash}` });
            }
          }
          await this.errorReporter.reportError(errorMessage);
          throw new Error(errorMessage);
        }
      }
      async store(hash, cacheDirectory11, cacheFile, includedFiles, markHashAsStored = true) {
        if (process.env.NX_CLOUD_DEBUG_URLS == "true") {
          output6.note({
            title: `Nx Cloud: Storing ${hash} ${includedFiles.join(", ")}`,
            bodyLines: [`STORAGE URL: ${cacheFile.remoteUrl}`]
          });
        }
        const tarFileName = await this.createTarFile(
          hash,
          cacheDirectory11,
          includedFiles,
          cacheFile
        );
        await this.uploadFile(cacheFile.remoteUrl, tarFileName);
        if (markHashAsStored) {
          this.storedHashes.push(hash);
        }
        if (VERBOSE_LOGGING) {
          output6.note({
            title: `Nx Cloud: Stored ${hash} ${includedFiles.join(", ")}`
          });
        }
      }
      createFileName(hash, cacheDirectory11, cacheFile) {
        switch (cacheFile.fileType) {
          case "artifact":
            return path.join(cacheDirectory11, `${hash}.tar.gz`);
          case "terminalOutput":
            return path.join(cacheDirectory11, `${hash}-logs.tar.gz`);
        }
      }
      async downloadFile(cacheFile, tgz, commitFilePath) {
        let resp;
        try {
          const urlObj = new URL(cacheFile.remoteUrl);
          const parsedUrl = urlObj.origin + urlObj.pathname;
          const searchParams = {};
          for (const [key, value2] of urlObj.searchParams.entries()) {
            searchParams[key] = value2;
          }
          resp = await axiosMultipleTries(
            () => axios2(
              parsedUrl,
              this.axiosConfigBuilder({
                method: "GET",
                responseType: "stream",
                maxContentLength: NX_CLOUD_NO_TIMEOUTS ? UNLIMITED_FILE_SIZE : DEFAULT_FILE_SIZE_LIMIT,
                maxBodyLength: NX_CLOUD_NO_TIMEOUTS ? UNLIMITED_FILE_SIZE : DEFAULT_FILE_SIZE_LIMIT,
                timeout: NX_CLOUD_NO_TIMEOUTS ? UNLIMITED_TIMEOUT : 6e4,
                params: searchParams
              })
            )
          );
        } catch (e) {
          throw e;
        }
        if ((0, import_fs4.existsSync)(tgz)) {
          let i = 0;
          while (i++ < 50) {
            if ((0, import_fs4.existsSync)(commitFilePath))
              return;
            await wait(500);
          }
        }
        if (this.encryption.hasEncryption() && cacheFile.fileType === "artifact") {
          await new Promise((res) => {
            const f = resp.data.pipe((0, import_fs4.createWriteStream)(tgz));
            f.on("close", () => res(null));
          });
          this.encryption.decryptFile(tgz);
          const q = (0, import_fs4.createReadStream)(tgz).pipe(
            tar.x({
              cwd: path.dirname(tgz),
              sync: true,
              noChmod: true
            })
          );
          return this.convertStreamIntoPromise(q);
        } else {
          const q = resp.data.pipe(
            tar.x({
              cwd: path.dirname(tgz),
              sync: true,
              noChmod: true
            })
          );
          return this.convertStreamIntoPromise(q);
        }
      }
      convertStreamIntoPromise(q) {
        return new Promise((res, rej) => {
          q.on("error", (e) => {
            if (e.tarCode === "TAR_ABORT" && e.message.indexOf("incorrect header check") > -1) {
              console.warn(
                "FileStorage: Decompression OK, Trailing garbage ignored."
              );
              res(null);
            } else {
              rej(e);
            }
          });
          q.on("finish", () => res(null));
        });
      }
      createCommitFile(commitFilePath) {
        (0, import_fs4.writeFileSync)(commitFilePath, "true");
      }
      createCommitFilePath(hash, cacheDirectory11) {
        return path.join(cacheDirectory11, `${hash}.commit`);
      }
      async createTarFile(hash, cacheDirectory11, includedFiles, cacheFile) {
        const tarFileName = this.createFileName(hash, cacheDirectory11, cacheFile);
        try {
          (0, import_fs4.unlinkSync)(path.join(cacheDirectory11, hash, "source"));
        } catch (e) {
        }
        tar.c(
          {
            gzip: true,
            sync: true,
            file: tarFileName,
            cwd: cacheDirectory11
          },
          includedFiles
        );
        if (this.encryption.hasEncryption() && cacheFile.fileType === "artifact") {
          this.encryption.encryptFile(tarFileName);
        }
        return tarFileName;
      }
      async uploadFile(url, tgz) {
        if (process.env.NX_CLOUD_ECONNABORTED_LOGGING == "true") {
          output6.note({ title: `Attempting to upload file with path: ${tgz}` });
        }
        const tarData = (0, import_fs4.readFileSync)(tgz);
        const tarHash = this.generateMD5(tarData);
        const headers = this.getFileUploadHeaders(url, tarHash);
        try {
          const resp = await axiosMultipleTries(
            () => axios2(
              url,
              this.axiosConfigBuilder({
                method: "PUT",
                data: tarData,
                headers,
                maxContentLength: NX_CLOUD_NO_TIMEOUTS ? UNLIMITED_FILE_SIZE : DEFAULT_FILE_SIZE_LIMIT,
                maxBodyLength: NX_CLOUD_NO_TIMEOUTS ? UNLIMITED_FILE_SIZE : DEFAULT_FILE_SIZE_LIMIT,
                timeout: NX_CLOUD_NO_TIMEOUTS ? UNLIMITED_TIMEOUT : 12e4
              })
            )
          );
        } catch (e) {
          if (e.message && e.message.includes("RetentionPolicyNotMet"))
            return;
          throw e;
        }
      }
      generateMD5(data) {
        const hasher = (0, import_crypto3.createHash)("md5");
        hasher.update(data);
        return hasher.digest("base64");
      }
      getFileUploadHeaders(url, tarHash) {
        const privateCloudFileServer = url.includes("/file/");
        const headers = {
          "Content-Type": "application/octet-stream",
          "x-ms-blob-type": "BlockBlob"
        };
        if (privateCloudFileServer) {
          headers["Content-MD5"] = tarHash;
        }
        return headers;
      }
    };
  }
});

// src/lib/core/terminal-output/end-of-run-message.ts
var EndOfRunMessage;
var init_end_of_run_message = __esm({
  "src/lib/core/terminal-output/end-of-run-message.ts"() {
    "use strict";
    init_environment();
    init_print_message();
    EndOfRunMessage = class {
      constructor(runContext, taskExecutions, distributedExecutionId) {
        this.runContext = runContext;
        this.taskExecutions = taskExecutions;
        this.distributedExecutionId = distributedExecutionId;
      }
      printCacheHitsMessage() {
        if (agentRunningInDistributedExecution(this.distributedExecutionId))
          return;
        if (!this.runContext.runUrl) {
          return;
        }
        const anyErrors = !!this.taskExecutions.find((te) => te.status !== 0);
        const anyCacheMisses = !!this.taskExecutions.find(
          (te) => te.cacheStatus === "cache-miss"
        );
        const hits = this.taskExecutions.filter((t) => this.runContext.statuses[t.hash] === "remote-cache-hit").map((t) => t.projectName);
        const message = [];
        if (anyErrors) {
          message.push(
            `View structured, searchable error logs at ${this.runContext.runUrl}`
          );
        } else if (anyCacheMisses) {
          message.push(
            `View logs and investigate cache misses at ${this.runContext.runUrl}`
          );
        } else if (hits.length > 0) {
          const tasks = hits.length === 1 ? hits[0] : `${hits.length} tasks`;
          message.push(
            `Nx Cloud made it possible to reuse ${tasks}: ${this.runContext.runUrl}`
          );
        } else {
          if (this.runContext.runUrl) {
            message.push(`View logs and run details at ${this.runContext.runUrl}`);
          }
        }
        if (message.length > 0) {
          printMessage(message.join(". "));
        }
      }
    };
  }
});

// src/lib/core/terminal-output/message-reporter.ts
var output7, MessageReporter;
var init_message_reporter = __esm({
  "src/lib/core/terminal-output/message-reporter.ts"() {
    "use strict";
    init_print_message();
    ({ output: output7 } = require_nx_imports_light());
    MessageReporter = class {
      constructor(options) {
        this.options = options;
        this.cacheError = null;
        this.apiError = null;
        this.message = null;
      }
      get anyErrors() {
        return this.cacheError || this.apiError;
      }
      printMessages() {
        if (this.anyErrors) {
          const bodyLines = [];
          if (this.cacheError) {
            bodyLines.push(`- ${this.cacheError}`);
          }
          if (this.apiError && this.apiError !== this.cacheError) {
            bodyLines.push(`- ${this.apiError}`);
          }
          output7.warn({
            title: `Nx Cloud Problems`,
            bodyLines
          });
        }
        if (this.message) {
          printMessage(this.message);
        }
      }
      extractErrorMessage(e, scope) {
        if (e.code === "ECONNABORTED") {
          if (process.env.NX_CLOUD_ECONNABORTED_LOGGING == "true") {
            console.log("[NX CLOUD DEBUG] Request config without `data`");
            delete e.config.data;
            console.log(JSON.stringify(e.config, null, 2));
          }
          return `Cannot connect to Nx Cloud (scope: ${scope}, code: ${e.code}). Try invoking the command with the NX_CLOUD_NO_TIMEOUTS env variable set to 'true'.`;
        } else if (e.code === "ECONNREFUSED" || e.code === "EAI_AGAIN" || e.code === "ENOTFOUND" || e.code === "EPROTO") {
          return `Cannot connect to Nx Cloud (scope: ${scope}, code: ${e.code}).`;
        } else if (e.response && e.response.status === 401) {
          return e.response.data.message ? e.response.data.message : e.response.data;
        } else if (e.response && e.response.status === 402) {
          if (this.options.showUsageWarnings === false || this.options.showUsageWarnings === void 0)
            return null;
          return e.response.data.message ? e.response.data.message : e.response.data;
        } else {
          let details = "";
          if (e.response && e.response.data && e.response.data.message) {
            details = `. ${e.response.data.message}`;
          } else if (e.response && e.response.data) {
            details = `. ${e.response.data}`;
          }
          const code = e.code ? ` (code: ${e.code})` : ``;
          return `${e.message}${details}${code}`;
        }
      }
    };
  }
});

// src/lib/core/terminal-output/output-obfuscator.ts
var OutputObfuscator;
var init_output_obfuscator = __esm({
  "src/lib/core/terminal-output/output-obfuscator.ts"() {
    "use strict";
    OutputObfuscator = class {
      constructor(maskedProperties = []) {
        this.normalizedMaskedProperties = [];
        this.normalizedMaskedProperties = Array.from(new Set(maskedProperties)).map(
          this.toCamelCase
        );
      }
      obfuscate(terminalOutput) {
        if (!this.normalizedMaskedProperties.length) {
          return terminalOutput;
        }
        this.normalizedMaskedProperties.forEach((secretKey) => {
          const commandFlagPattern = new RegExp(`(--${secretKey}=)[\\S]*`, "g");
          terminalOutput = terminalOutput.replaceAll(
            commandFlagPattern,
            "$1********"
          );
        });
        const secretValues = this.normalizedMaskedProperties.filter((secretKey) => secretKey in process.env).map((secretKey) => process.env[secretKey]);
        secretValues.forEach((secretValue) => {
          terminalOutput = terminalOutput.replaceAll(secretValue, "********");
        });
        return terminalOutput;
      }
      toCamelCase(input) {
        if (input.indexOf("-") > 1) {
          return input.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());
        } else {
          return input;
        }
      }
    };
  }
});

// src/lib/utilities/serializer-overrides.ts
function serializeOverrides(task) {
  return task.overrides.__overrides_unparsed__ ? task.overrides.__overrides_unparsed__.join(" ") : unparse(task.overrides).join(" ");
}
function unparse(options) {
  const unparsed = [];
  for (const key of Object.keys(options)) {
    const value2 = options[key];
    unparseOption(key, value2, unparsed);
  }
  return unparsed;
}
function unparseOption(key, value2, unparsed) {
  if (key === "_") {
    unparsed.push(...value2);
  } else if (value2 === true) {
    unparsed.push(`--${key}`);
  } else if (value2 === false) {
    unparsed.push(`--no-${key}`);
  } else if (Array.isArray(value2)) {
    value2.forEach((item) => unparseOption(key, item, unparsed));
  } else if (typeof value2 === "string" && stringShouldBeWrappedIntoQuotes(value2)) {
    const sanitized = value2.replace(/"/g, String.raw`\"`);
    unparsed.push(`--${key}="${sanitized}"`);
  } else if (value2 != null) {
    unparsed.push(`--${key}=${value2}`);
  }
}
function stringShouldBeWrappedIntoQuotes(str) {
  return str.includes(" ") || str.includes("{") || str.includes('"');
}
var init_serializer_overrides = __esm({
  "src/lib/utilities/serializer-overrides.ts"() {
    "use strict";
  }
});

// src/lib/core/terminal-output/read-task-terminal-output.ts
function readTaskTerminalOutput(cacheDirectory11, outputObfuscator, hash, cacheStatus, code) {
  let dir;
  if (cacheDirectory11) {
    if (cacheDirectory11.startsWith("./")) {
      dir = (0, import_path4.join)(workspaceRoot2, cacheDirectory11);
    } else {
      dir = cacheDirectory11;
    }
  } else {
    dir = (0, import_path4.join)(workspaceRoot2, "node_modules", ".cache", "nx");
  }
  try {
    const taskOutput = readTerminalOutputFile(dir, hash);
    const taskOutputSanitized = outputObfuscator.obfuscate(taskOutput);
    if (NX_CLOUD_UNLIMITED_OUTPUT)
      return taskOutputSanitized;
    const maxCharacters = cacheStatus === "cache-miss" ? code === 0 ? MAX_CHARACTERS_SUCCESSFUL_TASK : MAX_CHARACTERS_FAILED_TASK : MAX_CHARACTERS_CACHED_TASK;
    return taskOutputSanitized.length > maxCharacters ? `TRUNCATED

${taskOutputSanitized.slice(
      taskOutputSanitized.length - maxCharacters
    )}` : taskOutputSanitized;
  } catch (e) {
    if (process.env.NX_VERBOSE_LOGGING === "true") {
      console.error(e);
    }
    return "";
  }
}
function readTerminalOutputFile(dir, hash) {
  try {
    return (0, import_fs5.readFileSync)(path2.join(dir, "terminalOutputs", hash)).toString();
  } catch {
    try {
      return (0, import_fs5.readFileSync)(path2.join(dir, hash, "terminalOutput")).toString();
    } catch {
      return "";
    }
  }
}
var import_fs5, path2, import_path4, workspaceRoot2, MAX_CHARACTERS_FAILED_TASK, MAX_CHARACTERS_SUCCESSFUL_TASK, MAX_CHARACTERS_CACHED_TASK;
var init_read_task_terminal_output = __esm({
  "src/lib/core/terminal-output/read-task-terminal-output.ts"() {
    "use strict";
    import_fs5 = require("fs");
    path2 = __toESM(require("path"));
    import_path4 = require("path");
    init_environment();
    ({ workspaceRoot: workspaceRoot2 } = require_nx_imports_light());
    MAX_CHARACTERS_FAILED_TASK = 2e5;
    MAX_CHARACTERS_SUCCESSFUL_TASK = 2e4;
    MAX_CHARACTERS_CACHED_TASK = 2e4;
  }
});

// src/lib/core/runners/cloud-enabled/cloud-enabled-life-cycle.ts
var import_crypto4, CloudEnabledLifeCycle;
var init_cloud_enabled_life_cycle = __esm({
  "src/lib/core/runners/cloud-enabled/cloud-enabled-life-cycle.ts"() {
    "use strict";
    import_crypto4 = require("crypto");
    init_serializer_overrides();
    init_read_task_terminal_output();
    CloudEnabledLifeCycle = class {
      constructor(runContext, cacheDirectory11, cacheableOperations, outputObfuscator, tasks) {
        this.runContext = runContext;
        this.cacheDirectory = cacheDirectory11;
        this.cacheableOperations = cacheableOperations;
        this.outputObfuscator = outputObfuscator;
        this.tasks = tasks;
      }
      scheduleTask(task) {
        this.runContext.scheduledTasks.push(task);
      }
      // this gets called for every tasks that starts.
      startTask(task) {
        this.tasks.push({
          taskId: task.id,
          startTime: (/* @__PURE__ */ new Date()).toISOString(),
          target: task.target.target,
          projectName: task.target.project,
          hash: task.hash,
          hashDetails: this.cleanUpHashDetails(task.hashDetails),
          // the case is needed if you use older version of Nx
          params: serializeOverrides(task),
          uploadedToStorage: false,
          terminalOutputUploadedToFileStorage: false
        });
      }
      endTasks(tasks) {
        for (let t of tasks) {
          let cacheStatus;
          const taskIsRemoteCacheHit = t.status === "remote-cache";
          const taskIsLocalCacheHitPreNx135 = t.status === "cache";
          const taskIsLocalCacheHit = t.status === "local-cache" || t.status === "local-cache-kept-existing" || taskIsLocalCacheHitPreNx135;
          if (this.runContext.statuses[t.task.hash]) {
            cacheStatus = this.runContext.statuses[t.task.hash];
          } else if (taskIsRemoteCacheHit) {
            cacheStatus = "remote-cache-hit";
          } else if (taskIsLocalCacheHit) {
            cacheStatus = "local-cache-hit";
          } else {
            cacheStatus = "cache-miss";
          }
          this.updateStartedTask(t, cacheStatus);
        }
      }
      endCommand() {
      }
      updateStartedTask(result, cacheStatus) {
        const startedTask = this.tasks.find((t) => t.taskId === result.task.id);
        if (!startedTask) {
          throw new Error(`Cannot find task ${result.task.id}`);
        }
        if ((result == null ? void 0 : result.startTime) && (result == null ? void 0 : result.endTime)) {
          startedTask.startTime = new Date(result.startTime).toISOString();
          startedTask.endTime = new Date(result.endTime).toISOString();
        } else {
          startedTask.endTime = (/* @__PURE__ */ new Date()).toISOString();
        }
        startedTask.status = result.code;
        startedTask.params = this.outputObfuscator.obfuscate(startedTask.params);
        startedTask.cacheStatus = cacheStatus;
        startedTask.terminalOutput = this.getTerminalOutput(
          result.task.hash,
          startedTask.cacheStatus,
          result.code
        );
      }
      getTerminalOutput(hash, cacheStatus, code) {
        return readTaskTerminalOutput(
          this.cacheDirectory,
          this.outputObfuscator,
          hash,
          cacheStatus,
          code
        );
      }
      cleanUpHashDetails(hashDetails) {
        const nodes = {};
        const npm = [];
        for (const k of Object.keys(hashDetails.nodes)) {
          if (k.startsWith("npm:")) {
            npm.push(hashDetails.nodes[k]);
          } else {
            nodes[k] = hashDetails.nodes[k];
          }
        }
        npm.sort();
        if (npm.length > 0) {
          const hasher = (0, import_crypto4.createHash)("md5");
          hasher.update(npm.join("|"));
          nodes["npmDependencies"] = hasher.digest("base64");
        }
        return {
          nodes,
          runtime: hashDetails.runtime,
          implicitDeps: hashDetails.implicitDeps
        };
      }
    };
  }
});

// src/lib/core/runners/cloud-enabled/cloud-remote-cache.ts
var import_fs6, path3, output8, CloudRemoteCache;
var init_cloud_remote_cache = __esm({
  "src/lib/core/runners/cloud-enabled/cloud-remote-cache.ts"() {
    "use strict";
    import_fs6 = require("fs");
    path3 = __toESM(require("path"));
    init_environment();
    ({ output: output8 } = require_nx_imports_light());
    CloudRemoteCache = class {
      constructor(messages, api, runContext, fileStorage, distributedExecutionId, storeInCurrentProcess) {
        this.messages = messages;
        this.api = api;
        this.runContext = runContext;
        this.fileStorage = fileStorage;
        this.distributedExecutionId = distributedExecutionId;
        this.storeInCurrentProcess = storeInCurrentProcess;
        this.storeRequests = [];
        this.delayedStoreRequests = [];
      }
      async retrieve(hash, cacheDirectory11) {
        if (this.messages.cacheError)
          return false;
        const artifactUploadLocation = await this.getArtifactUploadLocations(hash);
        const artifactUrls = artifactUploadLocation == null ? void 0 : artifactUploadLocation.artifactUrls;
        const terminalOutputUrls = artifactUploadLocation == null ? void 0 : artifactUploadLocation.terminalOutputUrls;
        if (!artifactUrls || !artifactUrls.get) {
          if (VERBOSE_LOGGING) {
            output8.note({ title: `Nx Cloud: Cache miss ${hash}.` });
          }
          this.runContext.statuses[hash] = "cache-miss";
          return false;
        }
        const cacheFiles = [
          { remoteUrl: artifactUrls.get, fileType: "artifact" }
        ];
        if (terminalOutputUrls && terminalOutputUrls.get) {
          cacheFiles.push({
            remoteUrl: terminalOutputUrls.get,
            fileType: "terminalOutput"
          });
        }
        return this.retrieveFilesFromCache(hash, cacheDirectory11, cacheFiles);
      }
      async store(hash, cacheDirectory11) {
        if (this.messages.cacheError)
          return false;
        const storeRequest = new Promise(async (res, _) => {
          const artifactUploadLocation = await this.getArtifactUploadLocations(hash);
          const cacheFiles = [];
          const artifactUrls = artifactUploadLocation == null ? void 0 : artifactUploadLocation.artifactUrls;
          const terminalOutputUrls = artifactUploadLocation == null ? void 0 : artifactUploadLocation.terminalOutputUrls;
          if (terminalOutputUrls && terminalOutputUrls.put) {
            cacheFiles.push({
              remoteUrl: terminalOutputUrls.put,
              fileType: "terminalOutput"
            });
            this.setTerminalOutputAsUploadedToStorage(hash, true);
          }
          if (!artifactUrls && !terminalOutputUrls)
            return res(false);
          if (artifactUrls && artifactUrls.put) {
            cacheFiles.push({ remoteUrl: artifactUrls.put, fileType: "artifact" });
          } else {
            if (VERBOSE_LOGGING) {
              output8.note({
                title: `Nx Cloud: Skipping storing ${hash}.`,
                bodyLines: [
                  `There are several reasons why this can happen.`,
                  `Maybe you are using a read-only token or the artifact has already being uploaded.`
                ]
              });
            }
          }
          if (!this.storeInCurrentProcess) {
            this.delayedStoreRequests.push(
              ...cacheFiles.map((cacheFile) => ({
                hash,
                cacheFile
              }))
            );
            return res(true);
          }
          return res(
            await this.storeFilesInCache(hash, cacheDirectory11, cacheFiles)
          );
        });
        this.storeRequests.push(storeRequest);
        return storeRequest;
      }
      async retrieveFilesFromCache(hash, cacheDirectory11, cacheFiles) {
        try {
          for (const cacheFile of cacheFiles) {
            switch (cacheFile.fileType) {
              case "artifact":
                await this.fileStorage.retrieve(hash, cacheDirectory11, cacheFile);
                break;
              case "terminalOutput":
                await this.fileStorage.retrieve(hash, cacheDirectory11, cacheFile);
                break;
            }
          }
          this.runContext.statuses[hash] = "remote-cache-hit";
          return true;
        } catch (ee) {
          const e = ee.axiosException ?? ee;
          this.messages.cacheError = this.messages.extractErrorMessage(
            e,
            "storage"
          );
          this.runContext.statuses[hash] = "cache-miss";
          return false;
        }
      }
      async storeFilesInCache(hash, cacheDirectory11, cacheFiles) {
        try {
          await Promise.all(
            cacheFiles.map(async (cacheFile) => {
              switch (cacheFile.fileType) {
                case "artifact":
                  await this.fileStorage.store(hash, cacheDirectory11, cacheFile, [
                    path3.join(hash, "outputs"),
                    path3.join(hash, "code"),
                    path3.join(hash, "terminalOutput")
                  ]);
                  break;
                case "terminalOutput":
                  const terminalOutputPath = (0, import_fs6.existsSync)(
                    path3.join(cacheDirectory11, "terminalOutputs", hash)
                  ) ? path3.join("terminalOutputs", hash) : path3.join(hash, "terminalOutput");
                  await this.fileStorage.store(hash, cacheDirectory11, cacheFile, [
                    terminalOutputPath
                  ]);
                  break;
              }
            })
          );
          return true;
        } catch (ee) {
          const e = ee.axiosException ?? ee;
          this.messages.cacheError = this.messages.extractErrorMessage(
            e,
            "storage"
          );
          return false;
        }
      }
      async storeTerminalOutputsInCache(hash, cacheDirectory11) {
        if (this.messages.cacheError)
          return false;
        const res = Promise.resolve().then(async () => {
          const artifactUploadLocation = await this.getArtifactUploadLocations(hash);
          const terminalOutputUrls = artifactUploadLocation == null ? void 0 : artifactUploadLocation.terminalOutputUrls;
          let cacheFile;
          if (terminalOutputUrls && terminalOutputUrls.put) {
            cacheFile = {
              remoteUrl: terminalOutputUrls.put,
              fileType: "terminalOutput"
            };
            this.setTerminalOutputAsUploadedToStorage(hash, true);
          }
          if (cacheFile === void 0)
            return true;
          if (!this.storeInCurrentProcess) {
            this.delayedStoreRequests.push({ hash, cacheFile });
            return true;
          }
          if (!(0, import_fs6.existsSync)(path3.join(cacheDirectory11, "terminalOutputs", hash))) {
            let terminalOutputMessage = "";
            const nxVersion = getNxVersion();
            const nxMajorVersion = +nxVersion[1];
            const nxMinorVersion = nxVersion[2] ? +nxVersion[2] : 9999;
            const isBuggedVersion17 = nxMajorVersion === 17 && nxMinorVersion >= 3;
            const isBuggedVersion18 = nxMajorVersion === 18 && nxMinorVersion <= 2;
            if (isBuggedVersion17 || isBuggedVersion18) {
              terminalOutputMessage = "There is a known bug with this version of Nx when generating terminal outputs. Update to at least 18.3 to resolve this issue";
            }
            (0, import_fs6.writeFileSync)(
              path3.join(cacheDirectory11, "terminalOutputs", hash),
              terminalOutputMessage
            );
          }
          try {
            await this.fileStorage.store(
              hash,
              cacheDirectory11,
              cacheFile,
              [path3.join("terminalOutputs", hash)],
              false
            );
            return true;
          } catch (ee) {
            const e = ee.axiosException ?? ee;
            this.messages.cacheError = this.messages.extractErrorMessage(
              e,
              "storage"
            );
            return false;
          }
        });
        this.storeRequests.push(res);
        return res;
      }
      async getArtifactUploadLocations(hash) {
        if (hash in this.runContext.requests) {
          const uploadLocation = (await this.runContext.requests[hash])[hash];
          this.setTaskArtifactIdOnRunContext(hash, uploadLocation == null ? void 0 : uploadLocation.artifactId);
          return uploadLocation;
        } else {
          const scheduledTaskHashesWithoutRequests = this.runContext.scheduledTasks.filter((t) => !this.runContext.requests[t.hash]).map((t) => t.hash);
          if (scheduledTaskHashesWithoutRequests.indexOf(hash) === -1) {
            scheduledTaskHashesWithoutRequests.push(hash);
          }
          const request = this.api.startRun(
            this.distributedExecutionId,
            scheduledTaskHashesWithoutRequests
          );
          scheduledTaskHashesWithoutRequests.forEach((taskHash) => {
            this.runContext.requests[taskHash] = request;
          });
          const uploadLocation = (await request)[hash];
          this.setTaskArtifactIdOnRunContext(hash, uploadLocation == null ? void 0 : uploadLocation.artifactId);
          return uploadLocation;
        }
      }
      async waitForStoreRequestsToComplete() {
        const res = await Promise.all(this.storeRequests).then(
          (r) => r.reduce((a, b) => a && b, true)
        );
        if (!res) {
          throw new Error(`Error when storing artifacts`);
        }
      }
      setTaskArtifactIdOnRunContext(hash, artifactId) {
        const taskForHash = this.runContext.allTasks.find((t) => t.hash === hash);
        if (taskForHash === void 0) {
          throw Error(`Could not find task with hash $hash`);
        }
        taskForHash.artifactId = artifactId;
      }
      setTerminalOutputAsUploadedToStorage(hash, isUploaded) {
        const taskForHash = this.runContext.allTasks.find((t) => t.hash === hash);
        if (taskForHash === void 0) {
          throw Error(`Could not find task with hash $hash`);
        }
        taskForHash.terminalOutputUploadedToFileStorage = isUploaded;
      }
    };
  }
});

// ../../../node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "../../../node_modules/uuid/lib/rng.js"(exports2, module2) {
    "use strict";
    var crypto = require("crypto");
    module2.exports = function nodeRNG() {
      return crypto.randomBytes(16);
    };
  }
});

// ../../../node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "../../../node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
    "use strict";
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// ../../../node_modules/uuid/v1.js
var require_v1 = __commonJS({
  "../../../node_modules/uuid/v1.js"(exports2, module2) {
    "use strict";
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      var i = buf && offset || 0;
      var b = buf || [];
      options = options || {};
      var node = options.node || _nodeId;
      var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        var seedBytes = rng();
        if (node == null) {
          node = _nodeId = [
            seedBytes[0] | 1,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
          ];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
      var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      var tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (var n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf ? buf : bytesToUuid(b);
    }
    module2.exports = v1;
  }
});

// ../../../node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "../../../node_modules/uuid/v4.js"(exports2, module2) {
    "use strict";
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v4;
  }
});

// ../../../node_modules/uuid/index.js
var require_uuid = __commonJS({
  "../../../node_modules/uuid/index.js"(exports2, module2) {
    "use strict";
    var v1 = require_v1();
    var v4 = require_v4();
    var uuid5 = v4;
    uuid5.v1 = v1;
    uuid5.v4 = v4;
    module2.exports = uuid5;
  }
});

// src/lib/concurrency/concurrency-utils.ts
async function acquireLockAndRetrieveClientId() {
  const lockPath = getLockFilePath();
  if (nxInvokedByRunner()) {
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Nx invoked by runner, skipping lock acquisition"
      );
    }
    return await readFromLockFileMultipleRetries(lockPath);
  }
  if (VERBOSE_LOGGING) {
    console.log(
      "[Nx Cloud Debug] Attempting to acquire filesystem lock with path: ",
      lockPath
    );
  }
  try {
    (0, import_fs7.mkdirSync)(lockPath);
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Successfully created folder lock at path:",
        lockPath
      );
    }
  } catch (e) {
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Failed to create folder lock at path:",
        lockPath
      );
    }
    return await readFromLockFileMultipleRetries(lockPath);
  }
  return writeClientInstanceIdToLockfile(lockPath);
}
function getLockFilePath() {
  return (0, import_path5.join)((0, import_os.tmpdir)(), `client-instance-id.lock`);
}
function writeClientInstanceIdToLockfile(lockPath) {
  try {
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Attempting to write client instance id into lockfile"
      );
    }
    const clientInstanceId = import_uuid.default.v4();
    (0, import_fs7.writeFileSync)((0, import_path5.join)(lockPath, LOCK_FILE_NAME), clientInstanceId, {
      encoding: "utf-8"
    });
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Successfully wrote client instance id into lockfile"
      );
    }
    return clientInstanceId;
  } catch (e) {
    throw new Error("Skipped writing client instance id into lockfile");
  }
}
async function readFromLockFileMultipleRetries(lockPath) {
  try {
    const lockFile = (0, import_path5.join)(lockPath, LOCK_FILE_NAME);
    if (!(0, import_fs7.existsSync)(lockFile)) {
      let i = 0;
      while (i++ < 10) {
        if ((0, import_fs7.existsSync)(lockFile)) {
          return (0, import_fs7.readFileSync)(lockFile, "utf-8");
        }
        await wait(500);
      }
    }
    return (0, import_fs7.readFileSync)(lockFile, "utf-8");
  } catch (e) {
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Failed to read client id lockfile, returning default value"
      );
    }
    return DEFAULT_UUID;
  }
}
var import_fs7, import_os, import_path5, import_uuid, LOCK_FILE_NAME, DEFAULT_UUID;
var init_concurrency_utils = __esm({
  "src/lib/concurrency/concurrency-utils.ts"() {
    "use strict";
    import_fs7 = require("fs");
    import_os = require("os");
    import_path5 = require("path");
    import_uuid = __toESM(require_uuid());
    init_environment();
    init_waiter();
    LOCK_FILE_NAME = "client-instance-id.uuid";
    DEFAULT_UUID = "00000000-0000-0000-0000-000000000000";
  }
});

// src/lib/utilities/collect-contributor-info.ts
function getContributorCount() {
  const random = Math.floor(Math.random() * 100) + 1;
  const triggerRate = NX_CLOUD_CONTRIBUTOR_TESTING ? 100 : TRIGGER_RATE;
  return random <= triggerRate ? getContributorsFromGit() : null;
}
function getContributorsFromGit() {
  try {
    const collaborators = (0, import_child_process3.execSync)(
      `git log --since="30 days ago" --format="%ae"`,
      { stdio: "pipe", windowsHide: true }
    ).toString().trim().split("\n");
    return [...new Set(collaborators)].map((collaborator) => {
      const hash = (0, import_crypto5.createHash)("md5");
      hash.update(collaborator);
      return hash.digest("base64");
    });
  } catch (error) {
    return null;
  }
}
var import_child_process3, import_crypto5, TRIGGER_RATE;
var init_collect_contributor_info = __esm({
  "src/lib/utilities/collect-contributor-info.ts"() {
    "use strict";
    import_child_process3 = require("child_process");
    import_crypto5 = require("crypto");
    init_environment();
    TRIGGER_RATE = 2;
  }
});

// src/lib/utilities/trim-project-graph.ts
function removeNpmNodesFromProjectGraph(projectGraph) {
  if (!projectGraph)
    return null;
  const filteredNodes = {};
  Object.entries(projectGraph.nodes).forEach(([key, value2]) => {
    if (value2.type !== "npm") {
      filteredNodes[key] = {
        type: value2.type,
        name: value2.name,
        data: {
          root: value2.data.root,
          sourceRoot: value2.data.sourceRoot,
          metadata: value2.data.metadata,
          targets: value2.data.targets
        }
      };
    }
  });
  const filteredDependencies = {};
  Object.entries(projectGraph.dependencies).forEach(([key, value2]) => {
    if (!key.startsWith("npm:")) {
      filteredDependencies[key] = value2.filter(
        (dependency) => !dependency.target.startsWith("npm:")
      );
    }
  });
  return {
    nodes: filteredNodes,
    dependencies: filteredDependencies
  };
}
var init_trim_project_graph = __esm({
  "src/lib/utilities/trim-project-graph.ts"() {
    "use strict";
  }
});

// src/lib/core/runners/cloud-enabled/cloud-run.api.ts
var import_fs8, import_util2, import_zlib2, output9, CloudRunApi;
var init_cloud_run_api = __esm({
  "src/lib/core/runners/cloud-enabled/cloud-run.api.ts"() {
    "use strict";
    import_fs8 = require("fs");
    import_util2 = require("util");
    import_zlib2 = require("zlib");
    init_concurrency_utils();
    init_axios();
    init_collect_contributor_info();
    init_environment();
    init_get_vcs_context();
    init_trim_project_graph();
    ({ output: output9 } = require_nx_imports_light());
    CloudRunApi = class {
      constructor(messages, runContext, options, machineInfo) {
        this.messages = messages;
        this.runContext = runContext;
        this.machineInfo = machineInfo;
        this.apiAxiosInstance = createApiAxiosInstance(options);
        if (process.env.NX_CLOUD_CLIENT_INSTANCE_ID) {
          this.clientInstanceId = process.env.NX_CLOUD_CLIENT_INSTANCE_ID;
          this.clientInstanceSource = "DTE_AGENT";
        } else {
          this.clientInstanceSource = "CLOUD_RUNNER";
        }
      }
      async startRun(distributedExecutionId, hashes) {
        if (this.messages.apiError)
          return {};
        if (!this.clientInstanceId) {
          this.clientInstanceId = await acquireLockAndRetrieveClientId();
        }
        try {
          const request = {
            meta: {
              nxCloudVersion: this.nxCloudVersion()
            },
            branch: getBranch(),
            runGroup: getRunGroup(),
            ciExecutionId: getCIExecutionId(),
            ciExecutionEnv: getCIExecutionEnv(),
            distributedExecutionId,
            hashes,
            machineInfo: this.machineInfo,
            vcsContext: getVcsContext(),
            clientInstanceSource: this.clientInstanceSource,
            clientInstanceId: this.clientInstanceId
          };
          if (VERBOSE_LOGGING) {
            output9.note({
              title: "RunStart",
              bodyLines: ["\n" + JSON.stringify(request, null, 2)]
            });
          }
          const resp = await printDuration(
            "RunStart duration",
            () => axiosMultipleTries(
              () => this.apiAxiosInstance.post("/nx-cloud/v2/runs/start", request)
            )
          );
          if (resp.data && resp.data.message) {
            this.messages.message = resp.data.message;
          }
          if (!resp.data || !resp.data.artifacts) {
            this.messages.apiError = `Invalid Nx Cloud response: ${JSON.stringify(
              resp.data
            )}`;
            return {};
          }
          return resp.data.artifacts;
        } catch (e) {
          this.messages.apiError = this.messages.extractErrorMessage(e, "api");
          return {};
        }
      }
      createEndRunReqBody(run, tasks, ciExecutionContext, projectGraph, metadata, linkId) {
        const trimmedProjectGraph = removeNpmNodesFromProjectGraph(projectGraph);
        const uncompressedReqBody = {
          meta: {
            nxCloudVersion: this.nxCloudVersion(),
            ...metadata
          },
          tasks,
          run,
          linkId,
          ...ciExecutionContext,
          projectGraph: trimmedProjectGraph,
          machineInfo: this.machineInfo,
          vcsContext: getVcsContext(),
          hashedContributors: getContributorCount(),
          clientInstanceSource: this.clientInstanceSource,
          clientInstanceId: this.clientInstanceId
        };
        return JSON.stringify(uncompressedReqBody);
      }
      async endRun(run, tasks, ciExecutionContext, projectGraph, metadata, linkId) {
        if (this.messages.apiError)
          return false;
        if (!this.clientInstanceId) {
          this.clientInstanceId = await acquireLockAndRetrieveClientId();
        }
        run.runGroup = null;
        run.branch = null;
        let uncompressedBodyString = this.createEndRunReqBody(
          run,
          tasks,
          ciExecutionContext,
          projectGraph,
          metadata,
          linkId
        );
        if (uncompressedBodyString.length > 20 * 1e3 * 1e3) {
          uncompressedBodyString = this.createEndRunReqBody(
            run,
            tasks.map((t) => ({ ...t, hashDetails: void 0 })),
            ciExecutionContext,
            projectGraph,
            metadata,
            linkId
          );
        }
        const uncompressedBuffer = Buffer.from(uncompressedBodyString);
        const compressedBuffer = await (0, import_util2.promisify)(import_zlib2.gzip)(uncompressedBuffer);
        try {
          if (VERBOSE_LOGGING) {
            const t = tasks.map((tt) => {
              return {
                ...tt,
                terminalOutput: tt.terminalOutput ? `${tt.terminalOutput.slice(0, 20)}...` : void 0
              };
            });
            output9.note({
              title: "RunEnd. Completed tasks",
              bodyLines: ["\n" + JSON.stringify(t, null, 2)]
            });
          }
          const resp = await printDuration(
            "RunEnd duration",
            () => axiosMultipleTries(
              () => this.apiAxiosInstance.post("/nx-cloud/runs/end", compressedBuffer, {
                headers: {
                  ...this.apiAxiosInstance.defaults.headers,
                  "Content-Encoding": "gzip",
                  "Content-Type": "application/octet-stream"
                }
              })
            )
          );
          if (resp) {
            if (resp.data && resp.data.runUrl && resp.data.status === "success") {
              this.runContext.runUrl = resp.data.runUrl;
              return true;
            }
            if (resp.data && resp.data.status) {
              this.messages.apiError = `Invalid end run response: ${JSON.stringify(
                resp.data.message
              )}`;
            } else if (resp.data && typeof resp.data === "string") {
              if (resp.data !== "success") {
                this.messages.apiError = `Invalid end run response: ${JSON.stringify(
                  resp.data
                )}`;
              }
            } else {
              this.messages.apiError = `Invalid end run response: ${JSON.stringify(
                resp.data
              )}`;
            }
            if (VERBOSE_LOGGING) {
              output9.note({
                title: "Invalid end run response",
                bodyLines: [JSON.stringify(resp.data, null, 2)]
              });
            }
          } else {
            output9.error({
              title: "Nx Cloud: Unknown Error Occurred",
              bodyLines: [
                "Run completion responded with `undefined`.",
                "Run Details:",
                JSON.stringify(run, null, 2),
                "Stack Trace:",
                JSON.stringify(new Error().stack, null, 2)
              ]
            });
          }
          return false;
        } catch (ee) {
          const e = ee.axiosException ?? ee;
          this.messages.apiError = this.messages.extractErrorMessage(e, "api");
          return false;
        }
      }
      async endRunIfWorkspaceNotEnabled() {
        try {
          await axiosMultipleTries(
            () => this.apiAxiosInstance.get("/nx-cloud/runs/workspace-status")
          );
        } catch (e) {
          output9.error({
            title: "Nx Cloud: Workspace is disabled",
            bodyLines: e.bodyLines
          });
          process.exit(1);
        }
      }
      async getEndRunSplashMessage() {
        try {
          return this.apiAxiosInstance.get("/nx-cloud/runs/splash").then((r) => r.data);
        } catch (e) {
          return void 0;
        }
      }
      nxCloudVersion() {
        try {
          const v = JSON.parse((0, import_fs8.readFileSync)(`package.json`).toString());
          return v.devDependencies["nx-cloud"] || v.devDependencies["@nrwl/nx-cloud"];
        } catch (e) {
          return "unknown";
        }
      }
    };
  }
});

// src/lib/core/runners/cloud-enabled/id-generator.ts
function generateUniqueLinkId() {
  let res = "";
  for (let i = 0; i < 10; ++i) {
    res += alphanum[Math.floor(Math.random() * alphanum.length)];
  }
  return res;
}
var upper, digits, lower, alphanum;
var init_id_generator = __esm({
  "src/lib/core/runners/cloud-enabled/id-generator.ts"() {
    "use strict";
    upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    digits = "0123456789";
    lower = upper.toLowerCase();
    alphanum = upper + lower + digits;
  }
});

// src/lib/utilities/nx-imports.ts
var require_nx_imports = __commonJS({
  "src/lib/utilities/nx-imports.ts"(exports2) {
    "use strict";
    var import_path14 = require("path");
    init_light_client_require();
    try {
      try {
        let workspaceRoot7;
        try {
          workspaceRoot7 = lightClientRequire("nx/src/utils/app-root").workspaceRoot;
        } catch (_a2) {
          workspaceRoot7 = lightClientRequire(
            "nx/src/utils/workspace-root"
          ).workspaceRoot;
        }
        const { getDependencyConfigs: getDependencyConfigs2 } = lightClientRequire(
          "nx/src/tasks-runner/utils"
        );
        const tasksRunner3 = lightClientRequire("nx/tasks-runners/default").default;
        const { CompositeLifeCycle } = lightClientRequire(
          "nx/src/tasks-runner/life-cycle"
        );
        let initTasksRunner4 = null;
        try {
          initTasksRunner4 = lightClientRequire("nx/src/index").initTasksRunner;
        } catch (e) {
        }
        let cacheDirectory11;
        try {
          cacheDirectory11 = lightClientRequire("nx/src/devkit-exports").cacheDir;
        } catch (e) {
          try {
            cacheDirectory11 = lightClientRequire(
              "nx/src/utils/cache-directory"
            ).cacheDir;
          } catch (ee) {
            cacheDirectory11 = (0, import_path14.join)(workspaceRoot7, "./node_modules/.cache/nx");
          }
        }
        let isCacheableTask2 = lightClientRequire(
          "nx/src/tasks-runner/utils"
        ).isCacheableTask;
        exports2.cacheDirectory = cacheDirectory11;
        exports2.runnerReturnsPromise = true;
        exports2.tasksRunner = tasksRunner3;
        exports2.CompositeLifeCycle = CompositeLifeCycle;
        exports2.getDependencyConfigs = getDependencyConfigs2;
        exports2.initTasksRunner = initTasksRunner4;
        exports2.isCacheableTask = isCacheableTask2;
      } catch (e) {
        const { appRootPath } = lightClientRequire("@nrwl/tao/src/utils/app-root");
        const { getDependencyConfigs: getDependencyConfigs2 } = lightClientRequire(
          "@nrwl/workspace/src/tasks-runner/utils"
        );
        const { tasksRunnerV2 } = lightClientRequire(
          "@nrwl/workspace/src/tasks-runner/tasks-runner-v2"
        );
        let CompositeLifeCycle;
        try {
          CompositeLifeCycle = lightClientRequire(
            "@nrwl/workspace/src/tasks-runner/life-cycle"
          ).CompositeLifeCycle;
        } catch (e2) {
        }
        let isCacheableTask2 = lightClientRequire(
          "@nrwl/workspace/src/tasks-runner/utils"
        ).isCacheableTask;
        exports2.cacheDirectory = (0, import_path14.join)(appRootPath, "./node_modules/.cache/nx");
        exports2.runnerReturnsPromise = false;
        exports2.tasksRunner = tasksRunnerV2;
        exports2.CompositeLifeCycle = CompositeLifeCycle;
        exports2.getDependencyConfigs = getDependencyConfigs2;
        exports2.initTasksRunner = null;
        exports2.isCacheableTask = isCacheableTask2;
      }
    } catch (e) {
      if (process.env.NX_VERBOSE_LOGGING === "true") {
        console.log(e);
      }
      console.error("NX CLOUD ERROR");
      console.error("---------------------------------------");
      console.error(
        "This version of Nx Cloud is incompatible with the @nrwl/* and @nx/* packages in your workspace, or Nx was not installed properly."
      );
      console.error("");
      console.error("Verify your install step was successful, and if it was,");
      console.error(
        "match your @nrwl/nx-cloud version to the same major version of your @nx/* and @nrwl/* packages and try again."
      );
      console.error("---------------------------------------");
      process.exit(1);
    }
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args5) {
        if (typeof args5[args5.length - 1] === "function")
          fn.apply(this, args5);
        else {
          return new Promise((resolve2, reject) => {
            args5.push((err, res) => err != null ? reject(err) : resolve2(res));
            fn.apply(this, args5);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args5) {
        const cb = args5[args5.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args5);
        else {
          args5.pop();
          fn.apply(this, args5).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    "use strict";
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path5, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path5, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path5, mode, callback) {
          fs2.open(
            path5,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs2.fchmod(fd, mode, function(err2) {
                fs2.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs2.lchmodSync = function(path5, mode) {
          var fd = fs2.openSync(path5, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path5, at, mt, cb) {
            fs2.open(path5, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path5, at, mt) {
            var fd = fs2.openSync(path5, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a2, _b2, _c2, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path5, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path5, options);
        Stream.call(this);
        var self2 = this;
        this.path = path5;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path5, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path5, options);
        Stream.call(this);
        this.path = path5;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy2 = { __proto__: getPrototypeOf(obj) };
      else
        var copy2 = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy2;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream2;
      fs2.createWriteStream = createWriteStream2;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile2;
      function readFile2(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path5, options, cb);
        function go$readFile(path6, options2, cb2, startTime) {
          return fs$readFile(path6, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path6, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path5, data, options, cb);
        function go$writeFile(path6, data2, options2, cb2, startTime) {
          return fs$writeFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path5, data, options, cb);
        function go$appendFile(path6, data2, options2, cb2, startTime) {
          return fs$appendFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, options2, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path5, options, cb);
        function fs$readdirCallback(path6, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path6, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path5, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path5, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream2(path5, options) {
        return new fs2.ReadStream(path5, options);
      }
      function createWriteStream2(path5, options) {
        return new fs2.WriteStream(path5, options);
      }
      var fs$open = fs2.open;
      fs2.open = open2;
      function open2(path5, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path5, flags, mode, cb);
        function go$open(path6, flags2, mode2, cb2, startTime) {
          return fs$open(path6, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path6, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args5 = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args5);
        fn.apply(null, args5);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args5);
        var cb = args5.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args5);
          fn.apply(null, args5.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs[key] === "function";
    });
    Object.assign(exports2, fs);
    api.forEach((method) => {
      exports2[method] = u(fs[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs.exists(filename, callback);
      }
      return new Promise((resolve2) => {
        return fs.exists(filename, resolve2);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve2, reject) => {
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve2({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args5) {
      if (typeof args5[args5.length - 1] === "function") {
        return fs.write(fd, buffer, ...args5);
      }
      return new Promise((resolve2, reject) => {
        fs.write(fd, buffer, ...args5, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports2.readv = function(fd, buffers, ...args5) {
      if (typeof args5[args5.length - 1] === "function") {
        return fs.readv(fd, buffers, ...args5);
      }
      return new Promise((resolve2, reject) => {
        fs.readv(fd, buffers, ...args5, (err, bytesRead, buffers2) => {
          if (err)
            return reject(err);
          resolve2({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports2.writev = function(fd, buffers, ...args5) {
      if (typeof args5[args5.length - 1] === "function") {
        return fs.writev(fd, buffers, ...args5);
      }
      return new Promise((resolve2, reject) => {
        fs.writev(fd, buffers, ...args5, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve2({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs.realpath.native === "function") {
      exports2.realpath.native = u(fs.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/utils.js"(exports2, module2) {
    "use strict";
    var path5 = require("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path5.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs = require_fs();
    function pathExists2(path5) {
      return fs.access(path5).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists2),
      pathExistsSync: fs.existsSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var u = require_universalify().fromPromise;
    async function utimesMillis(path5, atime, mtime) {
      const fd = await fs.open(path5, "r+");
      let closeErr = null;
      try {
        await fs.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path5, atime, mtime) {
      const fd = fs.openSync(path5, "r+");
      fs.futimesSync(fd, atime, mtime);
      return fs.closeSync(fd);
    }
    module2.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var path5 = require("path");
    var u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs.stat(file, { bigint: true }) : (file) => fs.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs.statSync(file, { bigint: true }) : (file) => fs.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path5.basename(src);
          const destBaseName = path5.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path5.basename(src);
          const destBaseName = path5.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path5.resolve(path5.dirname(src));
      const destParent = path5.resolve(path5.dirname(dest));
      if (destParent === srcParent || destParent === path5.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = await fs.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path5.resolve(path5.dirname(src));
      const destParent = path5.resolve(path5.dirname(dest));
      if (destParent === srcParent || destParent === path5.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path5.resolve(src).split(path5.sep).filter((i) => i);
      const destArr = path5.resolve(dest).split(path5.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var path5 = require("path");
    var { mkdirs } = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists();
    var { utimesMillis } = require_utimes();
    var stat = require_stat();
    async function copy2(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
      await stat.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include)
        return;
      const destParent = path5.dirname(dest);
      const dirExists = await pathExists2(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter)
        return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs.stat : fs.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile(srcStat, src, dest, opts) {
      await fs.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs.mkdir(dest);
      }
      const items = await fs.readdir(src);
      await Promise.all(items.map(async (item) => {
        const srcItem = path5.join(src, item);
        const destItem = path5.join(dest, item);
        const include = await runFilter(srcItem, destItem, opts);
        if (!include)
          return;
        const { destStat: destStat2 } = await stat.checkPaths(srcItem, destItem, "copy", opts);
        return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
      }));
      if (!destStat) {
        await fs.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN")
          return fs.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path5.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs.unlink(dest);
      return fs.symlink(resolvedSrc, dest);
    }
    module2.exports = copy2;
  }
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/fs-extra/lib/copy/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path5 = require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path5.dirname(dest);
      if (!fs.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path5.join(src, item);
      const destItem = path5.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path5.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs.unlinkSync(dest);
      return fs.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove2(path5, callback) {
      fs.rm(path5, { recursive: true, force: true }, callback);
    }
    function removeSync(path5) {
      fs.rmSync(path5, { recursive: true, force: true });
    }
    module2.exports = {
      remove: u(remove2),
      removeSync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs = require_fs();
    var path5 = require("path");
    var mkdir = require_mkdirs();
    var remove2 = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove2.remove(path5.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path5.join(dir, item);
        remove2.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path5 = require("path");
    var fs = require_fs();
    var mkdir = require_mkdirs();
    async function createFile(file) {
      let stats;
      try {
        stats = await fs.stat(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path5.dirname(file);
      let dirStats = null;
      try {
        dirStats = await fs.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs.writeFile(file, "");
      } else {
        await fs.readdir(dir);
      }
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path5.dirname(file);
      try {
        if (!fs.statSync(dir).isDirectory()) {
          fs.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path5 = require("path");
    var fs = require_fs();
    var mkdir = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
      const dir = path5.dirname(dstpath);
      const dirExists = await pathExists2(dir);
      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }
      await fs.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path5.dirname(dstpath);
      const dirExists = fs.existsSync(dir);
      if (dirExists)
        return fs.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path5 = require("path");
    var fs = require_fs();
    var { pathExists: pathExists2 } = require_path_exists();
    var u = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path5.isAbsolute(srcpath)) {
        try {
          await fs.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path5.dirname(dstpath);
      const relativeToDst = path5.join(dstdir, srcpath);
      const exists = await pathExists2(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path5.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path5.isAbsolute(srcpath)) {
        const exists2 = fs.existsSync(srcpath);
        if (!exists2)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path5.dirname(dstpath);
      const relativeToDst = path5.join(dstdir, srcpath);
      const exists = fs.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs.existsSync(srcpath);
      if (!srcExists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path5.relative(dstdir, srcpath)
      };
    }
    module2.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var u = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type)
        return type;
      let stats;
      try {
        stats = await fs.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type)
        return type;
      let stats;
      try {
        stats = fs.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path5 = require("path");
    var fs = require_fs();
    var { mkdirs, mkdirsSync } = require_mkdirs();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
    var { symlinkType, symlinkTypeSync } = require_symlink_type();
    var { pathExists: pathExists2 } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs.stat(srcpath),
          fs.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path5.dirname(dstpath);
      if (!await pathExists2(dir)) {
        await mkdirs(dir);
      }
      return fs.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs.statSync(srcpath);
        const dstStat = fs.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path5.dirname(dstpath);
      const exists = fs.existsSync(dir);
      if (exists)
        return fs.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports2, module2) {
    "use strict";
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports2, module2) {
    "use strict";
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync17(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync10(file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify(obj, options);
      return fs.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync: readFileSync17,
      writeFile,
      writeFileSync: writeFileSync10
    };
    module2.exports = jsonfile;
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "node_modules/fs-extra/lib/output-file/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs = require_fs();
    var path5 = require("path");
    var mkdir = require_mkdirs();
    var pathExists2 = require_path_exists().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path5.dirname(file);
      if (!await pathExists2(dir)) {
        await mkdir.mkdirs(dir);
      }
      return fs.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args5) {
      const dir = path5.dirname(file);
      if (!fs.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs.writeFileSync(file, ...args5);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var path5 = require("path");
    var { copy: copy2 } = require_copy2();
    var { remove: remove2 } = require_remove();
    var { mkdirp } = require_mkdirs();
    var { pathExists: pathExists2 } = require_path_exists();
    var stat = require_stat();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
      await stat.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path5.dirname(dest);
      const parsedParentPath = path5.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove2(dest);
        } else if (await pathExists2(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy2(src, dest, opts);
      return remove2(src);
    }
    module2.exports = move;
  }
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/fs-extra/lib/move/move-sync.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path5 = require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path5.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path5.dirname(dest);
      const parsedPath = path5.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    module2.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// ../../../node_modules/rxjs/internal/util/isFunction.js
var require_isFunction = __commonJS({
  "../../../node_modules/rxjs/internal/util/isFunction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isFunction(x) {
      return typeof x === "function";
    }
    exports2.isFunction = isFunction;
  }
});

// ../../../node_modules/rxjs/internal/config.js
var require_config = __commonJS({
  "../../../node_modules/rxjs/internal/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _enable_super_gross_mode_that_will_cause_bad_things = false;
    exports2.config = {
      Promise: void 0,
      set useDeprecatedSynchronousErrorHandling(value2) {
        if (value2) {
          var error = new Error();
          console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          console.log("RxJS: Back to a better error behavior. Thank you. <3");
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value2;
      },
      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      }
    };
  }
});

// ../../../node_modules/rxjs/internal/util/hostReportError.js
var require_hostReportError = __commonJS({
  "../../../node_modules/rxjs/internal/util/hostReportError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function hostReportError(err) {
      setTimeout(function() {
        throw err;
      }, 0);
    }
    exports2.hostReportError = hostReportError;
  }
});

// ../../../node_modules/rxjs/internal/Observer.js
var require_Observer = __commonJS({
  "../../../node_modules/rxjs/internal/Observer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var config_1 = require_config();
    var hostReportError_1 = require_hostReportError();
    exports2.empty = {
      closed: true,
      next: function(value2) {
      },
      error: function(err) {
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError_1.hostReportError(err);
        }
      },
      complete: function() {
      }
    };
  }
});

// ../../../node_modules/rxjs/internal/util/isArray.js
var require_isArray = __commonJS({
  "../../../node_modules/rxjs/internal/util/isArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isArray = function() {
      return Array.isArray || function(x) {
        return x && typeof x.length === "number";
      };
    }();
  }
});

// ../../../node_modules/rxjs/internal/util/isObject.js
var require_isObject = __commonJS({
  "../../../node_modules/rxjs/internal/util/isObject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isObject(x) {
      return x !== null && typeof x === "object";
    }
    exports2.isObject = isObject;
  }
});

// ../../../node_modules/rxjs/internal/util/UnsubscriptionError.js
var require_UnsubscriptionError = __commonJS({
  "../../../node_modules/rxjs/internal/util/UnsubscriptionError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var UnsubscriptionErrorImpl = function() {
      function UnsubscriptionErrorImpl2(errors) {
        Error.call(this);
        this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
          return i + 1 + ") " + err.toString();
        }).join("\n  ") : "";
        this.name = "UnsubscriptionError";
        this.errors = errors;
        return this;
      }
      UnsubscriptionErrorImpl2.prototype = Object.create(Error.prototype);
      return UnsubscriptionErrorImpl2;
    }();
    exports2.UnsubscriptionError = UnsubscriptionErrorImpl;
  }
});

// ../../../node_modules/rxjs/internal/Subscription.js
var require_Subscription = __commonJS({
  "../../../node_modules/rxjs/internal/Subscription.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isArray_1 = require_isArray();
    var isObject_1 = require_isObject();
    var isFunction_1 = require_isFunction();
    var UnsubscriptionError_1 = require_UnsubscriptionError();
    var Subscription = function() {
      function Subscription2(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._unsubscribe = unsubscribe;
        }
      }
      Subscription2.prototype.unsubscribe = function() {
        var errors;
        if (this.closed) {
          return;
        }
        var _a2 = this, _parentOrParents = _a2._parentOrParents, _unsubscribe = _a2._unsubscribe, _subscriptions = _a2._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription2) {
          _parentOrParents.remove(this);
        } else if (_parentOrParents !== null) {
          for (var index = 0; index < _parentOrParents.length; ++index) {
            var parent_1 = _parentOrParents[index];
            parent_1.remove(this);
          }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
          try {
            _unsubscribe.call(this);
          } catch (e) {
            errors = e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
          }
        }
        if (isArray_1.isArray(_subscriptions)) {
          var index = -1;
          var len = _subscriptions.length;
          while (++index < len) {
            var sub = _subscriptions[index];
            if (isObject_1.isObject(sub)) {
              try {
                sub.unsubscribe();
              } catch (e) {
                errors = errors || [];
                if (e instanceof UnsubscriptionError_1.UnsubscriptionError) {
                  errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                } else {
                  errors.push(e);
                }
              }
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
      };
      Subscription2.prototype.add = function(teardown) {
        var subscription = teardown;
        if (!teardown) {
          return Subscription2.EMPTY;
        }
        switch (typeof teardown) {
          case "function":
            subscription = new Subscription2(teardown);
          case "object":
            if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (!(subscription instanceof Subscription2)) {
              var tmp = subscription;
              subscription = new Subscription2();
              subscription._subscriptions = [tmp];
            }
            break;
          default: {
            throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
          }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
          subscription._parentOrParents = this;
        } else if (_parentOrParents instanceof Subscription2) {
          if (_parentOrParents === this) {
            return subscription;
          }
          subscription._parentOrParents = [_parentOrParents, this];
        } else if (_parentOrParents.indexOf(this) === -1) {
          _parentOrParents.push(this);
        } else {
          return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
          this._subscriptions = [subscription];
        } else {
          subscriptions.push(subscription);
        }
        return subscription;
      };
      Subscription2.prototype.remove = function(subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
          var subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      };
      Subscription2.EMPTY = function(empty) {
        empty.closed = true;
        return empty;
      }(new Subscription2());
      return Subscription2;
    }();
    exports2.Subscription = Subscription;
    function flattenUnsubscriptionErrors(errors) {
      return errors.reduce(function(errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
      }, []);
    }
  }
});

// ../../../node_modules/rxjs/internal/symbol/rxSubscriber.js
var require_rxSubscriber = __commonJS({
  "../../../node_modules/rxjs/internal/symbol/rxSubscriber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rxSubscriber = function() {
      return typeof Symbol === "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random();
    }();
    exports2.$$rxSubscriber = exports2.rxSubscriber;
  }
});

// ../../../node_modules/rxjs/internal/Subscriber.js
var require_Subscriber = __commonJS({
  "../../../node_modules/rxjs/internal/Subscriber.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isFunction_1 = require_isFunction();
    var Observer_1 = require_Observer();
    var Subscription_1 = require_Subscription();
    var rxSubscriber_1 = require_rxSubscriber();
    var config_1 = require_config();
    var hostReportError_1 = require_hostReportError();
    var Subscriber = function(_super) {
      __extends(Subscriber2, _super);
      function Subscriber2(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
          case 0:
            _this.destination = Observer_1.empty;
            break;
          case 1:
            if (!destinationOrNext) {
              _this.destination = Observer_1.empty;
              break;
            }
            if (typeof destinationOrNext === "object") {
              if (destinationOrNext instanceof Subscriber2) {
                _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                _this.destination = destinationOrNext;
                destinationOrNext.add(_this);
              } else {
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext);
              }
              break;
            }
          default:
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
            break;
        }
        return _this;
      }
      Subscriber2.prototype[rxSubscriber_1.rxSubscriber] = function() {
        return this;
      };
      Subscriber2.create = function(next, error, complete) {
        var subscriber = new Subscriber2(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      };
      Subscriber2.prototype.next = function(value2) {
        if (!this.isStopped) {
          this._next(value2);
        }
      };
      Subscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          this.isStopped = true;
          this._error(err);
        }
      };
      Subscriber2.prototype.complete = function() {
        if (!this.isStopped) {
          this.isStopped = true;
          this._complete();
        }
      };
      Subscriber2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
      };
      Subscriber2.prototype._next = function(value2) {
        this.destination.next(value2);
      };
      Subscriber2.prototype._error = function(err) {
        this.destination.error(err);
        this.unsubscribe();
      };
      Subscriber2.prototype._complete = function() {
        this.destination.complete();
        this.unsubscribe();
      };
      Subscriber2.prototype._unsubscribeAndRecycle = function() {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
      };
      return Subscriber2;
    }(Subscription_1.Subscription);
    exports2.Subscriber = Subscriber;
    var SafeSubscriber = function(_super) {
      __extends(SafeSubscriber2, _super);
      function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;
          if (observerOrNext !== Observer_1.empty) {
            context = Object.create(observerOrNext);
            if (isFunction_1.isFunction(context.unsubscribe)) {
              _this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = _this.unsubscribe.bind(_this);
          }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
      }
      SafeSubscriber2.prototype.next = function(value2) {
        if (!this.isStopped && this._next) {
          var _parentSubscriber = this._parentSubscriber;
          if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value2);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value2)) {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.error = function(err) {
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          var useDeprecatedSynchronousErrorHandling = config_1.config.useDeprecatedSynchronousErrorHandling;
          if (this._error) {
            if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);
              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();
            if (useDeprecatedSynchronousErrorHandling) {
              throw err;
            }
            hostReportError_1.hostReportError(err);
          } else {
            if (useDeprecatedSynchronousErrorHandling) {
              _parentSubscriber.syncErrorValue = err;
              _parentSubscriber.syncErrorThrown = true;
            } else {
              hostReportError_1.hostReportError(err);
            }
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.complete = function() {
        var _this = this;
        if (!this.isStopped) {
          var _parentSubscriber = this._parentSubscriber;
          if (this._complete) {
            var wrappedComplete = function() {
              return _this._complete.call(_this._context);
            };
            if (!config_1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);
              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value2) {
        try {
          fn.call(this._context, value2);
        } catch (err) {
          this.unsubscribe();
          if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
          } else {
            hostReportError_1.hostReportError(err);
          }
        }
      };
      SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value2) {
        if (!config_1.config.useDeprecatedSynchronousErrorHandling) {
          throw new Error("bad call");
        }
        try {
          fn.call(this._context, value2);
        } catch (err) {
          if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
          } else {
            hostReportError_1.hostReportError(err);
            return true;
          }
        }
        return false;
      };
      SafeSubscriber2.prototype._unsubscribe = function() {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber2;
    }(Subscriber);
    exports2.SafeSubscriber = SafeSubscriber;
  }
});

// ../../../node_modules/rxjs/internal/util/canReportError.js
var require_canReportError = __commonJS({
  "../../../node_modules/rxjs/internal/util/canReportError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Subscriber_1 = require_Subscriber();
    function canReportError(observer) {
      while (observer) {
        var _a2 = observer, closed_1 = _a2.closed, destination = _a2.destination, isStopped = _a2.isStopped;
        if (closed_1 || isStopped) {
          return false;
        } else if (destination && destination instanceof Subscriber_1.Subscriber) {
          observer = destination;
        } else {
          observer = null;
        }
      }
      return true;
    }
    exports2.canReportError = canReportError;
  }
});

// ../../../node_modules/rxjs/internal/util/toSubscriber.js
var require_toSubscriber = __commonJS({
  "../../../node_modules/rxjs/internal/util/toSubscriber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Subscriber_1 = require_Subscriber();
    var rxSubscriber_1 = require_rxSubscriber();
    var Observer_1 = require_Observer();
    function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
          return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
          return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
      }
      if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
      }
      return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
    }
    exports2.toSubscriber = toSubscriber;
  }
});

// ../../../node_modules/rxjs/internal/symbol/observable.js
var require_observable = __commonJS({
  "../../../node_modules/rxjs/internal/symbol/observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
  }
});

// ../../../node_modules/rxjs/internal/util/identity.js
var require_identity = __commonJS({
  "../../../node_modules/rxjs/internal/util/identity.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function identity(x) {
      return x;
    }
    exports2.identity = identity;
  }
});

// ../../../node_modules/rxjs/internal/util/pipe.js
var require_pipe = __commonJS({
  "../../../node_modules/rxjs/internal/util/pipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var identity_1 = require_identity();
    function pipe() {
      var fns = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
      }
      return pipeFromArray(fns);
    }
    exports2.pipe = pipe;
    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity_1.identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce(function(prev, fn) {
          return fn(prev);
        }, input);
      };
    }
    exports2.pipeFromArray = pipeFromArray;
  }
});

// ../../../node_modules/rxjs/internal/Observable.js
var require_Observable = __commonJS({
  "../../../node_modules/rxjs/internal/Observable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var canReportError_1 = require_canReportError();
    var toSubscriber_1 = require_toSubscriber();
    var observable_1 = require_observable();
    var pipe_1 = require_pipe();
    var config_1 = require_config();
    var Observable = function() {
      function Observable2(subscribe) {
        this._isScalar = false;
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      Observable2.prototype.lift = function(operator) {
        var observable = new Observable2();
        observable.source = this;
        observable.operator = operator;
        return observable;
      };
      Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
          sink.add(operator.call(sink, this.source));
        } else {
          sink.add(this.source || config_1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config_1.config.useDeprecatedSynchronousErrorHandling) {
          if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
              throw sink.syncErrorValue;
            }
          }
        }
        return sink;
      };
      Observable2.prototype._trySubscribe = function(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          if (config_1.config.useDeprecatedSynchronousErrorHandling) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
          }
          if (canReportError_1.canReportError(sink)) {
            sink.error(err);
          } else {
            console.warn(err);
          }
        }
      };
      Observable2.prototype.forEach = function(next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve2, reject) {
          var subscription;
          subscription = _this.subscribe(function(value2) {
            try {
              next(value2);
            } catch (err) {
              reject(err);
              if (subscription) {
                subscription.unsubscribe();
              }
            }
          }, reject, resolve2);
        });
      };
      Observable2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
      };
      Observable2.prototype[observable_1.observable] = function() {
        return this;
      };
      Observable2.prototype.pipe = function() {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
          return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
      };
      Observable2.prototype.toPromise = function(promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function(resolve2, reject) {
          var value2;
          _this.subscribe(function(x) {
            return value2 = x;
          }, function(err) {
            return reject(err);
          }, function() {
            return resolve2(value2);
          });
        });
      };
      Observable2.create = function(subscribe) {
        return new Observable2(subscribe);
      };
      return Observable2;
    }();
    exports2.Observable = Observable;
    function getPromiseCtor(promiseCtor) {
      if (!promiseCtor) {
        promiseCtor = config_1.config.Promise || Promise;
      }
      if (!promiseCtor) {
        throw new Error("no Promise impl found");
      }
      return promiseCtor;
    }
  }
});

// ../../../node_modules/rxjs/internal/util/ObjectUnsubscribedError.js
var require_ObjectUnsubscribedError = __commonJS({
  "../../../node_modules/rxjs/internal/util/ObjectUnsubscribedError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ObjectUnsubscribedErrorImpl = function() {
      function ObjectUnsubscribedErrorImpl2() {
        Error.call(this);
        this.message = "object unsubscribed";
        this.name = "ObjectUnsubscribedError";
        return this;
      }
      ObjectUnsubscribedErrorImpl2.prototype = Object.create(Error.prototype);
      return ObjectUnsubscribedErrorImpl2;
    }();
    exports2.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
  }
});

// ../../../node_modules/rxjs/internal/SubjectSubscription.js
var require_SubjectSubscription = __commonJS({
  "../../../node_modules/rxjs/internal/SubjectSubscription.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Subscription_1 = require_Subscription();
    var SubjectSubscription = function(_super) {
      __extends(SubjectSubscription2, _super);
      function SubjectSubscription2(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
      }
      SubjectSubscription2.prototype.unsubscribe = function() {
        if (this.closed) {
          return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      };
      return SubjectSubscription2;
    }(Subscription_1.Subscription);
    exports2.SubjectSubscription = SubjectSubscription;
  }
});

// ../../../node_modules/rxjs/internal/Subject.js
var require_Subject = __commonJS({
  "../../../node_modules/rxjs/internal/Subject.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Observable_1 = require_Observable();
    var Subscriber_1 = require_Subscriber();
    var Subscription_1 = require_Subscription();
    var ObjectUnsubscribedError_1 = require_ObjectUnsubscribedError();
    var SubjectSubscription_1 = require_SubjectSubscription();
    var rxSubscriber_1 = require_rxSubscriber();
    var SubjectSubscriber = function(_super) {
      __extends(SubjectSubscriber2, _super);
      function SubjectSubscriber2(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
      }
      return SubjectSubscriber2;
    }(Subscriber_1.Subscriber);
    exports2.SubjectSubscriber = SubjectSubscriber;
    var Subject = function(_super) {
      __extends(Subject2, _super);
      function Subject2() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
      }
      Subject2.prototype[rxSubscriber_1.rxSubscriber] = function() {
        return new SubjectSubscriber(this);
      };
      Subject2.prototype.lift = function(operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      };
      Subject2.prototype.next = function(value2) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
          var observers = this.observers;
          var len = observers.length;
          var copy2 = observers.slice();
          for (var i = 0; i < len; i++) {
            copy2[i].next(value2);
          }
        }
      };
      Subject2.prototype.error = function(err) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy2 = observers.slice();
        for (var i = 0; i < len; i++) {
          copy2[i].error(err);
        }
        this.observers.length = 0;
      };
      Subject2.prototype.complete = function() {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy2 = observers.slice();
        for (var i = 0; i < len; i++) {
          copy2[i].complete();
        }
        this.observers.length = 0;
      };
      Subject2.prototype.unsubscribe = function() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      };
      Subject2.prototype._trySubscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
          return _super.prototype._trySubscribe.call(this, subscriber);
        }
      };
      Subject2.prototype._subscribe = function(subscriber) {
        if (this.closed) {
          throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return Subscription_1.Subscription.EMPTY;
        } else {
          this.observers.push(subscriber);
          return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
      };
      Subject2.prototype.asObservable = function() {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
      };
      Subject2.create = function(destination, source) {
        return new AnonymousSubject(destination, source);
      };
      return Subject2;
    }(Observable_1.Observable);
    exports2.Subject = Subject;
    var AnonymousSubject = function(_super) {
      __extends(AnonymousSubject2, _super);
      function AnonymousSubject2(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
      }
      AnonymousSubject2.prototype.next = function(value2) {
        var destination = this.destination;
        if (destination && destination.next) {
          destination.next(value2);
        }
      };
      AnonymousSubject2.prototype.error = function(err) {
        var destination = this.destination;
        if (destination && destination.error) {
          this.destination.error(err);
        }
      };
      AnonymousSubject2.prototype.complete = function() {
        var destination = this.destination;
        if (destination && destination.complete) {
          this.destination.complete();
        }
      };
      AnonymousSubject2.prototype._subscribe = function(subscriber) {
        var source = this.source;
        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return Subscription_1.Subscription.EMPTY;
        }
      };
      return AnonymousSubject2;
    }(Subject);
    exports2.AnonymousSubject = AnonymousSubject;
  }
});

// src/lib/core/runners/cloud-enabled/cloud-enabled.runner.ts
function createApi(errors, options, runContext) {
  const machineInfo = getMachineInfo();
  return new CloudRunApi(errors, runContext, options, machineInfo);
}
function storeTaskHashes(taskExecutions, directory, distributedExecutionId) {
  const hashes = JSON.stringify(
    taskExecutions.map((t) => ({
      taskId: t.taskId,
      hash: t.hash,
      code: t.status
    }))
  );
  if (VERBOSE_LOGGING) {
    output10.note({
      title: `Executed tasks with hashes: ${hashes}`
    });
  }
  (0, import_fs9.writeFileSync)(
    path4.join(directory, `tasks-hashes-${distributedExecutionId}`),
    hashes
  );
}
function storeLocalCacheHits(taskExecutions, remoteCache, nxCacheDirectory) {
  const hashes = taskExecutions.filter((t) => t.cacheStatus === "local-cache-hit").map((t) => t.hash);
  hashes.forEach((hash) => remoteCache.store(hash, nxCacheDirectory));
}
async function onComplete({
  daemon,
  options,
  fileStorage,
  remoteCache,
  api,
  outputObfuscator,
  runStartTime,
  messages,
  endOfRunMessage,
  taskExecutions,
  versionOfNxBefore133,
  inner,
  encryptionKey,
  storeInCurrentProcess,
  distributedExecutionId,
  runContext,
  projectGraph
}) {
  const runEndTime = (/* @__PURE__ */ new Date()).toISOString();
  const branch = getBranch();
  const runData = {
    command: outputObfuscator.obfuscate(parseCommand()),
    startTime: runStartTime,
    endTime: runEndTime,
    distributedExecutionId,
    branch,
    runGroup: getRunGroup(),
    // only set sha if branch is set because we invoke a separate process,
    // which adds a few millis
    sha: branch ? extractGitSha() : void 0,
    inner
  };
  const ciExecutionContext = {
    branch,
    runGroup: getRunGroup(),
    ciExecutionId: getCIExecutionId(),
    ciExecutionEnv: getCIExecutionEnv()
  };
  if (!agentRunningInDistributedExecution(distributedExecutionId)) {
    for (const taskExecution of taskExecutions) {
      const task = runContext.allTasks.find(
        (taskFromContext) => taskFromContext.hash === taskExecution.hash
      );
      const taskIsCacheable = (task == null ? void 0 : task.cache) ?? false;
      const taskHasNonZeroStatus = taskExecution.status != 0;
      if (task && (!taskIsCacheable || taskHasNonZeroStatus)) {
        if (!task.terminalOutputUploadedToFileStorage) {
          if (VERBOSE_LOGGING) {
            output10.note({
              title: `Storing terminal outputs for ${taskExecution.taskId} with hash ${taskExecution.hash}`
            });
          }
          await remoteCache.storeTerminalOutputsInCache(
            taskExecution.hash,
            cacheDirectory
          );
        }
      }
    }
  }
  if (storeInCurrentProcess) {
    if (agentRunningInDistributedExecution(distributedExecutionId)) {
      storeTaskHashes(taskExecutions, cacheDirectory, distributedExecutionId);
      storeLocalCacheHits(taskExecutions, remoteCache, cacheDirectory);
    }
    try {
      await remoteCache.waitForStoreRequestsToComplete();
    } catch (e) {
      output10.error({
        title: `Nx Cloud wasn't able to store artifacts.`
      });
      messages.printMessages();
      return false;
    }
    for (const hash of fileStorage.storedHashes) {
      const matchingTask = taskExecutions.find((t) => t.hash === hash);
      if (!matchingTask) {
        throw new Error(`Task with hash ${hash} isn't recorded`);
      }
      matchingTask.uploadedToStorage = true;
    }
    taskExecutions.forEach((taskExecution) => {
      const task = runContext.allTasks.find(
        (taskFromContext) => taskFromContext.hash === taskExecution.hash
      );
      taskExecution.artifactId = task == null ? void 0 : task.artifactId;
      taskExecution.terminalOutputUploadedToFileStorage = (task == null ? void 0 : task.terminalOutputUploadedToFileStorage) ?? false;
      taskExecution.isCacheable = (task == null ? void 0 : task.cache) ?? false;
      setTechnologiesOnTask(projectGraph.nodes, taskExecution);
    });
    try {
      await api.endRun(
        runData,
        taskExecutions,
        ciExecutionContext,
        projectGraph,
        getMetadataFromProjectGraphNodes(
          projectGraph.nodes,
          runContext.allTasks
        )
      );
    } catch (e) {
      output10.error({
        title: `Nx Cloud wasn't able to record its run.`
      });
      messages.printMessages();
      return false;
    }
  } else {
    try {
      const accessToken = ACCESS_TOKEN ? ACCESS_TOKEN : options.accessToken;
      const linkId = generateUniqueLinkId();
      const processRunEndFullPath = require.resolve(
        // Path is relative to *bundled* output root since most of the light client
        // is invoked from `index.js`
        "./lib/daemon/process-run-end"
      );
      await daemon.processInBackground(processRunEndFullPath, {
        encryptionKey,
        runnerOptions: { ...options, accessToken },
        delayedStoreRequests: remoteCache.delayedStoreRequests,
        ciExecutionContext,
        runEnd: {
          runData,
          taskExecutions,
          allTasks: runContext.allTasks,
          linkId
        },
        projectGraph,
        lightRunnerResolutionPaths: JSON.parse(
          process.env.NX_CLOUD_LIGHT_CLIENT_RESOLUTION_PATHS
        )
      });
      runContext.runUrl = `${removeTrailingSlash(
        options.url || "https://nx.app"
      )}/runs/${linkId}`;
    } catch (e) {
      output10.warn({
        title: `Nx Cloud Problems`,
        bodyLines: [e.message || e.toString()]
      });
      return false;
    }
  }
  if (versionOfNxBefore133) {
    setTimeout(() => {
      messages.printMessages();
      if (runContext.splashMessage && runContext.splashMessage.title) {
        output10.note(runContext.splashMessage);
      }
      if (!messages.anyErrors && !inner) {
        endOfRunMessage.printCacheHitsMessage();
      }
    }, 0);
  } else {
    messages.printMessages();
    if (runContext.splashMessage && runContext.splashMessage.title) {
      output10.note(runContext.splashMessage);
    }
    if (!messages.anyErrors && !inner) {
      endOfRunMessage.printCacheHitsMessage();
    }
  }
  return true;
}
function createLifeCycle(runContext, options, outputObfuscator, tasks) {
  const cloudEnabledLifeCycle = new CloudEnabledLifeCycle(
    runContext,
    cacheDirectory,
    options.cacheableOperations || [],
    outputObfuscator,
    tasks
  );
  try {
    const { CompositeLifeCycle } = require_nx_imports();
    if (!CompositeLifeCycle)
      return cloudEnabledLifeCycle;
    return new CompositeLifeCycle([options.lifeCycle, cloudEnabledLifeCycle]);
  } catch (e) {
    return cloudEnabledLifeCycle;
  }
}
async function fetchUrlsForKnownHashesUpfront(api, runContext, tasks, options, distributedExecutionId) {
  if (options.skipNxCache)
    return;
  let hashes = tasks.map((t) => t.hash).filter((h) => !!h);
  const exists = await Promise.all(
    hashes.map((hash) => {
      const tdCommit = (0, import_path6.join)(cacheDirectory, `${hash}.commit`);
      return pathExists(tdCommit);
    })
  );
  const missingHashes = [];
  for (let i = 0; i < exists.length; ++i) {
    if (!exists[i]) {
      missingHashes.push(hashes[i]);
    }
  }
  if (missingHashes.length > 0) {
    const startRunRequest = api.startRun(distributedExecutionId, missingHashes);
    for (const hash of missingHashes) {
      runContext.requests[hash] = startRunRequest;
    }
  }
}
async function fetchEndRunSplashMessage(api, runContext) {
  try {
    runContext.splashMessage = await api.getEndRunSplashMessage();
  } catch (e) {
  }
}
function cloudEnabledTasksRunner(tasks, options, context, inner = false) {
  var _a2;
  const distributedExecutionId = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID;
  const runContext = {
    statuses: {},
    scheduledTasks: [],
    requests: {},
    allTasks: tasks,
    nxArgs: {}
  };
  const versionOfNxBefore133 = options.lifeCycle === void 0;
  const taskExecutions = [];
  const messages = new MessageReporter(options);
  const api = createApi(messages, options, runContext);
  if (getCIExecutionId() && getBranch()) {
    api.endRunIfWorkspaceNotEnabled();
  }
  const endOfRunMessage = new EndOfRunMessage(
    runContext,
    taskExecutions,
    distributedExecutionId
  );
  const outputObfuscator = new OutputObfuscator(options.maskedProperties);
  const runStartTime = (/* @__PURE__ */ new Date()).toISOString();
  const lifeCycle = createLifeCycle(
    runContext,
    options,
    outputObfuscator,
    taskExecutions
  );
  const encryptionKey = ENCRYPTION_KEY || options.encryptionKey;
  const encryption = new E2EEncryption(encryptionKey);
  const errorApi = new ErrorReporterApi(options);
  const storeInCurrentProcess = agentRunningInDistributedExecution(distributedExecutionId) || !((_a2 = context.daemon) == null ? void 0 : _a2.enabled());
  const fileStorage = new FileStorage(
    encryption,
    errorApi,
    options,
    "cloud-enabled-runner"
  );
  const remoteCache = new CloudRemoteCache(
    messages,
    api,
    runContext,
    fileStorage,
    distributedExecutionId,
    storeInCurrentProcess
  );
  fetchUrlsForKnownHashesUpfront(
    api,
    runContext,
    tasks,
    options,
    distributedExecutionId
  );
  fetchEndRunSplashMessage(api, runContext);
  delete process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID;
  const res = tasksRunner(
    tasks,
    { ...options, remoteCache, lifeCycle },
    context
  );
  if (res.subscribe) {
    const { Subject } = require_Subject();
    const wrappedRes = new Subject();
    res.subscribe({
      next: (value2) => wrappedRes.next(value2),
      error: (err) => wrappedRes.error(err),
      complete: async () => {
        const success = await onComplete({
          daemon: context.daemon,
          options,
          fileStorage,
          remoteCache,
          api,
          outputObfuscator,
          runStartTime,
          messages,
          endOfRunMessage,
          taskExecutions,
          versionOfNxBefore133,
          inner,
          encryptionKey,
          storeInCurrentProcess,
          runContext,
          distributedExecutionId,
          projectGraph: context.projectGraph
        });
        if (!success && agentRunningInDistributedExecution(distributedExecutionId)) {
          if (process.env.NX_CLOUD_INVOKED_WITH_RUN_MANY === "true") {
            process.exit(DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
          } else {
            process.env.NX_CLOUD_CRITICAL_ERROR = "true";
          }
        }
        wrappedRes.complete();
      }
    });
    return wrappedRes;
  } else {
    return res.then(async (r) => {
      const success = await onComplete({
        daemon: context.daemon,
        options,
        fileStorage,
        remoteCache,
        api,
        outputObfuscator,
        runStartTime,
        messages,
        endOfRunMessage,
        taskExecutions,
        versionOfNxBefore133,
        inner,
        encryptionKey,
        storeInCurrentProcess,
        runContext,
        distributedExecutionId,
        projectGraph: context.projectGraph
      });
      if (!success && agentRunningInDistributedExecution(distributedExecutionId)) {
        if (process.env.NX_CLOUD_INVOKED_WITH_RUN_MANY === "true") {
          process.exit(DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
        } else {
          process.env.NX_CLOUD_CRITICAL_ERROR = "true";
        }
      }
      return r;
    }).catch(async (e) => {
      const success = await onComplete({
        daemon: context.daemon,
        options,
        fileStorage,
        remoteCache,
        api,
        outputObfuscator,
        runStartTime,
        messages,
        endOfRunMessage,
        taskExecutions,
        versionOfNxBefore133,
        inner,
        encryptionKey,
        storeInCurrentProcess,
        runContext,
        distributedExecutionId,
        projectGraph: context.projectGraph
      });
      if (!success && agentRunningInDistributedExecution(distributedExecutionId)) {
        if (process.env.NX_CLOUD_INVOKED_WITH_RUN_MANY === "true") {
          process.exit(DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
        } else {
          process.env.NX_CLOUD_CRITICAL_ERROR = "true";
        }
      }
      throw e;
    });
  }
}
var import_fs9, path4, import_path6, output10, tasksRunner, cacheDirectory, pathExists;
var init_cloud_enabled_runner = __esm({
  "src/lib/core/runners/cloud-enabled/cloud-enabled.runner.ts"() {
    "use strict";
    import_fs9 = require("fs");
    path4 = __toESM(require("path"));
    import_path6 = require("path");
    init_environment();
    init_project_graph_metadata();
    init_remove_trailing_slash();
    init_error_reporter_api();
    init_e2e_encryption();
    init_file_storage();
    init_end_of_run_message();
    init_message_reporter();
    init_output_obfuscator();
    init_cloud_enabled_life_cycle();
    init_cloud_remote_cache();
    init_cloud_run_api();
    init_id_generator();
    ({ output: output10 } = require_nx_imports_light());
    ({
      tasksRunner,
      cacheDirectory
    } = require_nx_imports());
    ({ pathExists } = require_lib());
  }
});

// src/lib/heartbeat/heartbeat-utils.ts
function getHeartbeatLockFilePath(runGroup) {
  const markerPath = (0, import_path7.join)((0, import_os2.tmpdir)(), `run-group-${runGroup}-marker.lock`);
  return markerPath;
}
function processIsAlive(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch (e) {
    return false;
  }
}
function getLockOwnerPid(lockPath) {
  try {
    const pidString = (0, import_fs10.readFileSync)((0, import_path7.join)(lockPath, "owner.pid"), {
      encoding: "utf-8"
    });
    return Number(pidString);
  } catch (e) {
    return void 0;
  }
}
function getOwnerElectionLockPath(lockPath, priorOwnerPid) {
  return (0, import_path7.join)(lockPath, `elect-owner-${priorOwnerPid}`);
}
function acquireFileSystemLock(lockPath) {
  let ownerElectionLockPath;
  try {
    (0, import_fs10.mkdirSync)(lockPath);
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Successfully created folder lock at path:",
        lockPath
      );
    }
  } catch (e) {
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Failed to create folder lock at path:",
        lockPath
      );
    }
    const lockOwnerPid = getLockOwnerPid(lockPath);
    if (lockOwnerPid !== void 0) {
      if (VERBOSE_LOGGING) {
        console.log("[Nx Cloud Debug] Found previous owner pid:", lockOwnerPid);
      }
      if (lockOwnerPid === process.pid) {
        if (VERBOSE_LOGGING) {
          console.log(
            "[Nx Cloud Debug] We are the previous owner, lock acquired"
          );
        }
        return;
      }
      if (processIsAlive(lockOwnerPid)) {
        if (VERBOSE_LOGGING) {
          console.log("[Nx Cloud Debug] Previous owner process is still alive");
        }
        throw new Error(
          `Current heartbeat owner (${lockOwnerPid}) is still alive`
        );
      }
    }
    try {
      ownerElectionLockPath = getOwnerElectionLockPath(
        lockPath,
        lockOwnerPid
      );
      if (VERBOSE_LOGGING) {
        console.log(
          "[Nx Cloud Debug] Attempting to secure ownership with lock path:",
          ownerElectionLockPath
        );
      }
      (0, import_fs10.mkdirSync)(ownerElectionLockPath);
    } catch (e2) {
      if (VERBOSE_LOGGING) {
        console.log("[Nx Cloud Debug] Failed to secure ownership lock");
      }
      throw new Error("Did not become new heartbeat process owner");
    }
  }
  try {
    if (VERBOSE_LOGGING) {
      console.log(
        "[Nx Cloud Debug] Attempting to write current PID to owner file:",
        process.pid
      );
    }
    (0, import_fs10.writeFileSync)((0, import_path7.join)(lockPath, "owner.pid"), process.pid.toString(), {
      encoding: "utf-8"
    });
    if (VERBOSE_LOGGING) {
      console.log("[Nx Cloud Debug] Successfully acquired lock");
    }
    return;
  } catch (e) {
    if (ownerElectionLockPath !== void 0 && (0, import_fs10.existsSync)(ownerElectionLockPath)) {
      (0, import_fs10.rmdirSync)(ownerElectionLockPath);
    }
    throw new Error(
      `Failed to write self process id (${process.pid}) to owner lockfile`
    );
  }
}
function writeHeartbeatProcessPid(runGroup, pid) {
  if (pid === void 0)
    return;
  const markerPath = getHeartbeatLockFilePath(runGroup);
  if (!(0, import_fs10.existsSync)(markerPath)) {
    (0, import_fs10.mkdirSync)(markerPath, { recursive: true });
  }
  (0, import_fs10.writeFileSync)(`${markerPath}/pid`, pid.toString());
}
var import_fs10, import_os2, import_path7;
var init_heartbeat_utils = __esm({
  "src/lib/heartbeat/heartbeat-utils.ts"() {
    "use strict";
    import_fs10 = require("fs");
    import_os2 = require("os");
    import_path7 = require("path");
    init_environment();
  }
});

// src/lib/heartbeat/heartbeat-client.ts
async function acquireLockAndSpawnHeartbeat(runGroupApi, runGroup) {
  const lockPath = getHeartbeatLockFilePath(runGroup);
  if (VERBOSE_LOGGING) {
    console.log(
      "[Nx Cloud Debug] Attempting to acquire filesystem lock with path: ",
      lockPath
    );
  }
  acquireFileSystemLock(lockPath);
  await spawnHeartbeatProcess(runGroupApi, runGroup).catch(() => {
    output11.error({
      title: "Took longer than 3 seconds to hear from heartbeat process",
      bodyLines: [
        "The heartbeat process may have not started properly. This CIPE could have inconsistent status reporting."
      ]
    });
  });
}
async function startHeartbeatProcessIfNotRunning(runGroupApi) {
  if (getBranch() == null) {
    return false;
  }
  const runGroup = getRunGroup();
  if (VERBOSE_LOGGING)
    output11.note({
      title: `Trying to create heartbeat background process for run group: ${runGroup}`
    });
  try {
    await acquireLockAndSpawnHeartbeat(runGroupApi, runGroup);
    return true;
  } catch (e) {
    const pid = await tryGetRunningHeartbeatPid(runGroup);
    if (pid === void 0) {
      if (VERBOSE_LOGGING) {
        console.log(
          "[Nx Cloud Debug] Was not able to locate a heartbeat process"
        );
      }
      return false;
    }
    createHeartbeatProcessWatcher(runGroupApi, runGroup, pid);
    return false;
  }
}
async function spawnHeartbeatProcess(runGroupApi, runGroup) {
  const stdio = process.env.NX_CLOUD_HEARTBEAT_INHERIT_STDIO == "true" ? "inherit" : "pipe";
  return new Promise((res, rej) => {
    const heartbeatProcess = (0, import_child_process4.spawn)(
      process.execPath,
      [require.resolve("./lib/heartbeat/heartbeat-process.js")],
      {
        detached: true,
        windowsHide: true,
        stdio
      }
    );
    if (stdio === "pipe") {
      heartbeatProcess.stdout.on("data", (message) => {
        try {
          if (message == "heartbeat-ready") {
            if (VERBOSE_LOGGING)
              output11.note({
                title: `Heartbeat process started successfully with PID ${heartbeatProcess.pid}`
              });
            writeHeartbeatProcessPid(runGroup, heartbeatProcess.pid);
            createHeartbeatProcessWatcher(
              runGroupApi,
              runGroup,
              heartbeatProcess.pid
            );
            heartbeatProcess.unref();
            res();
          }
        } catch (e) {
          if (VERBOSE_LOGGING)
            console.log("[Nx Cloud Debug] Error:", JSON.stringify(e));
          rej();
        }
      });
      setTimeout(() => rej(), 5e3);
    } else {
      res();
    }
  });
}
async function tryGetRunningHeartbeatPid(runGroup) {
  const markerPath = getHeartbeatLockFilePath(runGroup);
  for (let attempt = 0; attempt < 3; attempt++) {
    try {
      const pid = (0, import_fs11.readFileSync)(`${markerPath}/pid`, { encoding: "utf-8" });
      if (processIsAlive(Number(pid))) {
        return Number(pid);
      }
    } catch (e) {
    }
    await wait(1e3);
  }
  return void 0;
}
function createHeartbeatProcessWatcher(runGroupApi, runGroup, pid) {
  if (pid === void 0)
    return;
  if (!heartbeatWatcherIntervalId) {
    heartbeatWatcherIntervalId = setInterval(async () => {
      if (!isHeartbeatAlive(pid)) {
        const markerPath = getHeartbeatLockFilePath(runGroup);
        let logs;
        try {
          logs = (0, import_fs11.readFileSync)(`${markerPath}/logs.txt`, {
            encoding: "utf-8"
          });
        } catch (e) {
          logs = "Unable to find shutdown logs, likely the heartbeat process was sent a SIGKILL";
        }
        clearHeartbeatProcessWatcher();
        if (VERBOSE_LOGGING) {
          output11.error({
            title: "Nx Cloud Heartbeat missing",
            bodyLines: [
              `Expected to find process with PID ${pid} but none was found.`,
              `Output:`,
              ...logs.split("\n")
            ]
          });
        }
        const currentProcessStartedHeartbeat = await startHeartbeatProcessIfNotRunning(runGroupApi);
        if (currentProcessStartedHeartbeat) {
          if (VERBOSE_LOGGING)
            console.log("[Nx Cloud Debug] Sending heartbeat logs");
          await runGroupApi.sendHeartbeatLogs(logs, getCIExecutionId(), runGroup).catch((e) => {
            if (VERBOSE_LOGGING)
              output11.note({
                title: "Nx Cloud Unable to Upload Heartbeat Diagnostics",
                bodyLines: [
                  `An error occurred while uploading diagnostics from the Nx Cloud heartbeat process.`,
                  `This will not affect your run. To hide this message, disable verbose logging for future runs.`,
                  `Output:`,
                  JSON.stringify(e)
                ]
              });
          });
        }
      }
    }, 1e3);
    process.on("SIGINT", clearHeartbeatProcessWatcher);
    process.on("SIGTERM", clearHeartbeatProcessWatcher);
    process.on("uncaughtException", clearHeartbeatProcessWatcher);
    process.on("exit", clearHeartbeatProcessWatcher);
  }
}
function clearHeartbeatProcessWatcher() {
  clearInterval(heartbeatWatcherIntervalId);
  heartbeatWatcherIntervalId = void 0;
}
function isHeartbeatAlive(pid) {
  try {
    process.kill(pid, 0);
    return true;
  } catch (e) {
    return false;
  }
}
var import_child_process4, import_fs11, output11, heartbeatWatcherIntervalId;
var init_heartbeat_client = __esm({
  "src/lib/heartbeat/heartbeat-client.ts"() {
    "use strict";
    import_child_process4 = require("child_process");
    import_fs11 = require("fs");
    init_environment();
    init_waiter();
    init_heartbeat_utils();
    ({ output: output11 } = require_nx_imports_light());
  }
});

// src/lib/utilities/distributed-task-execution-detection.ts
function storeDteMarker() {
  (0, import_fs12.writeFileSync)(dteMarker, "true");
}
function isDistributedExecutionEnabled(dteFlag, useAgentsFlag) {
  if (dteFlag === true)
    return true;
  if (dteFlag === false)
    return false;
  if (useAgentsFlag === true)
    return true;
  if (useAgentsFlag === false)
    return false;
  const envVar = process.env.NX_CLOUD_DISTRIBUTED_EXECUTION;
  if (envVar === "false" || envVar === "FALSE" || envVar === "0")
    return false;
  if (envVar === "true" || envVar === "TRUE" || envVar === "1")
    return true;
  try {
    (0, import_fs12.readFileSync)(dteMarker);
    return true;
  } catch (e) {
    return false;
  }
}
var import_fs12, import_os3, import_path8, dteMarker;
var init_distributed_task_execution_detection = __esm({
  "src/lib/utilities/distributed-task-execution-detection.ts"() {
    "use strict";
    import_fs12 = require("fs");
    import_os3 = require("os");
    import_path8 = require("path");
    dteMarker = (0, import_path8.join)(
      (0, import_os3.tmpdir)(),
      `NX_CLOUD_DISTRIBUTED_EXECUTION-${(0, import_path8.basename)(process.cwd())}`
    );
  }
});

// src/lib/utilities/is-workspace-enabled.ts
async function isWorkspaceEnabled(options) {
  const axiosInstance = createApiAxiosInstance(options);
  return await axiosMultipleTries(
    () => axiosInstance.get("/nx-cloud/executions/workspace-status")
  );
}
var init_is_workspace_enabled = __esm({
  "src/lib/utilities/is-workspace-enabled.ts"() {
    "use strict";
    init_axios();
  }
});

// ../../../node_modules/rxjs/internal/util/subscribeToArray.js
var require_subscribeToArray = __commonJS({
  "../../../node_modules/rxjs/internal/util/subscribeToArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.subscribeToArray = function(array) {
      return function(subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      };
    };
  }
});

// ../../../node_modules/rxjs/internal/util/subscribeToPromise.js
var require_subscribeToPromise = __commonJS({
  "../../../node_modules/rxjs/internal/util/subscribeToPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hostReportError_1 = require_hostReportError();
    exports2.subscribeToPromise = function(promise) {
      return function(subscriber) {
        promise.then(function(value2) {
          if (!subscriber.closed) {
            subscriber.next(value2);
            subscriber.complete();
          }
        }, function(err) {
          return subscriber.error(err);
        }).then(null, hostReportError_1.hostReportError);
        return subscriber;
      };
    };
  }
});

// ../../../node_modules/rxjs/internal/symbol/iterator.js
var require_iterator2 = __commonJS({
  "../../../node_modules/rxjs/internal/symbol/iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function getSymbolIterator() {
      if (typeof Symbol !== "function" || !Symbol.iterator) {
        return "@@iterator";
      }
      return Symbol.iterator;
    }
    exports2.getSymbolIterator = getSymbolIterator;
    exports2.iterator = getSymbolIterator();
    exports2.$$iterator = exports2.iterator;
  }
});

// ../../../node_modules/rxjs/internal/util/subscribeToIterable.js
var require_subscribeToIterable = __commonJS({
  "../../../node_modules/rxjs/internal/util/subscribeToIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var iterator_1 = require_iterator2();
    exports2.subscribeToIterable = function(iterable) {
      return function(subscriber) {
        var iterator = iterable[iterator_1.iterator]();
        do {
          var item = iterator.next();
          if (item.done) {
            subscriber.complete();
            break;
          }
          subscriber.next(item.value);
          if (subscriber.closed) {
            break;
          }
        } while (true);
        if (typeof iterator.return === "function") {
          subscriber.add(function() {
            if (iterator.return) {
              iterator.return();
            }
          });
        }
        return subscriber;
      };
    };
  }
});

// ../../../node_modules/rxjs/internal/util/subscribeToObservable.js
var require_subscribeToObservable = __commonJS({
  "../../../node_modules/rxjs/internal/util/subscribeToObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var observable_1 = require_observable();
    exports2.subscribeToObservable = function(obj) {
      return function(subscriber) {
        var obs = obj[observable_1.observable]();
        if (typeof obs.subscribe !== "function") {
          throw new TypeError("Provided object does not correctly implement Symbol.observable");
        } else {
          return obs.subscribe(subscriber);
        }
      };
    };
  }
});

// ../../../node_modules/rxjs/internal/util/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../../../node_modules/rxjs/internal/util/isArrayLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isArrayLike = function(x) {
      return x && typeof x.length === "number" && typeof x !== "function";
    };
  }
});

// ../../../node_modules/rxjs/internal/util/isPromise.js
var require_isPromise = __commonJS({
  "../../../node_modules/rxjs/internal/util/isPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isPromise(value2) {
      return !!value2 && typeof value2.subscribe !== "function" && typeof value2.then === "function";
    }
    exports2.isPromise = isPromise;
  }
});

// ../../../node_modules/rxjs/internal/util/subscribeTo.js
var require_subscribeTo = __commonJS({
  "../../../node_modules/rxjs/internal/util/subscribeTo.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var subscribeToArray_1 = require_subscribeToArray();
    var subscribeToPromise_1 = require_subscribeToPromise();
    var subscribeToIterable_1 = require_subscribeToIterable();
    var subscribeToObservable_1 = require_subscribeToObservable();
    var isArrayLike_1 = require_isArrayLike();
    var isPromise_1 = require_isPromise();
    var isObject_1 = require_isObject();
    var iterator_1 = require_iterator2();
    var observable_1 = require_observable();
    exports2.subscribeTo = function(result) {
      if (!!result && typeof result[observable_1.observable] === "function") {
        return subscribeToObservable_1.subscribeToObservable(result);
      } else if (isArrayLike_1.isArrayLike(result)) {
        return subscribeToArray_1.subscribeToArray(result);
      } else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise_1.subscribeToPromise(result);
      } else if (!!result && typeof result[iterator_1.iterator] === "function") {
        return subscribeToIterable_1.subscribeToIterable(result);
      } else {
        var value2 = isObject_1.isObject(result) ? "an invalid object" : "'" + result + "'";
        var msg = "You provided " + value2 + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
        throw new TypeError(msg);
      }
    };
  }
});

// ../../../node_modules/rxjs/internal/scheduled/scheduleObservable.js
var require_scheduleObservable = __commonJS({
  "../../../node_modules/rxjs/internal/scheduled/scheduleObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var observable_1 = require_observable();
    function scheduleObservable(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function() {
          var observable = input[observable_1.observable]();
          sub.add(observable.subscribe({
            next: function(value2) {
              sub.add(scheduler.schedule(function() {
                return subscriber.next(value2);
              }));
            },
            error: function(err) {
              sub.add(scheduler.schedule(function() {
                return subscriber.error(err);
              }));
            },
            complete: function() {
              sub.add(scheduler.schedule(function() {
                return subscriber.complete();
              }));
            }
          }));
        }));
        return sub;
      });
    }
    exports2.scheduleObservable = scheduleObservable;
  }
});

// ../../../node_modules/rxjs/internal/scheduled/schedulePromise.js
var require_schedulePromise = __commonJS({
  "../../../node_modules/rxjs/internal/scheduled/schedulePromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    function schedulePromise(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function() {
          return input.then(function(value2) {
            sub.add(scheduler.schedule(function() {
              subscriber.next(value2);
              sub.add(scheduler.schedule(function() {
                return subscriber.complete();
              }));
            }));
          }, function(err) {
            sub.add(scheduler.schedule(function() {
              return subscriber.error(err);
            }));
          });
        }));
        return sub;
      });
    }
    exports2.schedulePromise = schedulePromise;
  }
});

// ../../../node_modules/rxjs/internal/scheduled/scheduleArray.js
var require_scheduleArray = __commonJS({
  "../../../node_modules/rxjs/internal/scheduled/scheduleArray.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    function scheduleArray(input, scheduler) {
      return new Observable_1.Observable(function(subscriber) {
        var sub = new Subscription_1.Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function() {
          if (i === input.length) {
            subscriber.complete();
            return;
          }
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            sub.add(this.schedule());
          }
        }));
        return sub;
      });
    }
    exports2.scheduleArray = scheduleArray;
  }
});

// ../../../node_modules/rxjs/internal/scheduled/scheduleIterable.js
var require_scheduleIterable = __commonJS({
  "../../../node_modules/rxjs/internal/scheduled/scheduleIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Observable_1 = require_Observable();
    var Subscription_1 = require_Subscription();
    var iterator_1 = require_iterator2();
    function scheduleIterable(input, scheduler) {
      if (!input) {
        throw new Error("Iterable cannot be null");
      }
      return new Observable_1.Observable(function(subscriber) {
        var sub = new Subscription_1.Subscription();
        var iterator;
        sub.add(function() {
          if (iterator && typeof iterator.return === "function") {
            iterator.return();
          }
        });
        sub.add(scheduler.schedule(function() {
          iterator = input[iterator_1.iterator]();
          sub.add(scheduler.schedule(function() {
            if (subscriber.closed) {
              return;
            }
            var value2;
            var done;
            try {
              var result = iterator.next();
              value2 = result.value;
              done = result.done;
            } catch (err) {
              subscriber.error(err);
              return;
            }
            if (done) {
              subscriber.complete();
            } else {
              subscriber.next(value2);
              this.schedule();
            }
          }));
        }));
        return sub;
      });
    }
    exports2.scheduleIterable = scheduleIterable;
  }
});

// ../../../node_modules/rxjs/internal/util/isInteropObservable.js
var require_isInteropObservable = __commonJS({
  "../../../node_modules/rxjs/internal/util/isInteropObservable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var observable_1 = require_observable();
    function isInteropObservable(input) {
      return input && typeof input[observable_1.observable] === "function";
    }
    exports2.isInteropObservable = isInteropObservable;
  }
});

// ../../../node_modules/rxjs/internal/util/isIterable.js
var require_isIterable = __commonJS({
  "../../../node_modules/rxjs/internal/util/isIterable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var iterator_1 = require_iterator2();
    function isIterable(input) {
      return input && typeof input[iterator_1.iterator] === "function";
    }
    exports2.isIterable = isIterable;
  }
});

// ../../../node_modules/rxjs/internal/scheduled/scheduled.js
var require_scheduled = __commonJS({
  "../../../node_modules/rxjs/internal/scheduled/scheduled.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var scheduleObservable_1 = require_scheduleObservable();
    var schedulePromise_1 = require_schedulePromise();
    var scheduleArray_1 = require_scheduleArray();
    var scheduleIterable_1 = require_scheduleIterable();
    var isInteropObservable_1 = require_isInteropObservable();
    var isPromise_1 = require_isPromise();
    var isArrayLike_1 = require_isArrayLike();
    var isIterable_1 = require_isIterable();
    function scheduled(input, scheduler) {
      if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
          return scheduleObservable_1.scheduleObservable(input, scheduler);
        } else if (isPromise_1.isPromise(input)) {
          return schedulePromise_1.schedulePromise(input, scheduler);
        } else if (isArrayLike_1.isArrayLike(input)) {
          return scheduleArray_1.scheduleArray(input, scheduler);
        } else if (isIterable_1.isIterable(input) || typeof input === "string") {
          return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
      }
      throw new TypeError((input !== null && typeof input || input) + " is not observable");
    }
    exports2.scheduled = scheduled;
  }
});

// ../../../node_modules/rxjs/internal/observable/from.js
var require_from = __commonJS({
  "../../../node_modules/rxjs/internal/observable/from.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Observable_1 = require_Observable();
    var subscribeTo_1 = require_subscribeTo();
    var scheduled_1 = require_scheduled();
    function from(input, scheduler) {
      if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
          return input;
        }
        return new Observable_1.Observable(subscribeTo_1.subscribeTo(input));
      } else {
        return scheduled_1.scheduled(input, scheduler);
      }
    }
    exports2.from = from;
  }
});

// ../../../node_modules/rxjs/internal/OuterSubscriber.js
var require_OuterSubscriber = __commonJS({
  "../../../node_modules/rxjs/internal/OuterSubscriber.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Subscriber_1 = require_Subscriber();
    var OuterSubscriber = function(_super) {
      __extends(OuterSubscriber2, _super);
      function OuterSubscriber2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      OuterSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };
      OuterSubscriber2.prototype.notifyError = function(error, innerSub) {
        this.destination.error(error);
      };
      OuterSubscriber2.prototype.notifyComplete = function(innerSub) {
        this.destination.complete();
      };
      return OuterSubscriber2;
    }(Subscriber_1.Subscriber);
    exports2.OuterSubscriber = OuterSubscriber;
  }
});

// ../../../node_modules/rxjs/internal/InnerSubscriber.js
var require_InnerSubscriber = __commonJS({
  "../../../node_modules/rxjs/internal/InnerSubscriber.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Subscriber_1 = require_Subscriber();
    var InnerSubscriber = function(_super) {
      __extends(InnerSubscriber2, _super);
      function InnerSubscriber2(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
      }
      InnerSubscriber2.prototype._next = function(value2) {
        this.parent.notifyNext(this.outerValue, value2, this.outerIndex, this.index++, this);
      };
      InnerSubscriber2.prototype._error = function(error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
      };
      InnerSubscriber2.prototype._complete = function() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      };
      return InnerSubscriber2;
    }(Subscriber_1.Subscriber);
    exports2.InnerSubscriber = InnerSubscriber;
  }
});

// ../../../node_modules/rxjs/internal/util/subscribeToResult.js
var require_subscribeToResult = __commonJS({
  "../../../node_modules/rxjs/internal/util/subscribeToResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var InnerSubscriber_1 = require_InnerSubscriber();
    var subscribeTo_1 = require_subscribeTo();
    var Observable_1 = require_Observable();
    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
      if (innerSubscriber === void 0) {
        innerSubscriber = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
      }
      if (innerSubscriber.closed) {
        return void 0;
      }
      if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
      }
      return subscribeTo_1.subscribeTo(result)(innerSubscriber);
    }
    exports2.subscribeToResult = subscribeToResult;
  }
});

// ../../../node_modules/rxjs/internal/operators/map.js
var require_map = __commonJS({
  "../../../node_modules/rxjs/internal/operators/map.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Subscriber_1 = require_Subscriber();
    function map(project, thisArg) {
      return function mapOperation(source) {
        if (typeof project !== "function") {
          throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
        }
        return source.lift(new MapOperator(project, thisArg));
      };
    }
    exports2.map = map;
    var MapOperator = function() {
      function MapOperator2(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }
      MapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator2;
    }();
    exports2.MapOperator = MapOperator;
    var MapSubscriber = function(_super) {
      __extends(MapSubscriber2, _super);
      function MapSubscriber2(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
      }
      MapSubscriber2.prototype._next = function(value2) {
        var result;
        try {
          result = this.project.call(this.thisArg, value2, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      };
      return MapSubscriber2;
    }(Subscriber_1.Subscriber);
  }
});

// ../../../node_modules/rxjs/internal/operators/switchMap.js
var require_switchMap = __commonJS({
  "../../../node_modules/rxjs/internal/operators/switchMap.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var OuterSubscriber_1 = require_OuterSubscriber();
    var InnerSubscriber_1 = require_InnerSubscriber();
    var subscribeToResult_1 = require_subscribeToResult();
    var map_1 = require_map();
    var from_1 = require_from();
    function switchMap(project, resultSelector) {
      if (typeof resultSelector === "function") {
        return function(source) {
          return source.pipe(switchMap(function(a, i) {
            return from_1.from(project(a, i)).pipe(map_1.map(function(b, ii) {
              return resultSelector(a, b, i, ii);
            }));
          }));
        };
      }
      return function(source) {
        return source.lift(new SwitchMapOperator(project));
      };
    }
    exports2.switchMap = switchMap;
    var SwitchMapOperator = function() {
      function SwitchMapOperator2(project) {
        this.project = project;
      }
      SwitchMapOperator2.prototype.call = function(subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
      };
      return SwitchMapOperator2;
    }();
    var SwitchMapSubscriber = function(_super) {
      __extends(SwitchMapSubscriber2, _super);
      function SwitchMapSubscriber2(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
      }
      SwitchMapSubscriber2.prototype._next = function(value2) {
        var result;
        var index = this.index++;
        try {
          result = this.project(value2, index);
        } catch (error) {
          this.destination.error(error);
          return;
        }
        this._innerSub(result, value2, index);
      };
      SwitchMapSubscriber2.prototype._innerSub = function(result, value2, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
          innerSubscription.unsubscribe();
        }
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, value2, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, void 0, void 0, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
          destination.add(this.innerSubscription);
        }
      };
      SwitchMapSubscriber2.prototype._complete = function() {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
          _super.prototype._complete.call(this);
        }
        this.unsubscribe();
      };
      SwitchMapSubscriber2.prototype._unsubscribe = function() {
        this.innerSubscription = null;
      };
      SwitchMapSubscriber2.prototype.notifyComplete = function(innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
          _super.prototype._complete.call(this);
        }
      };
      SwitchMapSubscriber2.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      };
      return SwitchMapSubscriber2;
    }(OuterSubscriber_1.OuterSubscriber);
  }
});

// src/lib/utilities/dte-artifact-storage.ts
var import_path9, readFile, copy, mkdirSync3, remove, output12, workspaceRoot3, DteArtifactStorage;
var init_dte_artifact_storage = __esm({
  "src/lib/utilities/dte-artifact-storage.ts"() {
    "use strict";
    import_path9 = require("path");
    init_environment();
    ({ readFile, copy, mkdirSync: mkdirSync3, remove } = require_lib());
    ({ output: output12, workspaceRoot: workspaceRoot3 } = require_nx_imports_light());
    DteArtifactStorage = class {
      constructor(fileStorage, cacheDirectory11) {
        this.fileStorage = fileStorage;
        this.cacheDirectory = cacheDirectory11;
        mkdirSync3(cacheDirectory11, { recursive: true });
        mkdirSync3((0, import_path9.join)(cacheDirectory11, "terminalOutputs"), { recursive: true });
      }
      async retrieveAndExtract(hash, cacheFiles) {
        if (process.env.NX_CLOUD_DEBUG_URLS == "true") {
          output12.note({
            title: `Retrieving artifacts from ${cacheFiles.map((cacheFile) => cacheFile.remoteUrl).join(", ")}`
          });
        }
        for (const cacheFile of cacheFiles) {
          switch (cacheFile.fileType) {
            case "artifact":
              await this.fileStorage.retrieve(hash, this.cacheDirectory, cacheFile);
              break;
            case "terminalOutput":
              await this.fileStorage.retrieve(hash, this.cacheDirectory, cacheFile);
              break;
          }
        }
        const outputs = (0, import_path9.join)(this.cacheDirectory, hash, "outputs");
        if (VERBOSE_LOGGING) {
          output12.note({
            title: `Extracting artifacts`,
            bodyLines: [`from: ${outputs}`, `to: ${workspaceRoot3}`]
          });
        }
        await copy(outputs, workspaceRoot3);
        if (VERBOSE_LOGGING) {
          output12.log({
            title: `Finished extracting artifacts`,
            bodyLines: [`from: ${outputs}`, `to: ${workspaceRoot3}`]
          });
        }
        return (await readFile((0, import_path9.join)(this.cacheDirectory, hash, "terminalOutput"))).toString();
      }
    };
  }
});

// src/lib/core/error/print-run-group-error.ts
function canDetectRunGroup(runGroup, ciExecutionId) {
  return !!runGroup || !!ciExecutionId;
}
function printRunGroupError() {
  output13.error({
    title: `Unable to determine the context for running Nx in CI`,
    bodyLines: [
      "- Nx tried to determine the context automatically but wasn't able to do it.",
      "- Use the NX_CI_EXECUTION_ID env variable to set it manually.",
      `- NX_CI_EXECUTION_ID must be a unique value for every CI execution/run.`
    ]
  });
}
var output13;
var init_print_run_group_error = __esm({
  "src/lib/core/error/print-run-group-error.ts"() {
    "use strict";
    ({ output: output13 } = require_nx_imports_light());
  }
});

// node_modules/strip-json-comments/index.js
function stripJsonComments(jsonString, { whitespace = true, trailingCommas = false } = {}) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
  }
  const strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;
  let isInsideString = false;
  let isInsideComment = false;
  let offset = 0;
  let buffer = "";
  let result = "";
  let commaIndex = -1;
  for (let index = 0; index < jsonString.length; index++) {
    const currentCharacter = jsonString[index];
    const nextCharacter = jsonString[index + 1];
    if (!isInsideComment && currentCharacter === '"') {
      const escaped = isEscaped(jsonString, index);
      if (!escaped) {
        isInsideString = !isInsideString;
      }
    }
    if (isInsideString) {
      continue;
    }
    if (!isInsideComment && currentCharacter + nextCharacter === "//") {
      buffer += jsonString.slice(offset, index);
      offset = index;
      isInsideComment = singleComment;
      index++;
    } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
      index++;
      isInsideComment = false;
      buffer += strip(jsonString, offset, index);
      offset = index;
      continue;
    } else if (isInsideComment === singleComment && currentCharacter === "\n") {
      isInsideComment = false;
      buffer += strip(jsonString, offset, index);
      offset = index;
    } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
      buffer += jsonString.slice(offset, index);
      offset = index;
      isInsideComment = multiComment;
      index++;
      continue;
    } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
      index++;
      isInsideComment = false;
      buffer += strip(jsonString, offset, index + 1);
      offset = index + 1;
      continue;
    } else if (trailingCommas && !isInsideComment) {
      if (commaIndex !== -1) {
        if (currentCharacter === "}" || currentCharacter === "]") {
          buffer += jsonString.slice(offset, index);
          result += strip(buffer, 0, 1) + buffer.slice(1);
          buffer = "";
          offset = index;
          commaIndex = -1;
        } else if (currentCharacter !== " " && currentCharacter !== "	" && currentCharacter !== "\r" && currentCharacter !== "\n") {
          buffer += jsonString.slice(offset, index);
          offset = index;
          commaIndex = -1;
        }
      } else if (currentCharacter === ",") {
        result += buffer + jsonString.slice(offset, index);
        buffer = "";
        offset = index;
        commaIndex = index;
      }
    }
  }
  return result + buffer + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
}
var singleComment, multiComment, stripWithoutWhitespace, stripWithWhitespace, isEscaped;
var init_strip_json_comments = __esm({
  "node_modules/strip-json-comments/index.js"() {
    "use strict";
    singleComment = Symbol("singleComment");
    multiComment = Symbol("multiComment");
    stripWithoutWhitespace = () => "";
    stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\S/g, " ");
    isEscaped = (jsonString, quotePosition) => {
      let index = quotePosition - 1;
      let backslashCount = 0;
      while (jsonString[index] === "\\") {
        index -= 1;
        backslashCount += 1;
      }
      return Boolean(backslashCount % 2);
    };
  }
});

// src/lib/core/runners/distributed-execution/v1/task-graph-creator.ts
function createTaskGraphCompat(options, projectGraph, tasks) {
  const nxjson = JSON.parse(
    stripJsonComments((0, import_fs13.readFileSync)(`${workspaceRoot4}/nx.json`).toString(), {
      trailingCommas: true
    })
  );
  return new TaskGraphCreator(
    projectGraph,
    getDefaultDependencyConfigs(nxjson, options)
  ).createTaskGraph(tasks);
}
function getDefaultDependencyConfigs(nxJson, runnerOptions) {
  const defaults = nxJson.targetDependencies ?? {};
  const strictlyOrderedTargets = runnerOptions ? runnerOptions.strictlyOrderedTargets ?? ["build"] : [];
  for (const target of strictlyOrderedTargets) {
    defaults[target] = defaults[target] || [];
    defaults[target].push({
      target,
      projects: "dependencies"
    });
  }
  return defaults;
}
var import_fs13, workspaceRoot4, getDependencyConfigs, TaskGraphCreator;
var init_task_graph_creator = __esm({
  "src/lib/core/runners/distributed-execution/v1/task-graph-creator.ts"() {
    "use strict";
    import_fs13 = require("fs");
    init_strip_json_comments();
    ({ workspaceRoot: workspaceRoot4 } = require_nx_imports_light());
    ({ getDependencyConfigs } = require_nx_imports());
    TaskGraphCreator = class {
      constructor(projectGraph, defaultTargetDependencies) {
        this.projectGraph = projectGraph;
        this.defaultTargetDependencies = defaultTargetDependencies;
      }
      createTaskGraph(tasks) {
        const graph = {
          roots: [],
          tasks: {},
          dependencies: {}
        };
        for (const task of tasks) {
          this.addTaskToGraph(task, graph);
          const dependencyConfigs = getDependencyConfigs(
            task.target,
            this.defaultTargetDependencies,
            this.projectGraph
          );
          if (!dependencyConfigs) {
            continue;
          }
          this.addTaskDependencies(task, dependencyConfigs, tasks, graph);
        }
        graph.roots = Object.keys(graph.dependencies).filter(
          (k) => graph.dependencies[k].length === 0
        );
        return graph;
      }
      addTaskDependencies(task, dependencyConfigs, tasks, graph) {
        for (const dependencyConfig of dependencyConfigs) {
          if (dependencyConfig.projects === "self") {
            for (const t of tasks) {
              if (t.target.project === task.target.project && t.target.target === dependencyConfig.target) {
                graph.dependencies[task.id].push(t.id);
              }
            }
          } else if (dependencyConfig.projects === "dependencies") {
            const seen = /* @__PURE__ */ new Set();
            this.addDependencies(
              task.target.project,
              dependencyConfig.target,
              tasks,
              graph,
              task.id,
              seen
            );
          }
        }
      }
      addDependencies(project, target, tasks, graph, taskId, seen) {
        seen.add(project);
        const dependencies = this.projectGraph.dependencies[project];
        if (dependencies) {
          const projectDependencies = dependencies.map(
            (dependency) => dependency.target
          );
          for (const projectDependency of projectDependencies) {
            if (seen.has(projectDependency)) {
              continue;
            }
            const dependency = this.findTask(
              { project: projectDependency, target },
              tasks
            );
            if (dependency) {
              if (graph.dependencies[taskId].indexOf(dependency.id) === -1) {
                graph.dependencies[taskId].push(dependency.id);
              }
            } else {
              this.addDependencies(
                projectDependency,
                target,
                tasks,
                graph,
                taskId,
                seen
              );
            }
          }
        }
      }
      findTask({ project, target }, tasks) {
        return tasks.find(
          (t) => t.target.project === project && t.target.target === target
        );
      }
      addTaskToGraph(task, graph) {
        graph.tasks[task.id] = task;
        graph.dependencies[task.id] = [];
      }
    };
  }
});

// src/lib/core/runners/distributed-execution/dte-utils.ts
function attachSignalListenersToCompleteRunGroupOnError(api, branch, runGroup, ciExecutionId, ciExecutionEnv) {
  process.on("SIGINT", async () => {
    await api.completeRunGroupWithError(
      branch,
      runGroup,
      ciExecutionId,
      ciExecutionEnv,
      "Main job was terminated via SIGINT"
    );
    process.exit(1);
  });
  process.on("SIGTERM", async () => {
    await api.completeRunGroupWithError(
      branch,
      runGroup,
      ciExecutionId,
      ciExecutionEnv,
      "Main job was terminated via SIGTERM"
    );
    process.exit(1);
  });
}
function calculateMaxParallel(options) {
  if (options.parallel === "false" || options.parallel === false) {
    return 1;
  } else if (options.parallel === "true" || options.parallel === true) {
    return Number(options.maxParallel || 3);
  } else if (options.parallel === void 0) {
    return options.maxParallel ? Number(options.maxParallel) : 3;
  } else {
    return Number(options.parallel) || 3;
  }
}
function removeHashDetails(taskGraph) {
  for (const task of Object.values(taskGraph.tasks)) {
    delete task.hashDetails;
  }
}
function getTaskGraph(context, tasks, options) {
  if (context.taskGraph) {
    removeHashDetails(context.taskGraph);
    return context.taskGraph;
  } else {
    const taskGraph = createTaskGraphCompat(
      options,
      context.projectGraph,
      tasks
    );
    removeHashDetails(taskGraph);
    return taskGraph;
  }
}
function getTaskRunnerConfiguration(runContext) {
  var _a2;
  const runner = (_a2 = runContext == null ? void 0 : runContext.nxArgs) == null ? void 0 : _a2.runner;
  if (runner === null || runner === void 0 || runner === "default")
    return null;
  return runner;
}
var NoopLifeCycle;
var init_dte_utils = __esm({
  "src/lib/core/runners/distributed-execution/dte-utils.ts"() {
    "use strict";
    init_task_graph_creator();
    NoopLifeCycle = class {
      scheduleTask(task) {
      }
      startTask(task) {
      }
      endTasks(tasks) {
      }
    };
  }
});

// src/lib/core/runners/distributed-execution/distributed-execution.api.ts
function createStartRequestV1(branch, runGroup, ciExecutionId, ciExecutionEnv, task, options, clientInstanceId, commitSha, projectGraph, taskRunnerConfiguration, meta) {
  const tasksToExecute = task.map((arr) => {
    return arr.map((t) => {
      return {
        taskId: t.id,
        hash: t.hash,
        projectName: t.target.project,
        target: t.target.target,
        configuration: t.target.configuration || null,
        params: serializeOverrides(t),
        projectRoot: t.projectRoot,
        cache: t.cache,
        outputs: t.outputs
      };
    });
  });
  const request = {
    command: parseCommand(),
    branch,
    runGroup,
    ciExecutionId,
    ciExecutionEnv,
    tasks: tasksToExecute,
    maxParallel: calculateMaxParallel(options),
    clientInstanceId,
    commitSha,
    projectGraph,
    taskRunnerConfiguration,
    meta
  };
  if (NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT) {
    request.agentCount = NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT;
  }
  if (!NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE) {
    request.stopAgentsOnFailure = false;
  }
  return request;
}
function createStartRequestV2(branch, runGroup, ciExecutionId, ciExecutionEnv, projectGraph, taskGraph, options, commitSha = null, taskRunnerConfiguration = null, clientInstanceId, meta, nxBail) {
  const request = {
    command: parseCommand(),
    branch,
    runGroup,
    ciExecutionId,
    ciExecutionEnv,
    projectGraph,
    taskGraph,
    maxParallel: calculateMaxParallel(options),
    commitSha,
    taskRunnerConfiguration,
    retryFlakyTasks: NX_CLOUD_RETRY_FLAKY_TASKS,
    clientInstanceId,
    meta,
    nxBail
  };
  if (NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT) {
    request.agentCount = NX_CLOUD_DISTRIBUTED_EXECUTION_AGENT_COUNT;
  }
  if (!NX_CLOUD_DISTRIBUTED_EXECUTION_STOP_AGENTS_ON_FAILURE) {
    request.stopAgentsOnFailure = false;
  }
  return request;
}
var import_util3, import_zlib3, output14, DistributedExecutionApi;
var init_distributed_execution_api = __esm({
  "src/lib/core/runners/distributed-execution/distributed-execution.api.ts"() {
    "use strict";
    import_util3 = require("util");
    import_zlib3 = require("zlib");
    init_axios();
    init_environment();
    init_get_vcs_context();
    init_serializer_overrides();
    init_dte_utils();
    ({ output: output14 } = require_nx_imports_light());
    DistributedExecutionApi = class {
      constructor(options) {
        this.apiAxiosInstance = createApiAxiosInstance(options, 6e4);
      }
      async start(params) {
        let resp;
        if (VERBOSE_LOGGING) {
          output14.note({
            title: "Starting a distributed execution",
            bodyLines: [JSON.stringify(params, null, 2)]
          });
        }
        try {
          resp = await axiosMultipleTries(
            () => this.apiAxiosInstance.post("/nx-cloud/executions/start", params)
          );
        } catch (e) {
          throw e;
        }
        if (!resp.data.enabled) {
          throw new Error(
            `Workspace is disabled. Cannot perform distributed task executions.`
          );
        }
        if (resp.data.error) {
          throw new Error(resp.data.error);
        }
        return resp.data.id;
      }
      async status(id, prevUpdatedAt) {
        try {
          const resp = await axiosMultipleTries(
            () => this.apiAxiosInstance.post("/nx-cloud/executions/status", {
              id,
              prevUpdatedAt
            })
          );
          return resp.data;
        } catch (e) {
          output14.error({
            title: e.message
          });
          process.exit(1);
        }
      }
      async completeRunGroupWithError(branch, runGroup, ciExecutionId, ciExecutionEnv, error) {
        if (VERBOSE_LOGGING) {
          output14.note({
            title: "Completing with an error",
            bodyLines: [
              `ciExecutionId: ${ciExecutionId}`,
              `ciExecutionEnv: ${ciExecutionEnv}`,
              `runGroup: ${runGroup}`,
              `error: ${error}`
            ]
          });
        }
        try {
          const resp = await axiosMultipleTries(
            () => this.apiAxiosInstance.post(
              "/nx-cloud/executions/complete-run-group",
              {
                branch,
                runGroup,
                ciExecutionId,
                ciExecutionEnv,
                criticalErrorMessage: error,
                vcsContext: getVcsContext()
              }
            ),
            3
          );
        } catch (e) {
          output14.error({
            title: e.message
          });
        }
      }
      async startV2(reqBody) {
        if (VERBOSE_LOGGING) {
          const logOutput = {
            command: reqBody.command,
            branch: reqBody.branch,
            runGroup: reqBody.runGroup,
            ciExecutionId: reqBody.ciExecutionId,
            ciExecutionEnv: reqBody.ciExecutionEnv,
            stopAgentsOnFailure: reqBody.stopAgentsOnFailure,
            retryFlakyTasks: reqBody.retryFlakyTasks,
            maxParallel: reqBody.maxParallel,
            agentCount: reqBody.agentCount,
            nxBail: reqBody.nxBail
          };
          output14.note({
            title: "Starting a distributed execution",
            bodyLines: [JSON.stringify(logOutput, null, 2)]
          });
        }
        const compressedReqBody = await this.compressRequestBody(reqBody);
        const resp = await axiosSingleTry(
          () => this.apiAxiosInstance.post(
            "/nx-cloud/v2/executions/start",
            compressedReqBody,
            {
              headers: {
                ...this.apiAxiosInstance.defaults.headers,
                "Content-Encoding": "gzip",
                "Content-Type": "application/octet-stream"
              }
            }
          )
        );
        if (!resp.data.enabled) {
          throw new Error(
            `Workspace is disabled. Cannot perform distributed task executions.`
          );
        }
        if (resp.data.error) {
          throw new Error(resp.data.error);
        }
        return resp.data.executionId;
      }
      async statusV2(id, prevUpdatedAt) {
        try {
          const resp = await axiosMultipleTries(
            () => this.apiAxiosInstance.post("/nx-cloud/v2/executions/status", {
              id,
              prevUpdatedAt
            })
          );
          return resp.data;
        } catch (e) {
          output14.error({
            title: e.message
          });
          process.exit(1);
        }
      }
      async compressRequestBody(reqBody) {
        const stringifiedBody = JSON.stringify(reqBody);
        const bodyAsBuffer = Buffer.from(stringifiedBody);
        return (0, import_util3.promisify)(import_zlib3.gzip)(bodyAsBuffer);
      }
    };
  }
});

// src/lib/utilities/create-unchanged-value-timeout.ts
function createUnchangedValueTimeout(options) {
  let value2 = new Object();
  let valueIsSetAt;
  return (newValue) => {
    if (value2 !== newValue) {
      value2 = newValue;
      valueIsSetAt = /* @__PURE__ */ new Date();
    } else {
      if ((/* @__PURE__ */ new Date()).getTime() - valueIsSetAt.getTime() > options.timeout) {
        output15.error({
          title: options.title
        });
        process.exit(1);
      }
    }
  };
}
var output15;
var init_create_unchanged_value_timeout = __esm({
  "src/lib/utilities/create-unchanged-value-timeout.ts"() {
    "use strict";
    ({ output: output15 } = require_nx_imports_light());
  }
});

// src/lib/core/runners/distributed-execution/process-task.ts
async function processTask(dteArtifactStorage, tasks, completedTask) {
  if (VERBOSE_LOGGING) {
    output16.note({
      title: `Processing task ${completedTask.taskId}`
    });
  }
  const matchingTask = tasks.find((tt) => completedTask.taskId === tt.id);
  if (!matchingTask) {
    throw new Error(`Found unknown task: ${completedTask.taskId}`);
  }
  const cacheFiles = [
    { remoteUrl: completedTask.url, fileType: "artifact" }
  ];
  if (completedTask.terminalOutputUrl) {
    cacheFiles.push({
      remoteUrl: completedTask.terminalOutputUrl,
      fileType: "terminalOutput"
    });
  }
  const terminalOutput = await dteArtifactStorage.retrieveAndExtract(
    completedTask.hash,
    cacheFiles
  );
  output16.logCommand(getCommand(matchingTask));
  process.stdout.write(terminalOutput);
  output16.addVerticalSeparator();
}
function getCommand(task) {
  const config = task.target.configuration ? `:${task.target.configuration}` : "";
  return [
    "nx",
    "run",
    `${task.target.project}:${task.target.target}${config}`,
    serializeOverrides(task)
  ].join(" ");
}
var output16;
var init_process_task = __esm({
  "src/lib/core/runners/distributed-execution/process-task.ts"() {
    "use strict";
    init_environment();
    init_serializer_overrides();
    ({ output: output16 } = require_nx_imports_light());
  }
});

// src/lib/core/runners/distributed-execution/v1/process-tasks.ts
async function processTasks(api, dteArtifactStorage, executionId, tasks) {
  let prevUpdatedAt = null;
  const processedTasks = {};
  const failIfNumberOfCompletedTasksDoesNotChangeAfterTimeout = createUnchangedValueTimeout({
    title: `No new completed tasks after ${NO_COMPLETED_TASKS_TIMEOUT / 1e3} seconds.`,
    timeout: NO_COMPLETED_TASKS_TIMEOUT
  });
  await wait(1e3);
  while (true) {
    if (VERBOSE_LOGGING) {
      output17.note({
        title: "Waiting..."
      });
    }
    const r = await api.status(executionId, prevUpdatedAt);
    if (VERBOSE_LOGGING) {
      output17.note({
        title: `Status update`,
        bodyLines: [
          `executionId: ${executionId}`,
          `executionStatus: ${r.executionStatus}`,
          `number of completed tasks: ${r.completedTasks.length}`,
          `error: ${r.criticalErrorMessage}`
        ]
      });
    }
    if (r.criticalErrorMessage) {
      output17.error({
        title: "Distributed Execution Terminated",
        bodyLines: ["Error:", r.criticalErrorMessage]
      });
      process.exit(1);
    }
    if (!r.updatedAt) {
      await wait(5e3);
    }
    prevUpdatedAt = r.updatedAt;
    failIfNumberOfCompletedTasksDoesNotChangeAfterTimeout(
      r.completedTasks.length
    );
    for (const t of r.completedTasks) {
      if (processedTasks[t.taskId])
        continue;
      await processTask(dteArtifactStorage, tasks, t);
      processedTasks[t.taskId] = true;
    }
    if (r.executionStatus === "COMPLETED") {
      return { commandStatus: r.commandStatus, runUrl: r.runUrl };
    }
  }
}
var output17;
var init_process_tasks = __esm({
  "src/lib/core/runners/distributed-execution/v1/process-tasks.ts"() {
    "use strict";
    init_create_unchanged_value_timeout();
    init_environment();
    init_waiter();
    init_process_task();
    ({ output: output17 } = require_nx_imports_light());
  }
});

// src/lib/core/runners/distributed-execution/v1/split-task-graph-into-stages.ts
function splitTasksIntoStages(taskGraph) {
  const stages = [];
  const notStagedTaskIds = new Set(
    Object.values(taskGraph.tasks).map((t) => t.id)
  );
  let stageIndex = 0;
  while (notStagedTaskIds.size > 0) {
    const currentStage = stages[stageIndex] = [];
    for (const taskId of notStagedTaskIds) {
      let ready = true;
      for (const dependency of taskGraph.dependencies[taskId]) {
        if (notStagedTaskIds.has(dependency)) {
          ready = false;
          break;
        }
      }
      if (!ready) {
        continue;
      }
      const task = taskGraph.tasks[taskId];
      currentStage.push(task);
    }
    for (const task of currentStage) {
      notStagedTaskIds.delete(task.id);
    }
    stageIndex++;
  }
  return stages;
}
var init_split_task_graph_into_stages = __esm({
  "src/lib/core/runners/distributed-execution/v1/split-task-graph-into-stages.ts"() {
    "use strict";
  }
});

// src/lib/core/runners/distributed-execution/v1/distributed-execution.runner.ts
var distributed_execution_runner_exports = {};
__export(distributed_execution_runner_exports, {
  nxCloudDistributedTasksRunner: () => nxCloudDistributedTasksRunner
});
async function runDistributedExecution(api, options, dteArtifactStorage, branch, runGroup, ciExecutionId, ciExecutionEnv, taskGraph, projectGraph, commitSha, commitRef, taskRunnerConfiguration) {
  const clientInstanceId = await acquireLockAndRetrieveClientId();
  const id = await api.start(
    createStartRequestV1(
      branch,
      runGroup,
      ciExecutionId,
      ciExecutionEnv,
      splitTasksIntoStages(taskGraph),
      options,
      clientInstanceId,
      commitSha,
      projectGraph,
      taskRunnerConfiguration
    )
  );
  return await processTasks(
    api,
    dteArtifactStorage,
    id,
    Object.values(taskGraph.tasks)
  );
}
var output18, cacheDirectory2, nxCloudDistributedTasksRunner;
var init_distributed_execution_runner = __esm({
  "src/lib/core/runners/distributed-execution/v1/distributed-execution.runner.ts"() {
    "use strict";
    init_concurrency_utils();
    init_dte_artifact_storage();
    init_environment();
    init_trim_project_graph();
    init_error_reporter_api();
    init_print_run_group_error();
    init_e2e_encryption();
    init_file_storage();
    init_distributed_execution_api();
    init_dte_utils();
    init_process_tasks();
    init_split_task_graph_into_stages();
    ({ output: output18 } = require_nx_imports_light());
    ({ cacheDirectory: cacheDirectory2 } = require_nx_imports());
    nxCloudDistributedTasksRunner = async (tasks, options, context) => {
      if (options.skipNxCache) {
        output18.warn({
          title: `--skip-nx-cache is ignored when using distributed tasks execution (DTE).`,
          bodyLine: [`DTE needs the cache to share files between agents.`]
        });
      }
      if (VERBOSE_LOGGING) {
        output18.note({
          title: "Starting distributed command execution"
        });
      }
      options.lifeCycle = new NoopLifeCycle();
      const branch = getBranch();
      const runGroup = getRunGroup();
      const ciExecutionId = getCIExecutionId();
      const ciExecutionEnv = getCIExecutionEnv();
      const commitSha = extractGitSha();
      const commitRef = extractGitRef();
      if (!canDetectRunGroup(runGroup, ciExecutionId)) {
        printRunGroupError();
        process.exit(1);
      }
      const encryption = new E2EEncryption(ENCRYPTION_KEY || options.encryptionKey);
      const errorReporter = new ErrorReporterApi(options);
      const dteArtifactStorage = new DteArtifactStorage(
        new FileStorage(encryption, errorReporter, options, "dte-main"),
        cacheDirectory2
      );
      const api = new DistributedExecutionApi(options);
      attachSignalListenersToCompleteRunGroupOnError(
        api,
        branch,
        runGroup,
        ciExecutionId,
        ciExecutionEnv
      );
      try {
        const taskGraph = getTaskGraph(context, tasks, options);
        const taskRunnerConfiguration = getTaskRunnerConfiguration(context);
        const r = await runDistributedExecution(
          api,
          options,
          dteArtifactStorage,
          branch,
          runGroup,
          ciExecutionId,
          ciExecutionEnv,
          taskGraph,
          removeNpmNodesFromProjectGraph(context.projectGraph),
          commitSha,
          commitRef,
          taskRunnerConfiguration
        );
        if (r.commandStatus === 0) {
          output18.success({
            title: "Successfully completed running the command.",
            bodyLines: [`See run details at ${r.runUrl}`]
          });
        } else {
          output18.error({
            title: "Command execution failed.",
            bodyLines: [`See run details at ${r.runUrl}`]
          });
        }
        process.exit(r.commandStatus);
      } catch (e) {
        const bodyLines = [e.message];
        if (e.bodyLines) {
          bodyLines.push(e.bodyLines);
        }
        output18.error({
          title: "Unable to complete a run.",
          bodyLines
        });
        try {
          await api.completeRunGroupWithError(
            branch,
            runGroup,
            ciExecutionId,
            ciExecutionEnv,
            `Main job terminated with an error: "${e.message}"`
          );
        } finally {
          process.exit(1);
        }
      }
    };
  }
});

// src/lib/core/runners/distributed-execution/v2/process-tasks-v2.ts
async function processTasksV2(api, dteArtifactStorage, executionId, tasks) {
  let prevUpdatedAt = null;
  const processedTasks = {};
  const failIfNumberOfCompletedTasksDoesNotChangeAfterTimeout = createUnchangedValueTimeout({
    title: `No new completed tasks after ${NO_COMPLETED_TASKS_TIMEOUT / 1e3} seconds.`,
    timeout: NO_COMPLETED_TASKS_TIMEOUT
  });
  while (true) {
    try {
      if (VERBOSE_LOGGING) {
        output19.note({
          title: "Waiting..."
        });
      }
      const r = await api.statusV2(executionId, prevUpdatedAt);
      if (VERBOSE_LOGGING) {
        output19.note({
          title: `Status update`,
          bodyLines: [
            `executionId: ${executionId}`,
            `executionStatus: ${r.executionStatus}`,
            `number of completed tasks: ${r.completedTasks.length}`,
            `error: ${r.criticalErrorMessage}`
          ]
        });
      }
      if (r.criticalErrorMessage) {
        output19.error({
          title: "Distributed Execution Terminated",
          bodyLines: ["Error:", r.criticalErrorMessage]
        });
        process.exit(1);
      }
      if (!r.updatedAt) {
        await wait(5e3);
      }
      prevUpdatedAt = r.updatedAt;
      failIfNumberOfCompletedTasksDoesNotChangeAfterTimeout(
        r.completedTasks.length
      );
      for (const t of r.completedTasks) {
        if (processedTasks[t.taskId])
          continue;
        await processTask(dteArtifactStorage, tasks, t);
        processedTasks[t.taskId] = true;
      }
      if (r.executionStatus === "COMPLETED") {
        return { commandStatus: r.commandStatus, runUrl: r.runUrl };
      }
    } catch (e) {
      console.log(e);
    }
  }
}
var output19;
var init_process_tasks_v2 = __esm({
  "src/lib/core/runners/distributed-execution/v2/process-tasks-v2.ts"() {
    "use strict";
    init_create_unchanged_value_timeout();
    init_environment();
    init_waiter();
    init_process_task();
    ({ output: output19 } = require_nx_imports_light());
  }
});

// src/lib/core/runners/distributed-execution/v2/distributed-execution-v2.runner.ts
var distributed_execution_v2_runner_exports = {};
__export(distributed_execution_v2_runner_exports, {
  nxCloudDistributedV2TasksRunner: () => nxCloudDistributedV2TasksRunner
});
async function runDistributedExecutionV2(api, options, dteArtifactStorage, branch, runGroup, ciExecutionId, ciExecutionEnv, taskGraph, projectGraph, commitSha, taskRunnerConfiguration, meta, nxBail) {
  const clientInstanceId = await acquireLockAndRetrieveClientId();
  const id = await api.startV2(
    createStartRequestV2(
      branch,
      runGroup,
      ciExecutionId,
      ciExecutionEnv,
      projectGraph,
      taskGraph,
      options,
      commitSha,
      taskRunnerConfiguration,
      clientInstanceId,
      meta,
      nxBail
    )
  );
  return await processTasksV2(
    api,
    dteArtifactStorage,
    id,
    Object.values(taskGraph.tasks)
  );
}
var output20, cacheDirectory3, nxCloudDistributedV2TasksRunner;
var init_distributed_execution_v2_runner = __esm({
  "src/lib/core/runners/distributed-execution/v2/distributed-execution-v2.runner.ts"() {
    "use strict";
    init_concurrency_utils();
    init_dte_artifact_storage();
    init_environment();
    init_project_graph_metadata();
    init_trim_project_graph();
    init_error_reporter_api();
    init_print_run_group_error();
    init_e2e_encryption();
    init_file_storage();
    init_distributed_execution_api();
    init_dte_utils();
    init_process_tasks_v2();
    ({ output: output20 } = require_nx_imports_light());
    ({ cacheDirectory: cacheDirectory3 } = require_nx_imports());
    nxCloudDistributedV2TasksRunner = async (tasks, options, context) => {
      var _a2;
      if (options.skipNxCache) {
        output20.warn({
          title: `--skip-nx-cache is ignored when using distributed tasks execution (DTE).`,
          bodyLine: [`DTE needs the cache to share files between agents.`]
        });
      }
      if (VERBOSE_LOGGING) {
        output20.note({
          title: "Starting distributed command execution (v2)"
        });
      }
      options.lifeCycle = new NoopLifeCycle();
      const branch = getBranch();
      const runGroup = getRunGroup();
      const ciExecutionId = getCIExecutionId();
      const ciExecutionEnv = getCIExecutionEnv();
      const commitSha = extractGitSha();
      if (!canDetectRunGroup(runGroup, ciExecutionId)) {
        printRunGroupError();
        process.exit(1);
      }
      const encryption = new E2EEncryption(ENCRYPTION_KEY || options.encryptionKey);
      const errorReporter = new ErrorReporterApi(options);
      const dteArtifactStorage = new DteArtifactStorage(
        new FileStorage(encryption, errorReporter, options, "dte-main"),
        cacheDirectory3
      );
      const api = new DistributedExecutionApi(options);
      attachSignalListenersToCompleteRunGroupOnError(
        api,
        branch,
        runGroup,
        ciExecutionId,
        ciExecutionEnv
      );
      try {
        const r = await runDistributedExecutionV2(
          api,
          options,
          dteArtifactStorage,
          branch,
          runGroup,
          ciExecutionId,
          ciExecutionEnv,
          getTaskGraph(context, tasks, options),
          removeNpmNodesFromProjectGraph(context.projectGraph),
          commitSha,
          getTaskRunnerConfiguration(context),
          getMetadataFromProjectGraphNodes(context.projectGraph.nodes, tasks),
          (_a2 = context == null ? void 0 : context.nxArgs) == null ? void 0 : _a2.nxBail
        );
        if (r.commandStatus === 0) {
          output20.success({
            title: "Successfully completed running the command.",
            bodyLines: [`See run details at ${r.runUrl}`]
          });
        } else {
          output20.error({
            title: "Command execution failed.",
            bodyLines: [`See run details at ${r.runUrl}`]
          });
        }
        process.exit(r.commandStatus);
      } catch (e) {
        const bodyLines = [e.message];
        if (e.bodyLines) {
          bodyLines.push(e.bodyLines);
        }
        output20.error({
          title: "Unable to complete a run.",
          bodyLines
        });
        try {
          await api.completeRunGroupWithError(
            branch,
            runGroup,
            ciExecutionId,
            ciExecutionEnv,
            `Main job terminated with an error: "${e.message}"`
          );
        } finally {
          process.exit(1);
        }
      }
    };
  }
});

// src/lib/nx-cloud-tasks-runner.ts
var nx_cloud_tasks_runner_exports = {};
__export(nx_cloud_tasks_runner_exports, {
  default: () => nx_cloud_tasks_runner_default
});
function dteLegacyObservableVersion(tasks, options, context) {
  const { from } = require_from();
  const { switchMap } = require_switchMap();
  return from(isWorkspaceEnabled(options)).pipe(
    switchMap((res) => {
      if (res.data.enabled) {
        return process.env.NX_CLOUD_DTE_V1 === "true" ? (init_distributed_execution_runner(), __toCommonJS(distributed_execution_runner_exports)).nxCloudDistributedTasksRunner(
          tasks,
          options,
          context
        ) : (init_distributed_execution_v2_runner(), __toCommonJS(distributed_execution_v2_runner_exports)).nxCloudDistributedV2TasksRunner(
          tasks,
          options,
          context
        );
      }
      output21.warn({
        title: "Nx Cloud: Workspace Disabled",
        bodyLines: [
          "This run and following runs will not use distributed task execution until",
          "the outstanding balance is paid or additional coupons are added for this",
          "workspace. If you believe you are receiving this message in error, please",
          "contact support at cloud-support@nrwl.io.",
          "",
          "Execution will now continue using this machine only."
        ]
      });
      process.env.NX_INVOKED_BY_RUNNER = "true";
      return cloudEnabledTasksRunner(tasks, options, context);
    })
  );
}
async function dtePromiseVersion(tasks, options, context) {
  const isEnabled = await isWorkspaceEnabled(options);
  if (isEnabled.data.enabled) {
    return process.env.NX_CLOUD_DTE_V1 === "true" ? (init_distributed_execution_runner(), __toCommonJS(distributed_execution_runner_exports)).nxCloudDistributedTasksRunner(
      tasks,
      options,
      context
    ) : (init_distributed_execution_v2_runner(), __toCommonJS(distributed_execution_v2_runner_exports)).nxCloudDistributedV2TasksRunner(
      tasks,
      options,
      context
    );
  } else {
    output21.warn({
      title: "Nx Cloud: Workspace Disabled",
      bodyLines: [
        "This run and following runs will not use distributed task execution until",
        "the outstanding balance is paid.",
        "",
        "If you believe you are receiving this message in error, please",
        "contact support at cloud-support@nrwl.io.",
        "",
        "Execution will now continue using this machine only."
      ]
    });
    process.env.NX_INVOKED_BY_RUNNER = "true";
    return cloudEnabledTasksRunner(tasks, options, context);
  }
}
function anyCacheableTargets(tasks, options) {
  const cacheableOperations = options.cacheableOperations || [];
  return tasks.some(
    (task) => isCacheableTask(task, { cacheableOperations })
  );
}
function verifyAllOperationsAreCacheableOnMainJob(tasks, options) {
  const cacheableOperations = options.cacheableOperations || [];
  for (const task of tasks) {
    if (!isCacheableTask(task, { cacheableOperations })) {
      output21.error({
        title: `Distributed task execution only works for cacheable targets`,
        bodyLines: [
          `Target '${task.target.project}:${task.target.target}' cannot be executed.`,
          `To be able to replay the output of the target, distributed task execution only supports cacheable targets.`,
          `You can verify that '${task.target.target}' is part of the list of cacheable targets in the 'nx.json' file.`,
          `You can invoke this command without distribution by doing "NX_CLOUD_DISTRIBUTED_EXECUTION=false nx ...".`
        ]
      });
      process.exit(1);
    }
  }
}
function verifyAllOperationsAreCacheableOnAgent(tasks, options) {
  const cacheableOperations = options.cacheableOperations || [];
  for (const task of tasks) {
    if (!isCacheableTask(task, { cacheableOperations })) {
      output21.error({
        title: `Distributed task execution only works for cacheable targets`,
        bodyLines: [
          `Target ${task.target.project}:${task.target.target} cannot be executed.`,
          `To be able to replay the output of the target, distributed task execution only supports cacheable targets.`,
          `You can still invoke "nx ${task.target.target} ${task.target.project}" from within a cacheable target when using "nx:run-commands".`
        ]
      });
      process.exit(DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE);
    }
  }
}
var output21, tasksRunner2, runnerReturnsPromise, isCacheableTask, nxCloudTasksRunner, nx_cloud_tasks_runner_default;
var init_nx_cloud_tasks_runner = __esm({
  "src/lib/nx-cloud-tasks-runner.ts"() {
    "use strict";
    init_run_group_api();
    init_cloud_enabled_runner();
    init_heartbeat_client();
    init_distributed_task_execution_detection();
    init_environment();
    init_is_workspace_enabled();
    ({ output: output21 } = require_nx_imports_light());
    ({
      tasksRunner: tasksRunner2,
      runnerReturnsPromise,
      isCacheableTask
    } = require_nx_imports());
    nxCloudTasksRunner = async (tasks, options, context = {}) => {
      const nxArgs = context.nxArgs || {};
      const noAccessTokenDefined = !ACCESS_TOKEN && !options.accessToken;
      const noCloud = nxArgs["cloud"] === false || NX_NO_CLOUD;
      if (noAccessTokenDefined || noCloud || options.skipNxCache) {
        if (noAccessTokenDefined) {
          output21.warn({
            title: "No access token found",
            bodyLines: [
              "Nx will continue running, but nothing will be written or read from the remote cache.",
              "Run details will also not be available in the Nx Cloud UI."
            ]
          });
        }
        if (noCloud) {
          output21.warn({
            title: "Nx Cloud Manually Disabled",
            bodyLines: [
              "Nx will continue running, but nothing will be written or read from the remote cache.",
              "Run details will also not be available in the Nx Cloud UI.",
              "",
              "If this wasn't intentional, check for the NX_NO_CLOUD environment variable, the --no-cloud flag"
            ]
          });
        }
        if (options.skipNxCache) {
          output21.warn({
            title: "--skip-nx-cache disables the connection to Nx Cloud for the current run.",
            bodyLines: [
              "The remote cache will not be read from or written to during this run."
            ]
          });
        }
        return tasksRunner2(tasks, options, context);
      }
      if (nxInvokedByRunner()) {
        if (anyCacheableTargets(tasks, options)) {
          return cloudEnabledTasksRunner(tasks, options, context, true);
        } else {
          return tasksRunner2(tasks, options, context);
        }
      }
      if (agentRunningInDistributedExecution(
        process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID
      )) {
        verifyAllOperationsAreCacheableOnAgent(tasks, options);
      } else {
        const runGroupApi = new RunGroupApi(options);
        await startHeartbeatProcessIfNotRunning(runGroupApi);
      }
      if (isDistributedExecutionEnabled(nxArgs["dte"], nxArgs["useAgents"]) && !agentRunningInDistributedExecution(
        process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID
      )) {
        verifyAllOperationsAreCacheableOnMainJob(tasks, options);
        if (runnerReturnsPromise) {
          return dtePromiseVersion(tasks, options, context);
        } else {
          return dteLegacyObservableVersion(tasks, options, context);
        }
      }
      process.env.NX_INVOKED_BY_RUNNER = "true";
      return cloudEnabledTasksRunner(tasks, options, context);
    };
    nx_cloud_tasks_runner_default = nxCloudTasksRunner;
  }
});

// src/lib/core/commands/clean-up-agents.ts
var clean_up_agents_exports = {};
__export(clean_up_agents_exports, {
  cleanUpAgents: () => cleanUpAgents
});
async function cleanUpAgents() {
  const lockFileDirectory = `${cacheDirectory4}/lockfiles`;
  if (VERBOSE_LOGGING) {
    output22.note({
      title: `Cleaning up agent metadata for this workspace.`
    });
  }
  return (0, import_fs14.rm)(lockFileDirectory, { recursive: true, force: true }, (err) => {
    if (err)
      throw err;
  });
}
var import_fs14, output22, cacheDirectory4;
var init_clean_up_agents = __esm({
  "src/lib/core/commands/clean-up-agents.ts"() {
    "use strict";
    import_fs14 = require("fs");
    init_environment();
    ({ output: output22 } = require_nx_imports_light());
    ({ cacheDirectory: cacheDirectory4 } = require_nx_imports());
  }
});

// src/lib/utilities/get-cloud-options.ts
function getCloudOptions(taskRunnerConfiguration) {
  var _a2, _b2;
  const nxJson = JSON.parse(
    stripJsonComments((0, import_fs15.readFileSync)(`${workspaceRoot5}/nx.json`).toString(), {
      trailingCommas: true
    })
  );
  const result = {};
  const defaultCacheableOperations = [];
  for (const key in nxJson.targetDefaults) {
    if (nxJson.targetDefaults[key].cache) {
      defaultCacheableOperations.push(key);
    }
  }
  if (nxJson.nxCloudAccessToken) {
    result.accessToken ?? (result.accessToken = nxJson.nxCloudAccessToken);
  }
  if (nxJson.nxCloudUrl) {
    result.url ?? (result.url = nxJson.nxCloudUrl);
  }
  if (nxJson.nxCloudEncryptionKey) {
    result.encryptionKey = nxJson.nxCloudEncryptionKey;
  }
  if (nxJson.parallel) {
    result.parallel ?? (result.parallel = nxJson.parallel);
  }
  if (nxJson.cacheDirectory) {
    result.cacheDirectory ?? (result.cacheDirectory = nxJson.cacheDirectory);
  }
  if (defaultCacheableOperations.length) {
    result.cacheableOperations ?? (result.cacheableOperations = defaultCacheableOperations);
  }
  return {
    nxJson,
    nxCloudOptions: {
      ...result,
      ...(_b2 = (_a2 = nxJson.tasksRunnerOptions) == null ? void 0 : _a2[taskRunnerConfiguration]) == null ? void 0 : _b2.options
    }
  };
}
var import_fs15, workspaceRoot5;
var init_get_cloud_options = __esm({
  "src/lib/utilities/get-cloud-options.ts"() {
    "use strict";
    import_fs15 = require("fs");
    init_strip_json_comments();
    ({ workspaceRoot: workspaceRoot5 } = require_nx_imports_light());
  }
});

// src/lib/utilities/task-runner-configurations.ts
function taskRunnerConfigurationIsDefault(taskRunnerConfiguration) {
  return taskRunnerConfiguration === "default" || taskRunnerConfiguration === null || taskRunnerConfiguration === void 0;
}
function taskRunnerConfigurationsMatch(launchConfiguration, executionConfiguration) {
  if (taskRunnerConfigurationIsDefault(launchConfiguration) && taskRunnerConfigurationIsDefault(executionConfiguration)) {
    return true;
  }
  return launchConfiguration === executionConfiguration;
}
function validateTaskRunnerConfigurationsOrExit(launchConfiguration, executionConfiguration) {
  if (!taskRunnerConfigurationsMatch(launchConfiguration, executionConfiguration)) {
    console.error(
      "[Nx Cloud] Task runner configuration must match between agents and main jobs."
    );
    console.error(
      "[Nx Cloud] Agent is using configuration:",
      launchConfiguration
    );
    console.error(
      "[Nx Cloud] Main job is using configuration:",
      executionConfiguration
    );
    console.error(
      "[Nx Cloud] To set runner configurations, use the `--runner` argument, the NX_TASKS_RUNNER env variable, or the NX_RUNNER env variable on your commands."
    );
    process.exit(1);
  }
}
function getTaskRunnerConfigurationFromArgs(args5) {
  for (const arg of args5) {
    if (arg.includes("--runner=")) {
      return arg.slice(9);
    }
  }
  return null;
}
var init_task_runner_configurations = __esm({
  "src/lib/utilities/task-runner-configurations.ts"() {
    "use strict";
  }
});

// src/lib/core/commands/record-output.ts
var record_output_exports = {};
__export(record_output_exports, {
  runCommandAndStoreInCloud: () => runCommandAndStoreInCloud
});
async function runCommandAndStoreInCloud() {
  var _a2, _b2, _c2;
  const taskRunnerConfiguration = getTaskRunnerConfigurationFromArgs(process.argv) ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? "default";
  const { nxCloudOptions } = getCloudOptions(taskRunnerConfiguration);
  const axios3 = createApiAxiosInstance(nxCloudOptions);
  const dteApi = new DistributedExecutionApi(nxCloudOptions);
  const outputObfuscator = new OutputObfuscator(
    nxCloudOptions.maskedProperties
  );
  const branch = getBranch();
  const runGroup = getRunGroup();
  const ciExecutionId = getCIExecutionId();
  const ciExecutionEnv = getCIExecutionEnv();
  const userCommandAndArgs = parseCommandAndFlags(process.argv);
  const [userCommand, ...userArgs] = userCommandAndArgs;
  const startTime = (/* @__PURE__ */ new Date()).toISOString();
  const { statusCode, terminalOutput } = await spawnUserCommandAndCaptureOutput(
    userCommand,
    userArgs
  );
  const endTime = (/* @__PURE__ */ new Date()).toISOString();
  const encryptionKey = ENCRYPTION_KEY || nxCloudOptions.encryptionKey;
  const encryption = new E2EEncryption(encryptionKey);
  const errorApi = new ErrorReporterApi(nxCloudOptions);
  const fileStorage = new FileStorage(
    encryption,
    errorApi,
    nxCloudOptions,
    "record-output"
  );
  const recordOutputRunParams = {
    statusCode,
    terminalOutput,
    userCommandAndArgsString: userCommandAndArgs.join(" "),
    startTime,
    endTime,
    branch,
    runGroup,
    ciExecutionId,
    ciExecutionEnv,
    hash: `record-output-${import_uuid2.default.v4()}`,
    artifactId: null,
    uploadedToStorage: false,
    terminalOutputUploadedToFileStorage: false
  };
  const uploadLocation = await startRecordOutputRun(
    axios3,
    recordOutputRunParams
  );
  recordOutputRunParams.artifactId = (_a2 = uploadLocation[recordOutputRunParams.hash]) == null ? void 0 : _a2.artifactId;
  const terminalOutputUrl = (_c2 = (_b2 = uploadLocation[recordOutputRunParams.hash]) == null ? void 0 : _b2.terminalOutputUrls) == null ? void 0 : _c2.put;
  if (terminalOutputUrl) {
    try {
      await storeTerminalOutputToFileStorage(
        fileStorage,
        recordOutputRunParams.hash,
        terminalOutput,
        terminalOutputUrl
      );
      recordOutputRunParams.uploadedToStorage = true;
      recordOutputRunParams.terminalOutputUploadedToFileStorage = true;
    } catch (e) {
      output23.error({
        title: `Failed to store terminal output to file storage.`,
        bodyLines: [e.message]
      });
    }
  }
  await endRecordOutputRun(
    axios3,
    outputObfuscator,
    nxCloudOptions,
    recordOutputRunParams,
    dteApi
  );
  process.exit(statusCode);
}
function parseCommandAndFlags(args5) {
  let commandStartIndex = args5.findIndex((arg) => arg === "record") + 1;
  let userCommandAndArgs;
  if (commandStartIndex < process.argv.length) {
    const sliceOffset = process.argv[commandStartIndex] === "--" ? 1 : 0;
    userCommandAndArgs = process.argv.slice(commandStartIndex + sliceOffset);
  } else {
    console.log(
      "Invalid command. Use `nx-cloud record [my command] [my arg1] [my arg...]`"
    );
    process.exit(1);
  }
  return userCommandAndArgs;
}
function spawnUserCommandAndCaptureOutput(command, args5) {
  return new Promise((res, rej) => {
    try {
      const userCommandProcess = cp.spawn(command, args5, {
        stdio: ["inherit", "pipe", "pipe", "ipc"]
      });
      const outLines = [];
      userCommandProcess.stdout.on("data", (chunk) => {
        process.stdout.write(chunk);
        outLines.push(chunk.toString());
      });
      userCommandProcess.stderr.on("data", (chunk) => {
        process.stderr.write(chunk);
        outLines.push(chunk.toString());
      });
      userCommandProcess.on("exit", (exitCode, exitSignal) => {
        const statusCode = exitCode ?? signalToCode(exitSignal || "");
        const joinedOutput = outLines.join("");
        res({
          statusCode,
          terminalOutput: joinedOutput
        });
      });
    } catch (e) {
      rej(e);
    }
  });
}
function createTaskDefinitionFromUserCommand(outputObfuscator, params) {
  const sanitizedOutput = outputObfuscator.obfuscate(params.terminalOutput);
  const truncatedOutput = sanitizedOutput.length > MAX_CHARACTERS_OUTPUT_CAPTURE ? `TRUNCATED

${sanitizedOutput.slice(
    sanitizedOutput.length - MAX_CHARACTERS_OUTPUT_CAPTURE
  )}` : sanitizedOutput;
  return {
    taskId: "nx-cloud-tasks-runner:record-command",
    target: "record-command",
    projectName: "nx-cloud-tasks-runner",
    hash: params.hash,
    startTime: params.startTime,
    endTime: params.endTime,
    hashDetails: {},
    params: params.userCommandAndArgsString,
    cacheStatus: "n/a",
    status: params.statusCode,
    artifactId: params.artifactId,
    uploadedToStorage: params.uploadedToStorage,
    terminalOutput: truncatedOutput,
    terminalOutputUploadedToFileStorage: params.terminalOutputUploadedToFileStorage
  };
}
async function startRecordOutputRun(axios3, params) {
  const startRunReq = {
    branch: params.branch,
    runGroup: params.runGroup,
    ciExecutionId: params.ciExecutionId,
    ciExecutionEnv: params.ciExecutionEnv,
    vcsContext: getVcsContext(),
    machineInfo: getMachineInfo(),
    hashes: [params.hash],
    distributedExecutionId: null
  };
  try {
    const startRunResp = await axiosMultipleTries(
      () => axios3.post("/nx-cloud/v2/runs/start", startRunReq)
    );
    return startRunResp.data.artifacts;
  } catch (e) {
    output23.error({
      title: e.message
    });
    return {};
  }
}
async function storeTerminalOutputToFileStorage(fileStorage, hash, terminalOutput, terminalOutputUrl) {
  const terminalOutputPath = `${cacheDirectory5}/${hash}`;
  (0, import_fs_extra.ensureDirSync)(cacheDirectory5);
  (0, import_fs_extra.writeFileSync)(`${terminalOutputPath}`, terminalOutput);
  if (VERBOSE_LOGGING) {
    output23.note({
      title: `Saving terminal output to ${terminalOutputPath}`
    });
  }
  const cacheFile = {
    remoteUrl: terminalOutputUrl,
    fileType: "terminalOutput"
  };
  if (VERBOSE_LOGGING) {
    output23.note({
      title: `Uploading terminal output to file storage`
    });
  }
  await fileStorage.store(hash, cacheDirectory5, cacheFile, [hash]);
  if (VERBOSE_LOGGING) {
    output23.note({
      title: `Successfully uploaded terminal output to file storage`
    });
  }
}
async function endRecordOutputRun(axios3, obfuscator, taskRunnerOptions, params, dteApi) {
  const commandWithPrefix = `nx-cloud record -- ${params.userCommandAndArgsString}`;
  const endRunReq = {
    meta: {
      nxCloudVersion: "0.0.0"
    },
    tasks: [createTaskDefinitionFromUserCommand(obfuscator, params)],
    run: {
      command: commandWithPrefix,
      startTime: params.startTime,
      endTime: params.endTime,
      branch: params.branch,
      runGroup: params.runGroup,
      // only set sha if branch is set because we invoke a separate process,
      // which adds a few millis
      sha: params.branch ? extractGitSha() : void 0
    },
    branch: params.branch,
    runGroup: params.runGroup,
    ciExecutionId: params.ciExecutionId,
    ciExecutionEnv: params.ciExecutionEnv,
    machineInfo: getMachineInfo(),
    vcsContext: getVcsContext()
  };
  const uncompressedBuffer = Buffer.from(JSON.stringify(endRunReq));
  const compressedBuffer = await (0, import_util4.promisify)(import_zlib4.gzip)(uncompressedBuffer);
  const endRunResp = await axiosMultipleTries(
    () => axios3.post("/nx-cloud/runs/end", compressedBuffer, {
      // @ts-ignore
      headers: {
        ...axios3.defaults.headers,
        "Content-Encoding": "gzip",
        "Content-Type": "application/octet-stream"
      }
    })
  );
  if (process.env.NX_CLOUD_SILENT_RECORD !== "true") {
    printRecordOutputRunEndMessage(endRunResp.data.runUrl);
  }
  if (params.statusCode !== 0 && (params.ciExecutionId || params.runGroup)) {
    await dteApi.completeRunGroupWithError(
      params.branch,
      params.runGroup,
      params.ciExecutionId,
      params.ciExecutionEnv,
      null
    );
  }
}
function printRecordOutputRunEndMessage(runUrl) {
  output23.addVerticalSeparator();
  output23.note({ title: "Nx Cloud: Successfully recorded command output" });
  printMessage(`You can view or share your output by visiting ${runUrl}`);
}
function signalToCode(signal) {
  if (signal === "SIGHUP")
    return 128 + 1;
  if (signal === "SIGINT")
    return 128 + 2;
  if (signal === "SIGTERM")
    return 128 + 15;
  return 128;
}
var cp, import_fs_extra, import_util4, import_uuid2, import_zlib4, cacheDirectory5, output23, MAX_CHARACTERS_OUTPUT_CAPTURE;
var init_record_output = __esm({
  "src/lib/core/commands/record-output.ts"() {
    "use strict";
    cp = __toESM(require("child_process"));
    import_fs_extra = __toESM(require_lib());
    import_util4 = require("util");
    import_uuid2 = __toESM(require_uuid());
    import_zlib4 = require("zlib");
    init_axios();
    init_environment();
    init_get_cloud_options();
    init_get_vcs_context();
    init_print_message();
    init_task_runner_configurations();
    init_error_reporter_api();
    init_e2e_encryption();
    init_file_storage();
    init_distributed_execution_api();
    init_output_obfuscator();
    ({ cacheDirectory: cacheDirectory5 } = require_nx_imports());
    ({ output: output23 } = require_nx_imports_light());
    MAX_CHARACTERS_OUTPUT_CAPTURE = 2e5;
  }
});

// src/lib/core/runners/distributed-agent/agent-utils.ts
function getAgentName() {
  if (process.env.NX_AGENT_NAME !== void 0) {
    return process.env.NX_AGENT_NAME;
  } else if (process.env.CIRCLECI !== void 0 && process.env.CIRCLE_STAGE) {
    return process.env.CIRCLE_STAGE;
  } else if (process.env.CIRCLECI !== void 0 && process.env.CIRCLE_JOB) {
    return process.env.CIRCLE_JOB;
  } else {
    return `Agent ${Math.floor(Math.random() * 1e5)}`;
  }
}
function createAgentLockfileAndSetUpListeners(api, options, agentName) {
  const lockFileDirectory = `${cacheDirectory6}/lockfiles`;
  const lockFilePath = `${lockFileDirectory}/${agentName}.lock`;
  if (!(0, import_fs16.existsSync)(lockFileDirectory)) {
    (0, import_fs16.mkdirSync)(lockFileDirectory, { recursive: true });
  }
  const lockFiles = (0, import_fs16.readdirSync)(lockFileDirectory);
  if (lockFiles.length) {
    if (lockFiles.includes(`${agentName}.lock`)) {
      output24.error({
        title: "Duplicate Agent ID Detected",
        bodyLines: [
          "We have detected another agent with this ID running in this workspace. This should not happen.",
          "",
          'End all currently running agents, run "npx nx-cloud clean-up-agents", and try again.'
        ]
      });
      process.exit(1);
    }
    output24.warn({
      title: "Other Nx Cloud Agents Detected",
      bodyLines: [
        "We have detected other agents running in this workspace. This can cause unexpected behavior.",
        "",
        "This can also be a false positive caused by agents that did not shut down correctly.",
        'If you believe this is the case, run "npx nx-cloud clean-up-agents".'
      ]
    });
  }
  (0, import_fs16.writeFileSync)(lockFilePath, "");
  process.on("exit", (code) => {
    cleanupAgentLockfile(lockFilePath, code);
  });
  process.on("SIGTERM", async () => {
    await api.completeRunGroupWithError("Agent was terminated via SIGTERM");
    cleanupAgentLockfile(lockFilePath, 1);
  });
  process.on("SIGINT", async () => {
    await api.completeRunGroupWithError("Agent was terminated via SIGINT");
    cleanupAgentLockfile(lockFilePath, 1);
  });
}
function cleanupAgentLockfile(lockFilePath, code) {
  if ((0, import_fs16.existsSync)(lockFilePath)) {
    (0, import_fs16.unlinkSync)(lockFilePath);
    process.exit(code);
  }
}
var import_fs16, output24, cacheDirectory6;
var init_agent_utils = __esm({
  "src/lib/core/runners/distributed-agent/agent-utils.ts"() {
    "use strict";
    import_fs16 = require("fs");
    ({
      output: output24,
      cacheDirectory: cacheDirectory6
    } = require_nx_imports_light());
  }
});

// src/lib/core/runners/distributed-agent/distributed-agent.api.ts
var output25, DistributedAgentApi;
var init_distributed_agent_api = __esm({
  "src/lib/core/runners/distributed-agent/distributed-agent.api.ts"() {
    "use strict";
    init_axios();
    init_environment();
    ({ output: output25 } = require_nx_imports_light());
    DistributedAgentApi = class {
      constructor(options, branch, runGroup, ciExecutionId, ciExecutionEnv, agentName) {
        this.branch = branch;
        this.runGroup = runGroup;
        this.ciExecutionId = ciExecutionId;
        this.ciExecutionEnv = ciExecutionEnv;
        this.agentName = agentName;
        this.apiAxiosInstance = createApiAxiosInstance(options, 6e4);
      }
      async tasks(executionId, statusCode, completedTasks, targets) {
        try {
          const res = await axiosMultipleTries(
            () => this.apiAxiosInstance.post("/nx-cloud/executions/tasks", {
              runGroup: this.runGroup,
              ciExecutionId: this.ciExecutionId,
              ciExecutionEnv: this.ciExecutionEnv,
              agentName: this.agentName,
              executionId,
              statusCode,
              completedTasks,
              targets,
              clientInstanceId: process.env.NX_CLOUD_CLIENT_INSTANCE_ID
            })
          );
          return res.data;
        } catch (e) {
          throw e;
        }
      }
      async tasksV2(executionId, statusCode, completedTasks, forceDownloadAllArtifacts, targets) {
        const res = await axiosMultipleTries(
          () => this.apiAxiosInstance.post("/nx-cloud/v2/executions/tasks", {
            runGroup: this.runGroup,
            ciExecutionId: this.ciExecutionId,
            ciExecutionEnv: this.ciExecutionEnv,
            agentName: this.agentName,
            executionId,
            statusCode,
            completedTasks,
            targets,
            forceDownloadAllArtifacts,
            clientInstanceId: process.env.NX_CLOUD_CLIENT_INSTANCE_ID
          })
        );
        return res.data;
      }
      async completeRunGroupWithError(error) {
        if (VERBOSE_LOGGING) {
          output25.note({
            title: "Completing with an error",
            bodyLines: [
              `ciExecutionId: ${this.ciExecutionId}`,
              `ciExecutionEnv: ${this.ciExecutionEnv}`,
              `runGroup: ${this.runGroup}`,
              `error: ${error}`
            ]
          });
        }
        try {
          const resp = await axiosMultipleTries(
            () => this.apiAxiosInstance.post("/nx-cloud/executions/complete-run-group", {
              branch: this.branch,
              runGroup: this.runGroup,
              ciExecutionId: this.ciExecutionId,
              ciExecutionEnv: this.ciExecutionEnv,
              agentName: this.agentName,
              criticalErrorMessage: error
            })
          );
          if (VERBOSE_LOGGING) {
            output25.note({
              title: "Completed run group with an error"
            });
          }
        } catch (e) {
          console.error(e);
        }
      }
    };
  }
});

// node_modules/yargs-parser/build/index.cjs
var require_build = __commonJS({
  "node_modules/yargs-parser/build/index.cjs"(exports2, module2) {
    "use strict";
    var util = require("util");
    var path5 = require("path");
    var fs = require("fs");
    function camelCase2(str) {
      const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
      if (!isCamelCase) {
        str = str.toLowerCase();
      }
      if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
        return str;
      } else {
        let camelcase = "";
        let nextChrUpper = false;
        const leadingHyphens = str.match(/^-+/);
        for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
          let chr = str.charAt(i);
          if (nextChrUpper) {
            nextChrUpper = false;
            chr = chr.toUpperCase();
          }
          if (i !== 0 && (chr === "-" || chr === "_")) {
            nextChrUpper = true;
          } else if (chr !== "-" && chr !== "_") {
            camelcase += chr;
          }
        }
        return camelcase;
      }
    }
    function decamelize2(str, joinString) {
      const lowercase = str.toLowerCase();
      joinString = joinString || "-";
      let notCamelcase = "";
      for (let i = 0; i < str.length; i++) {
        const chrLower = lowercase.charAt(i);
        const chrString = str.charAt(i);
        if (chrLower !== chrString && i > 0) {
          notCamelcase += `${joinString}${lowercase.charAt(i)}`;
        } else {
          notCamelcase += chrString;
        }
      }
      return notCamelcase;
    }
    function looksLikeNumber2(x) {
      if (x === null || x === void 0)
        return false;
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      if (/^0[^.]/.test(x))
        return false;
      return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
    function tokenizeArgString2(argString) {
      if (Array.isArray(argString)) {
        return argString.map((e) => typeof e !== "string" ? e + "" : e);
      }
      argString = argString.trim();
      let i = 0;
      let prevC = null;
      let c = null;
      let opening = null;
      const args5 = [];
      for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === " " && !opening) {
          if (!(prevC === " ")) {
            i++;
          }
          continue;
        }
        if (c === opening) {
          opening = null;
        } else if ((c === "'" || c === '"') && !opening) {
          opening = c;
        }
        if (!args5[i])
          args5[i] = "";
        args5[i] += c;
      }
      return args5;
    }
    var DefaultValuesForTypeKey2;
    (function(DefaultValuesForTypeKey3) {
      DefaultValuesForTypeKey3["BOOLEAN"] = "boolean";
      DefaultValuesForTypeKey3["STRING"] = "string";
      DefaultValuesForTypeKey3["NUMBER"] = "number";
      DefaultValuesForTypeKey3["ARRAY"] = "array";
    })(DefaultValuesForTypeKey2 || (DefaultValuesForTypeKey2 = {}));
    var mixin2;
    var YargsParser2 = class {
      constructor(_mixin) {
        mixin2 = _mixin;
      }
      parse(argsInput, options) {
        const opts = Object.assign({
          alias: void 0,
          array: void 0,
          boolean: void 0,
          config: void 0,
          configObjects: void 0,
          configuration: void 0,
          coerce: void 0,
          count: void 0,
          default: void 0,
          envPrefix: void 0,
          narg: void 0,
          normalize: void 0,
          string: void 0,
          number: void 0,
          __: void 0,
          key: void 0
        }, options);
        const args5 = tokenizeArgString2(argsInput);
        const inputIsString = typeof argsInput === "string";
        const aliases = combineAliases2(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
        const configuration = Object.assign({
          "boolean-negation": true,
          "camel-case-expansion": true,
          "combine-arrays": false,
          "dot-notation": true,
          "duplicate-arguments-array": true,
          "flatten-duplicate-arrays": true,
          "greedy-arrays": true,
          "halt-at-non-option": false,
          "nargs-eats-options": false,
          "negation-prefix": "no-",
          "parse-numbers": true,
          "parse-positional-numbers": true,
          "populate--": false,
          "set-placeholder-key": false,
          "short-option-groups": true,
          "strip-aliased": false,
          "strip-dashed": false,
          "unknown-options-as-args": false
        }, opts.configuration);
        const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration["populate--"];
        const notFlagsArgv = notFlagsOption ? "--" : "_";
        const newAliases = /* @__PURE__ */ Object.create(null);
        const defaulted = /* @__PURE__ */ Object.create(null);
        const __ = opts.__ || mixin2.format;
        const flags = {
          aliases: /* @__PURE__ */ Object.create(null),
          arrays: /* @__PURE__ */ Object.create(null),
          bools: /* @__PURE__ */ Object.create(null),
          strings: /* @__PURE__ */ Object.create(null),
          numbers: /* @__PURE__ */ Object.create(null),
          counts: /* @__PURE__ */ Object.create(null),
          normalize: /* @__PURE__ */ Object.create(null),
          configs: /* @__PURE__ */ Object.create(null),
          nargs: /* @__PURE__ */ Object.create(null),
          coercions: /* @__PURE__ */ Object.create(null),
          keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
          const key = typeof opt === "object" ? opt.key : opt;
          const assignment = Object.keys(opt).map(function(key2) {
            const arrayFlagKeys = {
              boolean: "bools",
              string: "strings",
              number: "numbers"
            };
            return arrayFlagKeys[key2];
          }).filter(Boolean).pop();
          if (assignment) {
            flags[assignment][key] = true;
          }
          flags.arrays[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
          flags.bools[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
          flags.strings[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
          flags.numbers[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
          flags.counts[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
          flags.normalize[key] = true;
          flags.keys.push(key);
        });
        if (typeof opts.narg === "object") {
          Object.entries(opts.narg).forEach(([key, value2]) => {
            if (typeof value2 === "number") {
              flags.nargs[key] = value2;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.coerce === "object") {
          Object.entries(opts.coerce).forEach(([key, value2]) => {
            if (typeof value2 === "function") {
              flags.coercions[key] = value2;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.config !== "undefined") {
          if (Array.isArray(opts.config) || typeof opts.config === "string") {
            [].concat(opts.config).filter(Boolean).forEach(function(key) {
              flags.configs[key] = true;
            });
          } else if (typeof opts.config === "object") {
            Object.entries(opts.config).forEach(([key, value2]) => {
              if (typeof value2 === "boolean" || typeof value2 === "function") {
                flags.configs[key] = value2;
              }
            });
          }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
          (flags.aliases[key] || []).forEach(function(alias) {
            defaults[alias] = defaults[key];
          });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv2 = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
        const argvReturn = {};
        for (let i = 0; i < args5.length; i++) {
          const arg = args5[i];
          const truncatedArg = arg.replace(/^-{3,}/, "---");
          let broken;
          let key;
          let letters;
          let m;
          let next;
          let value2;
          if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
            pushPositional(arg);
          } else if (truncatedArg.match(/^---+(=|$)/)) {
            pushPositional(arg);
            continue;
          } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
            m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              if (checkAllAliases(m[1], flags.arrays)) {
                i = eatArray(i, m[1], args5, m[2]);
              } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                i = eatNargs(i, m[1], args5, m[2]);
              } else {
                setArg(m[1], m[2], true);
              }
            }
          } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
            m = arg.match(negatedBoolean);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
            }
          } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
            m = arg.match(/^--?(.+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args5);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args5);
              } else {
                next = args5[i + 1];
                if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-.\..+=/)) {
            m = arg.match(/^-([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              setArg(m[1], m[2]);
            }
          } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
            next = args5[i + 1];
            m = arg.match(/^-(.\..+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
            letters = arg.slice(1, -1).split("");
            broken = false;
            for (let j = 0; j < letters.length; j++) {
              next = arg.slice(j + 2);
              if (letters[j + 1] && letters[j + 1] === "=") {
                value2 = arg.slice(j + 3);
                key = letters[j];
                if (checkAllAliases(key, flags.arrays)) {
                  i = eatArray(i, key, args5, value2);
                } else if (checkAllAliases(key, flags.nargs) !== false) {
                  i = eatNargs(i, key, args5, value2);
                } else {
                  setArg(key, value2);
                }
                broken = true;
                break;
              }
              if (next === "-") {
                setArg(letters[j], next);
                continue;
              }
              if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                setArg(letters[j], next);
                broken = true;
                break;
              }
              if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                setArg(letters[j], next);
                broken = true;
                break;
              } else {
                setArg(letters[j], defaultValue(letters[j]));
              }
            }
            key = arg.slice(-1)[0];
            if (!broken && key !== "-") {
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args5);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args5);
              } else {
                next = args5[i + 1];
                if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
            key = arg.slice(1);
            setArg(key, defaultValue(key));
          } else if (arg === "--") {
            notFlags = args5.slice(i + 1);
            break;
          } else if (configuration["halt-at-non-option"]) {
            notFlags = args5.slice(i);
            break;
          } else {
            pushPositional(arg);
          }
        }
        applyEnvVars(argv2, true);
        applyEnvVars(argv2, false);
        setConfig(argv2);
        setConfigObjects();
        applyDefaultsAndAliases(argv2, flags.aliases, defaults, true);
        applyCoercions(argv2);
        if (configuration["set-placeholder-key"])
          setPlaceholderKeys(argv2);
        Object.keys(flags.counts).forEach(function(key) {
          if (!hasKey(argv2, key.split(".")))
            setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
          argv2[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
          argv2[notFlagsArgv].push(key);
        });
        if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
          Object.keys(argv2).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
            delete argv2[key];
          });
        }
        if (configuration["strip-aliased"]) {
          [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
            if (configuration["camel-case-expansion"] && alias.includes("-")) {
              delete argv2[alias.split(".").map((prop) => camelCase2(prop)).join(".")];
            }
            delete argv2[alias];
          });
        }
        function pushPositional(arg) {
          const maybeCoercedNumber = maybeCoerceNumber("_", arg);
          if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
            argv2._.push(maybeCoercedNumber);
          }
        }
        function eatNargs(i, key, args6, argAfterEqualSign) {
          let ii;
          let toEat = checkAllAliases(key, flags.nargs);
          toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
          if (toEat === 0) {
            if (!isUndefined(argAfterEqualSign)) {
              error = Error(__("Argument unexpected for: %s", key));
            }
            setArg(key, defaultValue(key));
            return i;
          }
          let available = isUndefined(argAfterEqualSign) ? 0 : 1;
          if (configuration["nargs-eats-options"]) {
            if (args6.length - (i + 1) + available < toEat) {
              error = Error(__("Not enough arguments following: %s", key));
            }
            available = toEat;
          } else {
            for (ii = i + 1; ii < args6.length; ii++) {
              if (!args6[ii].match(/^-[^0-9]/) || args6[ii].match(negative) || isUnknownOptionAsArg(args6[ii]))
                available++;
              else
                break;
            }
            if (available < toEat)
              error = Error(__("Not enough arguments following: %s", key));
          }
          let consumed = Math.min(available, toEat);
          if (!isUndefined(argAfterEqualSign) && consumed > 0) {
            setArg(key, argAfterEqualSign);
            consumed--;
          }
          for (ii = i + 1; ii < consumed + i + 1; ii++) {
            setArg(key, args6[ii]);
          }
          return i + consumed;
        }
        function eatArray(i, key, args6, argAfterEqualSign) {
          let argsToSet = [];
          let next = argAfterEqualSign || args6[i + 1];
          const nargsCount = checkAllAliases(key, flags.nargs);
          if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
            argsToSet.push(true);
          } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
            if (defaults[key] !== void 0) {
              const defVal = defaults[key];
              argsToSet = Array.isArray(defVal) ? defVal : [defVal];
            }
          } else {
            if (!isUndefined(argAfterEqualSign)) {
              argsToSet.push(processValue(key, argAfterEqualSign, true));
            }
            for (let ii = i + 1; ii < args6.length; ii++) {
              if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
                break;
              next = args6[ii];
              if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                break;
              i = ii;
              argsToSet.push(processValue(key, next, inputIsString));
            }
          }
          if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          setArg(key, argsToSet);
          return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
          if (/-/.test(key) && configuration["camel-case-expansion"]) {
            const alias = key.split(".").map(function(prop) {
              return camelCase2(prop);
            }).join(".");
            addNewAlias(key, alias);
          }
          const value2 = processValue(key, val, shouldStripQuotes);
          const splitKey = key.split(".");
          setKey(argv2, splitKey, value2);
          if (flags.aliases[key]) {
            flags.aliases[key].forEach(function(x) {
              const keyProperties = x.split(".");
              setKey(argv2, keyProperties, value2);
            });
          }
          if (splitKey.length > 1 && configuration["dot-notation"]) {
            (flags.aliases[splitKey[0]] || []).forEach(function(x) {
              let keyProperties = x.split(".");
              const a = [].concat(splitKey);
              a.shift();
              keyProperties = keyProperties.concat(a);
              if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
                setKey(argv2, keyProperties, value2);
              }
            });
          }
          if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
            const keys = [key].concat(flags.aliases[key] || []);
            keys.forEach(function(key2) {
              Object.defineProperty(argvReturn, key2, {
                enumerable: true,
                get() {
                  return val;
                },
                set(value3) {
                  val = typeof value3 === "string" ? mixin2.normalize(value3) : value3;
                }
              });
            });
          }
        }
        function addNewAlias(key, alias) {
          if (!(flags.aliases[key] && flags.aliases[key].length)) {
            flags.aliases[key] = [alias];
            newAliases[alias] = true;
          }
          if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
            addNewAlias(alias, key);
          }
        }
        function processValue(key, val, shouldStripQuotes) {
          if (shouldStripQuotes) {
            val = stripQuotes2(val);
          }
          if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
            if (typeof val === "string")
              val = val === "true";
          }
          let value2 = Array.isArray(val) ? val.map(function(v) {
            return maybeCoerceNumber(key, v);
          }) : maybeCoerceNumber(key, val);
          if (checkAllAliases(key, flags.counts) && (isUndefined(value2) || typeof value2 === "boolean")) {
            value2 = increment2();
          }
          if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
            if (Array.isArray(val))
              value2 = val.map((val2) => {
                return mixin2.normalize(val2);
              });
            else
              value2 = mixin2.normalize(val);
          }
          return value2;
        }
        function maybeCoerceNumber(key, value2) {
          if (!configuration["parse-positional-numbers"] && key === "_")
            return value2;
          if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value2)) {
            const shouldCoerceNumber = looksLikeNumber2(value2) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value2}`)));
            if (shouldCoerceNumber || !isUndefined(value2) && checkAllAliases(key, flags.numbers)) {
              value2 = Number(value2);
            }
          }
          return value2;
        }
        function setConfig(argv3) {
          const configLookup = /* @__PURE__ */ Object.create(null);
          applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
          Object.keys(flags.configs).forEach(function(configKey) {
            const configPath = argv3[configKey] || configLookup[configKey];
            if (configPath) {
              try {
                let config = null;
                const resolvedConfigPath = mixin2.resolve(mixin2.cwd(), configPath);
                const resolveConfig = flags.configs[configKey];
                if (typeof resolveConfig === "function") {
                  try {
                    config = resolveConfig(resolvedConfigPath);
                  } catch (e) {
                    config = e;
                  }
                  if (config instanceof Error) {
                    error = config;
                    return;
                  }
                } else {
                  config = mixin2.require(resolvedConfigPath);
                }
                setConfigObject(config);
              } catch (ex) {
                if (ex.name === "PermissionDenied")
                  error = ex;
                else if (argv3[configKey])
                  error = Error(__("Invalid JSON config file: %s", configPath));
              }
            }
          });
        }
        function setConfigObject(config, prev) {
          Object.keys(config).forEach(function(key) {
            const value2 = config[key];
            const fullKey = prev ? prev + "." + key : key;
            if (typeof value2 === "object" && value2 !== null && !Array.isArray(value2) && configuration["dot-notation"]) {
              setConfigObject(value2, fullKey);
            } else {
              if (!hasKey(argv2, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
                setArg(fullKey, value2);
              }
            }
          });
        }
        function setConfigObjects() {
          if (typeof configObjects !== "undefined") {
            configObjects.forEach(function(configObject) {
              setConfigObject(configObject);
            });
          }
        }
        function applyEnvVars(argv3, configOnly) {
          if (typeof envPrefix === "undefined")
            return;
          const prefix = typeof envPrefix === "string" ? envPrefix : "";
          const env4 = mixin2.env();
          Object.keys(env4).forEach(function(envVar) {
            if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
              const keys = envVar.split("__").map(function(key, i) {
                if (i === 0) {
                  key = key.substring(prefix.length);
                }
                return camelCase2(key);
              });
              if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv3, keys)) {
                setArg(keys.join("."), env4[envVar]);
              }
            }
          });
        }
        function applyCoercions(argv3) {
          let coerce;
          const applied = /* @__PURE__ */ new Set();
          Object.keys(argv3).forEach(function(key) {
            if (!applied.has(key)) {
              coerce = checkAllAliases(key, flags.coercions);
              if (typeof coerce === "function") {
                try {
                  const value2 = maybeCoerceNumber(key, coerce(argv3[key]));
                  [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                    applied.add(ali);
                    argv3[ali] = value2;
                  });
                } catch (err) {
                  error = err;
                }
              }
            }
          });
        }
        function setPlaceholderKeys(argv3) {
          flags.keys.forEach((key) => {
            if (~key.indexOf("."))
              return;
            if (typeof argv3[key] === "undefined")
              argv3[key] = void 0;
          });
          return argv3;
        }
        function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
          Object.keys(defaults2).forEach(function(key) {
            if (!hasKey(obj, key.split("."))) {
              setKey(obj, key.split("."), defaults2[key]);
              if (canLog)
                defaulted[key] = true;
              (aliases2[key] || []).forEach(function(x) {
                if (hasKey(obj, x.split(".")))
                  return;
                setKey(obj, x.split("."), defaults2[key]);
              });
            }
          });
        }
        function hasKey(obj, keys) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            o = o[key2] || {};
          });
          const key = keys[keys.length - 1];
          if (typeof o !== "object")
            return false;
          else
            return key in o;
        }
        function setKey(obj, keys, value2) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            key2 = sanitizeKey2(key2);
            if (typeof o === "object" && o[key2] === void 0) {
              o[key2] = {};
            }
            if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
              if (Array.isArray(o[key2])) {
                o[key2].push({});
              } else {
                o[key2] = [o[key2], {}];
              }
              o = o[key2][o[key2].length - 1];
            } else {
              o = o[key2];
            }
          });
          const key = sanitizeKey2(keys[keys.length - 1]);
          const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
          const isValueArray = Array.isArray(value2);
          let duplicate = configuration["duplicate-arguments-array"];
          if (!duplicate && checkAllAliases(key, flags.nargs)) {
            duplicate = true;
            if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
              o[key] = void 0;
            }
          }
          if (value2 === increment2()) {
            o[key] = increment2(o[key]);
          } else if (Array.isArray(o[key])) {
            if (duplicate && isTypeArray && isValueArray) {
              o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value2) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value2]);
            } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
              o[key] = value2;
            } else {
              o[key] = o[key].concat([value2]);
            }
          } else if (o[key] === void 0 && isTypeArray) {
            o[key] = isValueArray ? value2 : [value2];
          } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
            o[key] = [o[key], value2];
          } else {
            o[key] = value2;
          }
        }
        function extendAliases(...args6) {
          args6.forEach(function(obj) {
            Object.keys(obj || {}).forEach(function(key) {
              if (flags.aliases[key])
                return;
              flags.aliases[key] = [].concat(aliases[key] || []);
              flags.aliases[key].concat(key).forEach(function(x) {
                if (/-/.test(x) && configuration["camel-case-expansion"]) {
                  const c = camelCase2(x);
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].concat(key).forEach(function(x) {
                if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                  const c = decamelize2(x, "-");
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].forEach(function(x) {
                flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
                  return x !== y;
                }));
              });
            });
          });
        }
        function checkAllAliases(key, flag) {
          const toCheck = [].concat(flags.aliases[key] || [], key);
          const keys = Object.keys(flag);
          const setAlias = toCheck.find((key2) => keys.includes(key2));
          return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
          const flagsKeys = Object.keys(flags);
          const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
          return toCheck.some(function(flag) {
            return Array.isArray(flag) ? flag.includes(key) : flag[key];
          });
        }
        function hasFlagsMatching(arg, ...patterns) {
          const toCheck = [].concat(...patterns);
          return toCheck.some(function(pattern) {
            const match = arg.match(pattern);
            return match && hasAnyFlag(match[1]);
          });
        }
        function hasAllShortFlags(arg) {
          if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
            return false;
          }
          let hasAllFlags = true;
          let next;
          const letters = arg.slice(1).split("");
          for (let j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (!hasAnyFlag(letters[j])) {
              hasAllFlags = false;
              break;
            }
            if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
              break;
            }
          }
          return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
          return configuration["unknown-options-as-args"] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
          arg = arg.replace(/^-{3,}/, "--");
          if (arg.match(negative)) {
            return false;
          }
          if (hasAllShortFlags(arg)) {
            return false;
          }
          const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
          const normalFlag = /^-+([^=]+?)$/;
          const flagEndingInHyphen = /^-+([^=]+?)-$/;
          const flagEndingInDigits = /^-+([^=]+?\d+)$/;
          const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
          return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
          if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
            return defaults[key];
          } else {
            return defaultForType(guessType(key));
          }
        }
        function defaultForType(type) {
          const def = {
            [DefaultValuesForTypeKey2.BOOLEAN]: true,
            [DefaultValuesForTypeKey2.STRING]: "",
            [DefaultValuesForTypeKey2.NUMBER]: void 0,
            [DefaultValuesForTypeKey2.ARRAY]: []
          };
          return def[type];
        }
        function guessType(key) {
          let type = DefaultValuesForTypeKey2.BOOLEAN;
          if (checkAllAliases(key, flags.strings))
            type = DefaultValuesForTypeKey2.STRING;
          else if (checkAllAliases(key, flags.numbers))
            type = DefaultValuesForTypeKey2.NUMBER;
          else if (checkAllAliases(key, flags.bools))
            type = DefaultValuesForTypeKey2.BOOLEAN;
          else if (checkAllAliases(key, flags.arrays))
            type = DefaultValuesForTypeKey2.ARRAY;
          return type;
        }
        function isUndefined(num) {
          return num === void 0;
        }
        function checkConfiguration() {
          Object.keys(flags.counts).find((key) => {
            if (checkAllAliases(key, flags.arrays)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
              return true;
            } else if (checkAllAliases(key, flags.nargs)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
              return true;
            }
            return false;
          });
        }
        return {
          aliases: Object.assign({}, flags.aliases),
          argv: Object.assign(argvReturn, argv2),
          configuration,
          defaulted: Object.assign({}, defaulted),
          error,
          newAliases: Object.assign({}, newAliases)
        };
      }
    };
    function combineAliases2(aliases) {
      const aliasArrays = [];
      const combined = /* @__PURE__ */ Object.create(null);
      let change = true;
      Object.keys(aliases).forEach(function(key) {
        aliasArrays.push([].concat(aliases[key], key));
      });
      while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
          for (let ii = i + 1; ii < aliasArrays.length; ii++) {
            const intersect = aliasArrays[i].filter(function(v) {
              return aliasArrays[ii].indexOf(v) !== -1;
            });
            if (intersect.length) {
              aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
              aliasArrays.splice(ii, 1);
              change = true;
              break;
            }
          }
        }
      }
      aliasArrays.forEach(function(aliasArray) {
        aliasArray = aliasArray.filter(function(v, i, self2) {
          return self2.indexOf(v) === i;
        });
        const lastAlias = aliasArray.pop();
        if (lastAlias !== void 0 && typeof lastAlias === "string") {
          combined[lastAlias] = aliasArray;
        }
      });
      return combined;
    }
    function increment2(orig) {
      return orig !== void 0 ? orig + 1 : 1;
    }
    function sanitizeKey2(key) {
      if (key === "__proto__")
        return "___proto___";
      return key;
    }
    function stripQuotes2(val) {
      return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
    }
    var _a2;
    var _b2;
    var _c2;
    var minNodeVersion2 = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
    var nodeVersion2 = (_b2 = (_a2 = process === null || process === void 0 ? void 0 : process.versions) === null || _a2 === void 0 ? void 0 : _a2.node) !== null && _b2 !== void 0 ? _b2 : (_c2 = process === null || process === void 0 ? void 0 : process.version) === null || _c2 === void 0 ? void 0 : _c2.slice(1);
    if (nodeVersion2) {
      const major = Number(nodeVersion2.match(/^([^.]+)/)[1]);
      if (major < minNodeVersion2) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion2}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
      }
    }
    var env3 = process ? process.env : {};
    var parser3 = new YargsParser2({
      cwd: process.cwd,
      env: () => {
        return env3;
      },
      format: util.format,
      normalize: path5.normalize,
      resolve: path5.resolve,
      require: (path6) => {
        if (typeof require !== "undefined") {
          return require(path6);
        } else if (path6.match(/\.json$/)) {
          return JSON.parse(fs.readFileSync(path6, "utf8"));
        } else {
          throw Error("only .json config files are supported in ESM");
        }
      }
    });
    var yargsParser4 = function Parser2(args5, opts) {
      const result = parser3.parse(args5.slice(), opts);
      return result.argv;
    };
    yargsParser4.detailed = function(args5, opts) {
      return parser3.parse(args5.slice(), opts);
    };
    yargsParser4.camelCase = camelCase2;
    yargsParser4.decamelize = decamelize2;
    yargsParser4.looksLikeNumber = looksLikeNumber2;
    module2.exports = yargsParser4;
  }
});

// src/lib/core/runners/distributed-agent/invoke-tasks-using-nx-imperative-api.ts
async function invokeTasksUsingNxImperativeApi(options, cacheDirectory11, launchTaskRunnerConfiguration) {
  const tasksRunner3 = await initTasksRunner(options);
  return async (executionId, tasks, parallel, executionTaskRunnerConfiguration) => {
    validateTaskRunnerConfigurationsOrExit(
      launchTaskRunnerConfiguration,
      executionTaskRunnerConfiguration
    );
    process.env.NX_CACHE_FAILURES = "true";
    process.env.NX_CLOUD_DISTRIBUTED_EXECUTION_ID = executionId;
    process.env.NX_STREAM_OUTPUT = "true";
    process.env.NX_PREFIX_OUTPUT = "true";
    const r = await tasksRunner3.invoke({ tasks, parallel });
    if (process.env.NX_CLOUD_CRITICAL_ERROR === "true") {
      throw new Error("Critical error while executing Nx tasks.");
    }
    const completedTasks = Object.values(r.taskGraph.tasks);
    return {
      completedTasks: completedTasks.map((t) => ({
        taskId: t.id,
        hash: t.hash,
        code: getStatusCodeForHash(cacheDirectory11, t.hash)
      })),
      completedStatusCode: r.status
    };
  };
}
function getStatusCodeForHash(cacheDirectory11, hash) {
  try {
    const codeAsString = (0, import_fs17.readFileSync)((0, import_path10.join)(cacheDirectory11, hash, "code"), {
      encoding: "utf-8"
    });
    return Number(codeAsString);
  } catch (e) {
    console.error(
      `Unable to read status code for hash ${hash} from cache directory ${cacheDirectory11}`
    );
    throw e;
  }
}
var import_fs17, import_path10, initTasksRunner, parser;
var init_invoke_tasks_using_nx_imperative_api = __esm({
  "src/lib/core/runners/distributed-agent/invoke-tasks-using-nx-imperative-api.ts"() {
    "use strict";
    import_fs17 = require("fs");
    import_path10 = require("path");
    init_task_runner_configurations();
    ({ initTasksRunner } = require_nx_imports());
    parser = require_build();
  }
});

// src/lib/core/runners/distributed-agent/invoke-tasks-using-run-many.ts
async function invokeTasksUsingRunMany(launchTaskRunnerConfiguration) {
  const readCompleted = completedTasksReader();
  return async function invokeTasksUsingRunMany2(executionId, tasksToExecute, parallel, executionTaskRunnerConfiguration) {
    validateTaskRunnerConfigurationsOrExit(
      launchTaskRunnerConfiguration,
      executionTaskRunnerConfiguration
    );
    let completedStatusCode = 0;
    const completedTasks = [];
    for (const g of groupByTarget(tasksToExecute)) {
      const config = g.configuration ? `--configuration=${g.configuration}` : ``;
      const parallelStr = parallel > 1 ? ` --parallel --max-parallel=${parallel}` : ``;
      const createTaskRunnerArgument = (taskRunnerConfiguration) => {
        if (taskRunnerConfiguration === null || taskRunnerConfiguration === void 0)
          return "";
        return `--runner=${taskRunnerConfiguration}`;
      };
      const command = `npx nx run-many --target=${g.target} ${config} --projects=${g.projects.join(",")} ${g.params}${parallelStr} ${createTaskRunnerArgument(
        executionTaskRunnerConfiguration
      )}`;
      if (VERBOSE_LOGGING) {
        output26.note({
          title: `Executing: '${command}'`
        });
      }
      try {
        (0, import_child_process5.execSync)(command, {
          stdio: ["ignore", "inherit", "inherit"],
          env: {
            ...process.env,
            NX_CACHE_FAILURES: "true",
            NX_CLOUD_DISTRIBUTED_EXECUTION_ID: executionId,
            NX_STREAM_OUTPUT: "true",
            NX_PREFIX_OUTPUT: "true",
            NX_CLOUD_INVOKED_WITH_RUN_MANY: "true"
          }
        });
        completedTasks.push(...readCompleted(executionId));
      } catch (e) {
        if (e.status === DISTRIBUTED_TASK_EXECUTION_INTERNAL_ERROR_STATUS_CODE) {
          throw e;
        } else {
          completedStatusCode = 1;
          completedTasks.push(...readCompleted(executionId));
        }
      }
    }
    return { completedStatusCode, completedTasks };
  };
}
function groupByTarget(tasks) {
  const res = [];
  tasks.forEach((t) => {
    const r = res.find(
      (rr) => rr.target === t.target.target && rr.configuration === t.target.configuration
    );
    if (r) {
      r.projects.push(t.target.project);
    } else {
      res.push({
        target: t.target.target,
        projects: [t.target.project],
        params: t.overrides["__overrides_unparsed__"] ?? [].join(" "),
        configuration: t.target.configuration
      });
    }
  });
  return res;
}
function completedTasksReader() {
  return (distributedExecutionId) => {
    const errorMessage = `Command execution failed (distributed task execution: ${distributedExecutionId}). Tasks hashes haven't been recorded.`;
    let completedTasks;
    try {
      const taskHashesFile = `${cacheDirectory7}/tasks-hashes-${distributedExecutionId}`;
      completedTasks = JSON.parse(
        (0, import_fs18.readFileSync)(taskHashesFile).toString()
      );
      (0, import_fs18.unlinkSync)(taskHashesFile);
    } catch (e) {
      throw new Error(errorMessage);
    }
    if (completedTasks.length == 0) {
      throw new Error(errorMessage);
    }
    return completedTasks;
  };
}
var import_child_process5, import_fs18, output26, cacheDirectory7;
var init_invoke_tasks_using_run_many = __esm({
  "src/lib/core/runners/distributed-agent/invoke-tasks-using-run-many.ts"() {
    "use strict";
    import_child_process5 = require("child_process");
    import_fs18 = require("fs");
    init_environment();
    init_task_runner_configurations();
    ({ output: output26 } = require_nx_imports_light());
    ({ cacheDirectory: cacheDirectory7 } = require_nx_imports());
  }
});

// node_modules/yargs-parser/build/lib/string-utils.js
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
      let chr = str.charAt(i);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i = 0; i < str.length; i++) {
    const chrLower = lowercase.charAt(i);
    const chrString = str.charAt(i);
    if (chrLower !== chrString && i > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x) {
  if (x === null || x === void 0)
    return false;
  if (typeof x === "number")
    return true;
  if (/^0x[0-9a-f]+$/i.test(x))
    return true;
  if (/^0[^.]/.test(x))
    return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}
var init_string_utils = __esm({
  "node_modules/yargs-parser/build/lib/string-utils.js"() {
    "use strict";
  }
});

// node_modules/yargs-parser/build/lib/tokenize-arg-string.js
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e) => typeof e !== "string" ? e + "" : e);
  }
  argString = argString.trim();
  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args5 = [];
  for (let ii = 0; ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);
    if (c === " " && !opening) {
      if (!(prevC === " ")) {
        i++;
      }
      continue;
    }
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }
    if (!args5[i])
      args5[i] = "";
    args5[i] += c;
  }
  return args5;
}
var init_tokenize_arg_string = __esm({
  "node_modules/yargs-parser/build/lib/tokenize-arg-string.js"() {
    "use strict";
  }
});

// node_modules/yargs-parser/build/lib/yargs-parser-types.js
var DefaultValuesForTypeKey;
var init_yargs_parser_types = __esm({
  "node_modules/yargs-parser/build/lib/yargs-parser-types.js"() {
    "use strict";
    (function(DefaultValuesForTypeKey2) {
      DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
      DefaultValuesForTypeKey2["STRING"] = "string";
      DefaultValuesForTypeKey2["NUMBER"] = "number";
      DefaultValuesForTypeKey2["ARRAY"] = "array";
    })(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
  }
});

// node_modules/yargs-parser/build/lib/yargs-parser.js
function combineAliases(aliases) {
  const aliasArrays = [];
  const combined = /* @__PURE__ */ Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i = 0; i < aliasArrays.length; i++) {
      for (let ii = i + 1; ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function(v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v, i, self2) {
      return self2.indexOf(v) === i;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== void 0 && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
}
function increment(orig) {
  return orig !== void 0 ? orig + 1 : 1;
}
function sanitizeKey(key) {
  if (key === "__proto__")
    return "___proto___";
  return key;
}
function stripQuotes(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
}
var mixin, YargsParser;
var init_yargs_parser = __esm({
  "node_modules/yargs-parser/build/lib/yargs-parser.js"() {
    "use strict";
    init_tokenize_arg_string();
    init_yargs_parser_types();
    init_string_utils();
    YargsParser = class {
      constructor(_mixin) {
        mixin = _mixin;
      }
      parse(argsInput, options) {
        const opts = Object.assign({
          alias: void 0,
          array: void 0,
          boolean: void 0,
          config: void 0,
          configObjects: void 0,
          configuration: void 0,
          coerce: void 0,
          count: void 0,
          default: void 0,
          envPrefix: void 0,
          narg: void 0,
          normalize: void 0,
          string: void 0,
          number: void 0,
          __: void 0,
          key: void 0
        }, options);
        const args5 = tokenizeArgString(argsInput);
        const inputIsString = typeof argsInput === "string";
        const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
        const configuration = Object.assign({
          "boolean-negation": true,
          "camel-case-expansion": true,
          "combine-arrays": false,
          "dot-notation": true,
          "duplicate-arguments-array": true,
          "flatten-duplicate-arrays": true,
          "greedy-arrays": true,
          "halt-at-non-option": false,
          "nargs-eats-options": false,
          "negation-prefix": "no-",
          "parse-numbers": true,
          "parse-positional-numbers": true,
          "populate--": false,
          "set-placeholder-key": false,
          "short-option-groups": true,
          "strip-aliased": false,
          "strip-dashed": false,
          "unknown-options-as-args": false
        }, opts.configuration);
        const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration["populate--"];
        const notFlagsArgv = notFlagsOption ? "--" : "_";
        const newAliases = /* @__PURE__ */ Object.create(null);
        const defaulted = /* @__PURE__ */ Object.create(null);
        const __ = opts.__ || mixin.format;
        const flags = {
          aliases: /* @__PURE__ */ Object.create(null),
          arrays: /* @__PURE__ */ Object.create(null),
          bools: /* @__PURE__ */ Object.create(null),
          strings: /* @__PURE__ */ Object.create(null),
          numbers: /* @__PURE__ */ Object.create(null),
          counts: /* @__PURE__ */ Object.create(null),
          normalize: /* @__PURE__ */ Object.create(null),
          configs: /* @__PURE__ */ Object.create(null),
          nargs: /* @__PURE__ */ Object.create(null),
          coercions: /* @__PURE__ */ Object.create(null),
          keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
          const key = typeof opt === "object" ? opt.key : opt;
          const assignment = Object.keys(opt).map(function(key2) {
            const arrayFlagKeys = {
              boolean: "bools",
              string: "strings",
              number: "numbers"
            };
            return arrayFlagKeys[key2];
          }).filter(Boolean).pop();
          if (assignment) {
            flags[assignment][key] = true;
          }
          flags.arrays[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
          flags.bools[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
          flags.strings[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
          flags.numbers[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
          flags.counts[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
          flags.normalize[key] = true;
          flags.keys.push(key);
        });
        if (typeof opts.narg === "object") {
          Object.entries(opts.narg).forEach(([key, value2]) => {
            if (typeof value2 === "number") {
              flags.nargs[key] = value2;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.coerce === "object") {
          Object.entries(opts.coerce).forEach(([key, value2]) => {
            if (typeof value2 === "function") {
              flags.coercions[key] = value2;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.config !== "undefined") {
          if (Array.isArray(opts.config) || typeof opts.config === "string") {
            ;
            [].concat(opts.config).filter(Boolean).forEach(function(key) {
              flags.configs[key] = true;
            });
          } else if (typeof opts.config === "object") {
            Object.entries(opts.config).forEach(([key, value2]) => {
              if (typeof value2 === "boolean" || typeof value2 === "function") {
                flags.configs[key] = value2;
              }
            });
          }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
          (flags.aliases[key] || []).forEach(function(alias) {
            defaults[alias] = defaults[key];
          });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv2 = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
        const argvReturn = {};
        for (let i = 0; i < args5.length; i++) {
          const arg = args5[i];
          const truncatedArg = arg.replace(/^-{3,}/, "---");
          let broken;
          let key;
          let letters;
          let m;
          let next;
          let value2;
          if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
            pushPositional(arg);
          } else if (truncatedArg.match(/^---+(=|$)/)) {
            pushPositional(arg);
            continue;
          } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
            m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              if (checkAllAliases(m[1], flags.arrays)) {
                i = eatArray(i, m[1], args5, m[2]);
              } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                i = eatNargs(i, m[1], args5, m[2]);
              } else {
                setArg(m[1], m[2], true);
              }
            }
          } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
            m = arg.match(negatedBoolean);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
            }
          } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
            m = arg.match(/^--?(.+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args5);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args5);
              } else {
                next = args5[i + 1];
                if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-.\..+=/)) {
            m = arg.match(/^-([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              setArg(m[1], m[2]);
            }
          } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
            next = args5[i + 1];
            m = arg.match(/^-(.\..+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
            letters = arg.slice(1, -1).split("");
            broken = false;
            for (let j = 0; j < letters.length; j++) {
              next = arg.slice(j + 2);
              if (letters[j + 1] && letters[j + 1] === "=") {
                value2 = arg.slice(j + 3);
                key = letters[j];
                if (checkAllAliases(key, flags.arrays)) {
                  i = eatArray(i, key, args5, value2);
                } else if (checkAllAliases(key, flags.nargs) !== false) {
                  i = eatNargs(i, key, args5, value2);
                } else {
                  setArg(key, value2);
                }
                broken = true;
                break;
              }
              if (next === "-") {
                setArg(letters[j], next);
                continue;
              }
              if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                setArg(letters[j], next);
                broken = true;
                break;
              }
              if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                setArg(letters[j], next);
                broken = true;
                break;
              } else {
                setArg(letters[j], defaultValue(letters[j]));
              }
            }
            key = arg.slice(-1)[0];
            if (!broken && key !== "-") {
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args5);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args5);
              } else {
                next = args5[i + 1];
                if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
            key = arg.slice(1);
            setArg(key, defaultValue(key));
          } else if (arg === "--") {
            notFlags = args5.slice(i + 1);
            break;
          } else if (configuration["halt-at-non-option"]) {
            notFlags = args5.slice(i);
            break;
          } else {
            pushPositional(arg);
          }
        }
        applyEnvVars(argv2, true);
        applyEnvVars(argv2, false);
        setConfig(argv2);
        setConfigObjects();
        applyDefaultsAndAliases(argv2, flags.aliases, defaults, true);
        applyCoercions(argv2);
        if (configuration["set-placeholder-key"])
          setPlaceholderKeys(argv2);
        Object.keys(flags.counts).forEach(function(key) {
          if (!hasKey(argv2, key.split(".")))
            setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length)
          argv2[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
          argv2[notFlagsArgv].push(key);
        });
        if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
          Object.keys(argv2).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
            delete argv2[key];
          });
        }
        if (configuration["strip-aliased"]) {
          ;
          [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
            if (configuration["camel-case-expansion"] && alias.includes("-")) {
              delete argv2[alias.split(".").map((prop) => camelCase(prop)).join(".")];
            }
            delete argv2[alias];
          });
        }
        function pushPositional(arg) {
          const maybeCoercedNumber = maybeCoerceNumber("_", arg);
          if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
            argv2._.push(maybeCoercedNumber);
          }
        }
        function eatNargs(i, key, args6, argAfterEqualSign) {
          let ii;
          let toEat = checkAllAliases(key, flags.nargs);
          toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
          if (toEat === 0) {
            if (!isUndefined(argAfterEqualSign)) {
              error = Error(__("Argument unexpected for: %s", key));
            }
            setArg(key, defaultValue(key));
            return i;
          }
          let available = isUndefined(argAfterEqualSign) ? 0 : 1;
          if (configuration["nargs-eats-options"]) {
            if (args6.length - (i + 1) + available < toEat) {
              error = Error(__("Not enough arguments following: %s", key));
            }
            available = toEat;
          } else {
            for (ii = i + 1; ii < args6.length; ii++) {
              if (!args6[ii].match(/^-[^0-9]/) || args6[ii].match(negative) || isUnknownOptionAsArg(args6[ii]))
                available++;
              else
                break;
            }
            if (available < toEat)
              error = Error(__("Not enough arguments following: %s", key));
          }
          let consumed = Math.min(available, toEat);
          if (!isUndefined(argAfterEqualSign) && consumed > 0) {
            setArg(key, argAfterEqualSign);
            consumed--;
          }
          for (ii = i + 1; ii < consumed + i + 1; ii++) {
            setArg(key, args6[ii]);
          }
          return i + consumed;
        }
        function eatArray(i, key, args6, argAfterEqualSign) {
          let argsToSet = [];
          let next = argAfterEqualSign || args6[i + 1];
          const nargsCount = checkAllAliases(key, flags.nargs);
          if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
            argsToSet.push(true);
          } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
            if (defaults[key] !== void 0) {
              const defVal = defaults[key];
              argsToSet = Array.isArray(defVal) ? defVal : [defVal];
            }
          } else {
            if (!isUndefined(argAfterEqualSign)) {
              argsToSet.push(processValue(key, argAfterEqualSign, true));
            }
            for (let ii = i + 1; ii < args6.length; ii++) {
              if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount)
                break;
              next = args6[ii];
              if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
                break;
              i = ii;
              argsToSet.push(processValue(key, next, inputIsString));
            }
          }
          if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          setArg(key, argsToSet);
          return i;
        }
        function setArg(key, val, shouldStripQuotes = inputIsString) {
          if (/-/.test(key) && configuration["camel-case-expansion"]) {
            const alias = key.split(".").map(function(prop) {
              return camelCase(prop);
            }).join(".");
            addNewAlias(key, alias);
          }
          const value2 = processValue(key, val, shouldStripQuotes);
          const splitKey = key.split(".");
          setKey(argv2, splitKey, value2);
          if (flags.aliases[key]) {
            flags.aliases[key].forEach(function(x) {
              const keyProperties = x.split(".");
              setKey(argv2, keyProperties, value2);
            });
          }
          if (splitKey.length > 1 && configuration["dot-notation"]) {
            ;
            (flags.aliases[splitKey[0]] || []).forEach(function(x) {
              let keyProperties = x.split(".");
              const a = [].concat(splitKey);
              a.shift();
              keyProperties = keyProperties.concat(a);
              if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
                setKey(argv2, keyProperties, value2);
              }
            });
          }
          if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
            const keys = [key].concat(flags.aliases[key] || []);
            keys.forEach(function(key2) {
              Object.defineProperty(argvReturn, key2, {
                enumerable: true,
                get() {
                  return val;
                },
                set(value3) {
                  val = typeof value3 === "string" ? mixin.normalize(value3) : value3;
                }
              });
            });
          }
        }
        function addNewAlias(key, alias) {
          if (!(flags.aliases[key] && flags.aliases[key].length)) {
            flags.aliases[key] = [alias];
            newAliases[alias] = true;
          }
          if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
            addNewAlias(alias, key);
          }
        }
        function processValue(key, val, shouldStripQuotes) {
          if (shouldStripQuotes) {
            val = stripQuotes(val);
          }
          if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
            if (typeof val === "string")
              val = val === "true";
          }
          let value2 = Array.isArray(val) ? val.map(function(v) {
            return maybeCoerceNumber(key, v);
          }) : maybeCoerceNumber(key, val);
          if (checkAllAliases(key, flags.counts) && (isUndefined(value2) || typeof value2 === "boolean")) {
            value2 = increment();
          }
          if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
            if (Array.isArray(val))
              value2 = val.map((val2) => {
                return mixin.normalize(val2);
              });
            else
              value2 = mixin.normalize(val);
          }
          return value2;
        }
        function maybeCoerceNumber(key, value2) {
          if (!configuration["parse-positional-numbers"] && key === "_")
            return value2;
          if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value2)) {
            const shouldCoerceNumber = looksLikeNumber(value2) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value2}`)));
            if (shouldCoerceNumber || !isUndefined(value2) && checkAllAliases(key, flags.numbers)) {
              value2 = Number(value2);
            }
          }
          return value2;
        }
        function setConfig(argv3) {
          const configLookup = /* @__PURE__ */ Object.create(null);
          applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
          Object.keys(flags.configs).forEach(function(configKey) {
            const configPath = argv3[configKey] || configLookup[configKey];
            if (configPath) {
              try {
                let config = null;
                const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);
                const resolveConfig = flags.configs[configKey];
                if (typeof resolveConfig === "function") {
                  try {
                    config = resolveConfig(resolvedConfigPath);
                  } catch (e) {
                    config = e;
                  }
                  if (config instanceof Error) {
                    error = config;
                    return;
                  }
                } else {
                  config = mixin.require(resolvedConfigPath);
                }
                setConfigObject(config);
              } catch (ex) {
                if (ex.name === "PermissionDenied")
                  error = ex;
                else if (argv3[configKey])
                  error = Error(__("Invalid JSON config file: %s", configPath));
              }
            }
          });
        }
        function setConfigObject(config, prev) {
          Object.keys(config).forEach(function(key) {
            const value2 = config[key];
            const fullKey = prev ? prev + "." + key : key;
            if (typeof value2 === "object" && value2 !== null && !Array.isArray(value2) && configuration["dot-notation"]) {
              setConfigObject(value2, fullKey);
            } else {
              if (!hasKey(argv2, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
                setArg(fullKey, value2);
              }
            }
          });
        }
        function setConfigObjects() {
          if (typeof configObjects !== "undefined") {
            configObjects.forEach(function(configObject) {
              setConfigObject(configObject);
            });
          }
        }
        function applyEnvVars(argv3, configOnly) {
          if (typeof envPrefix === "undefined")
            return;
          const prefix = typeof envPrefix === "string" ? envPrefix : "";
          const env3 = mixin.env();
          Object.keys(env3).forEach(function(envVar) {
            if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
              const keys = envVar.split("__").map(function(key, i) {
                if (i === 0) {
                  key = key.substring(prefix.length);
                }
                return camelCase(key);
              });
              if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv3, keys)) {
                setArg(keys.join("."), env3[envVar]);
              }
            }
          });
        }
        function applyCoercions(argv3) {
          let coerce;
          const applied = /* @__PURE__ */ new Set();
          Object.keys(argv3).forEach(function(key) {
            if (!applied.has(key)) {
              coerce = checkAllAliases(key, flags.coercions);
              if (typeof coerce === "function") {
                try {
                  const value2 = maybeCoerceNumber(key, coerce(argv3[key]));
                  [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                    applied.add(ali);
                    argv3[ali] = value2;
                  });
                } catch (err) {
                  error = err;
                }
              }
            }
          });
        }
        function setPlaceholderKeys(argv3) {
          flags.keys.forEach((key) => {
            if (~key.indexOf("."))
              return;
            if (typeof argv3[key] === "undefined")
              argv3[key] = void 0;
          });
          return argv3;
        }
        function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
          Object.keys(defaults2).forEach(function(key) {
            if (!hasKey(obj, key.split("."))) {
              setKey(obj, key.split("."), defaults2[key]);
              if (canLog)
                defaulted[key] = true;
              (aliases2[key] || []).forEach(function(x) {
                if (hasKey(obj, x.split(".")))
                  return;
                setKey(obj, x.split("."), defaults2[key]);
              });
            }
          });
        }
        function hasKey(obj, keys) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            o = o[key2] || {};
          });
          const key = keys[keys.length - 1];
          if (typeof o !== "object")
            return false;
          else
            return key in o;
        }
        function setKey(obj, keys, value2) {
          let o = obj;
          if (!configuration["dot-notation"])
            keys = [keys.join(".")];
          keys.slice(0, -1).forEach(function(key2) {
            key2 = sanitizeKey(key2);
            if (typeof o === "object" && o[key2] === void 0) {
              o[key2] = {};
            }
            if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
              if (Array.isArray(o[key2])) {
                o[key2].push({});
              } else {
                o[key2] = [o[key2], {}];
              }
              o = o[key2][o[key2].length - 1];
            } else {
              o = o[key2];
            }
          });
          const key = sanitizeKey(keys[keys.length - 1]);
          const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
          const isValueArray = Array.isArray(value2);
          let duplicate = configuration["duplicate-arguments-array"];
          if (!duplicate && checkAllAliases(key, flags.nargs)) {
            duplicate = true;
            if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
              o[key] = void 0;
            }
          }
          if (value2 === increment()) {
            o[key] = increment(o[key]);
          } else if (Array.isArray(o[key])) {
            if (duplicate && isTypeArray && isValueArray) {
              o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value2) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value2]);
            } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
              o[key] = value2;
            } else {
              o[key] = o[key].concat([value2]);
            }
          } else if (o[key] === void 0 && isTypeArray) {
            o[key] = isValueArray ? value2 : [value2];
          } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
            o[key] = [o[key], value2];
          } else {
            o[key] = value2;
          }
        }
        function extendAliases(...args6) {
          args6.forEach(function(obj) {
            Object.keys(obj || {}).forEach(function(key) {
              if (flags.aliases[key])
                return;
              flags.aliases[key] = [].concat(aliases[key] || []);
              flags.aliases[key].concat(key).forEach(function(x) {
                if (/-/.test(x) && configuration["camel-case-expansion"]) {
                  const c = camelCase(x);
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].concat(key).forEach(function(x) {
                if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                  const c = decamelize(x, "-");
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].forEach(function(x) {
                flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
                  return x !== y;
                }));
              });
            });
          });
        }
        function checkAllAliases(key, flag) {
          const toCheck = [].concat(flags.aliases[key] || [], key);
          const keys = Object.keys(flag);
          const setAlias = toCheck.find((key2) => keys.includes(key2));
          return setAlias ? flag[setAlias] : false;
        }
        function hasAnyFlag(key) {
          const flagsKeys = Object.keys(flags);
          const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
          return toCheck.some(function(flag) {
            return Array.isArray(flag) ? flag.includes(key) : flag[key];
          });
        }
        function hasFlagsMatching(arg, ...patterns) {
          const toCheck = [].concat(...patterns);
          return toCheck.some(function(pattern) {
            const match = arg.match(pattern);
            return match && hasAnyFlag(match[1]);
          });
        }
        function hasAllShortFlags(arg) {
          if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
            return false;
          }
          let hasAllFlags = true;
          let next;
          const letters = arg.slice(1).split("");
          for (let j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (!hasAnyFlag(letters[j])) {
              hasAllFlags = false;
              break;
            }
            if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
              break;
            }
          }
          return hasAllFlags;
        }
        function isUnknownOptionAsArg(arg) {
          return configuration["unknown-options-as-args"] && isUnknownOption(arg);
        }
        function isUnknownOption(arg) {
          arg = arg.replace(/^-{3,}/, "--");
          if (arg.match(negative)) {
            return false;
          }
          if (hasAllShortFlags(arg)) {
            return false;
          }
          const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
          const normalFlag = /^-+([^=]+?)$/;
          const flagEndingInHyphen = /^-+([^=]+?)-$/;
          const flagEndingInDigits = /^-+([^=]+?\d+)$/;
          const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
          return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        function defaultValue(key) {
          if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
            return defaults[key];
          } else {
            return defaultForType(guessType(key));
          }
        }
        function defaultForType(type) {
          const def = {
            [DefaultValuesForTypeKey.BOOLEAN]: true,
            [DefaultValuesForTypeKey.STRING]: "",
            [DefaultValuesForTypeKey.NUMBER]: void 0,
            [DefaultValuesForTypeKey.ARRAY]: []
          };
          return def[type];
        }
        function guessType(key) {
          let type = DefaultValuesForTypeKey.BOOLEAN;
          if (checkAllAliases(key, flags.strings))
            type = DefaultValuesForTypeKey.STRING;
          else if (checkAllAliases(key, flags.numbers))
            type = DefaultValuesForTypeKey.NUMBER;
          else if (checkAllAliases(key, flags.bools))
            type = DefaultValuesForTypeKey.BOOLEAN;
          else if (checkAllAliases(key, flags.arrays))
            type = DefaultValuesForTypeKey.ARRAY;
          return type;
        }
        function isUndefined(num) {
          return num === void 0;
        }
        function checkConfiguration() {
          Object.keys(flags.counts).find((key) => {
            if (checkAllAliases(key, flags.arrays)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
              return true;
            } else if (checkAllAliases(key, flags.nargs)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
              return true;
            }
            return false;
          });
        }
        return {
          aliases: Object.assign({}, flags.aliases),
          argv: Object.assign(argvReturn, argv2),
          configuration,
          defaulted: Object.assign({}, defaulted),
          error,
          newAliases: Object.assign({}, newAliases)
        };
      }
    };
  }
});

// node_modules/yargs-parser/build/lib/index.js
var import_util5, import_path11, import_fs19, _a, _b, _c, minNodeVersion, nodeVersion, env, parser2, yargsParser, lib_default;
var init_lib = __esm({
  "node_modules/yargs-parser/build/lib/index.js"() {
    "use strict";
    import_util5 = require("util");
    import_path11 = require("path");
    init_string_utils();
    init_yargs_parser();
    import_fs19 = require("fs");
    minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
    nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
    if (nodeVersion) {
      const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
      if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
      }
    }
    env = process ? process.env : {};
    parser2 = new YargsParser({
      cwd: process.cwd,
      env: () => {
        return env;
      },
      format: import_util5.format,
      normalize: import_path11.normalize,
      resolve: import_path11.resolve,
      // TODO: figure  out a  way to combine ESM and CJS coverage, such  that
      // we can exercise all the lines below:
      require: (path5) => {
        if (typeof require !== "undefined") {
          return require(path5);
        } else if (path5.match(/\.json$/)) {
          return JSON.parse((0, import_fs19.readFileSync)(path5, "utf8"));
        } else {
          throw Error("only .json config files are supported in ESM");
        }
      }
    });
    yargsParser = function Parser(args5, opts) {
      const result = parser2.parse(args5.slice(), opts);
      return result.argv;
    };
    yargsParser.detailed = function(args5, opts) {
      return parser2.parse(args5.slice(), opts);
    };
    yargsParser.camelCase = camelCase;
    yargsParser.decamelize = decamelize;
    yargsParser.looksLikeNumber = looksLikeNumber;
    lib_default = yargsParser;
  }
});

// src/lib/core/runners/distributed-agent/v1/execute-tasks.ts
async function executeTasks(agentName, api, dteArtifactStorage, invokeTasks, targets) {
  let completedStatusCode = 0;
  let apiResponse = null;
  const failIfSameTasksAfterTimeout = createUnchangedValueTimeout({
    title: `No new messages received after ${NO_MESSAGES_TIMEOUT / 1e3} seconds`,
    timeout: NO_MESSAGES_TIMEOUT
  });
  let completedTasks = [];
  const startTime = /* @__PURE__ */ new Date();
  let executedAnyTasks = false;
  const processedTasks = {};
  while (true) {
    if (VERBOSE_LOGGING) {
      output27.note({
        title: `${agentName} fetching tasks...`
      });
    }
    apiResponse = await api.tasks(
      apiResponse ? apiResponse.executionId : null,
      completedStatusCode,
      completedTasks,
      targets
    );
    if (VERBOSE_LOGGING) {
      output27.note({
        title: `${agentName} received an API Response`,
        bodyLines: [
          `completed: ${apiResponse.completed}`,
          `status: ${apiResponse.status}`,
          `retryDuring: ${apiResponse.retryDuring}`,
          `executionId: ${apiResponse.executionId}`,
          `number of tasks: ${apiResponse.tasks.length}`,
          `error: ${apiResponse.criticalErrorMessage}`,
          `maxParallel: ${apiResponse.maxParallel}`,
          `taskRunnerConfiguration: ${apiResponse.taskRunnerConfiguration}`
        ]
      });
    }
    if (apiResponse.criticalErrorMessage) {
      output27.error({
        title: "Distributed Execution Terminated",
        bodyLines: ["Error:", apiResponse.criticalErrorMessage]
      });
      process.exit(1);
    }
    if ((apiResponse == null ? void 0 : apiResponse.retryDuring) && (apiResponse == null ? void 0 : apiResponse.retryDuring) !== 0 && !executedAnyTasks && (/* @__PURE__ */ new Date()).getTime() - startTime.getTime() > apiResponse.retryDuring) {
      await wait(2e4);
      continue;
    }
    if ((apiResponse == null ? void 0 : apiResponse.status) !== void 0) {
      if (apiResponse.status === "RUN_GROUP_COMPLETED" || apiResponse.status === "NO_FURTHER_TASKS_TO_RUN") {
        return;
      }
    } else if (apiResponse.completed) {
      return;
    }
    failIfSameTasksAfterTimeout(
      apiResponse.tasks.map((t) => t.taskId).join("")
    );
    if (!apiResponse.executionId) {
      if (VERBOSE_LOGGING) {
        output27.note({
          title: `${agentName} waiting...`
        });
      }
      await wait(5e3);
      completedStatusCode = 0;
      completedTasks = [];
      continue;
    }
    executedAnyTasks = true;
    if (apiResponse.completedTasks) {
      for (const t of apiResponse.completedTasks) {
        if (processedTasks[t.taskId])
          continue;
        output27.note({
          title: `${agentName} downloading artifacts for ${t.taskId} Hash: ${t.hash}}`
        });
        const cacheFiles = [
          { remoteUrl: t.url, fileType: "artifact" }
        ];
        if (t.terminalOutputUrl) {
          cacheFiles.push({
            remoteUrl: t.terminalOutputUrl,
            fileType: "terminalOutput"
          });
        }
        await dteArtifactStorage.retrieveAndExtract(t.hash, cacheFiles);
        processedTasks[t.taskId] = true;
      }
    }
    const tasks = apiResponse.tasks.map((t) => {
      const params = lib_default(t.params, {
        configuration: {
          "camel-case-expansion": false,
          "dot-notation": true
        }
      });
      const unparsed = unparse(params);
      if (params._.length == 0) {
        delete params._;
      }
      return {
        id: t.taskId,
        target: {
          project: t.projectName,
          target: t.target,
          configuration: t.configuration
        },
        overrides: {
          ...params,
          __overrides_unparsed__: unparsed
        },
        projectRoot: t.projectRoot,
        cache: t.cache,
        outputs: t.outputs
      };
    });
    const r = await invokeTasks(
      apiResponse.executionId,
      tasks,
      apiResponse.maxParallel,
      apiResponse.taskRunnerConfiguration
    );
    for (const t of r.completedTasks) {
      processedTasks[t.taskId] = true;
    }
    completedStatusCode = r.completedStatusCode;
    completedTasks = r.completedTasks;
  }
}
var output27;
var init_execute_tasks = __esm({
  "src/lib/core/runners/distributed-agent/v1/execute-tasks.ts"() {
    "use strict";
    init_lib();
    init_create_unchanged_value_timeout();
    init_environment();
    init_serializer_overrides();
    init_waiter();
    ({ output: output27 } = require_nx_imports_light());
  }
});

// ../../../node_modules/make-error/index.js
var require_make_error = __commonJS({
  "../../../node_modules/make-error/index.js"(exports2, module2) {
    "use strict";
    var construct = typeof Reflect !== "undefined" ? Reflect.construct : void 0;
    var defineProperty = Object.defineProperty;
    var captureStackTrace = Error.captureStackTrace;
    if (captureStackTrace === void 0) {
      captureStackTrace = function captureStackTrace2(error) {
        var container = new Error();
        defineProperty(error, "stack", {
          configurable: true,
          get: function getStack() {
            var stack = container.stack;
            defineProperty(this, "stack", {
              configurable: true,
              value: stack,
              writable: true
            });
            return stack;
          },
          set: function setStack(stack) {
            defineProperty(error, "stack", {
              configurable: true,
              value: stack,
              writable: true
            });
          }
        });
      };
    }
    function BaseError(message) {
      if (message !== void 0) {
        defineProperty(this, "message", {
          configurable: true,
          value: message,
          writable: true
        });
      }
      var cname = this.constructor.name;
      if (cname !== void 0 && cname !== this.name) {
        defineProperty(this, "name", {
          configurable: true,
          value: cname,
          writable: true
        });
      }
      captureStackTrace(this, this.constructor);
    }
    BaseError.prototype = Object.create(Error.prototype, {
      // See: https://github.com/JsCommunity/make-error/issues/4
      constructor: {
        configurable: true,
        value: BaseError,
        writable: true
      }
    });
    var setFunctionName = function() {
      function setFunctionName2(fn, name) {
        return defineProperty(fn, "name", {
          configurable: true,
          value: name
        });
      }
      try {
        var f = function() {
        };
        setFunctionName2(f, "foo");
        if (f.name === "foo") {
          return setFunctionName2;
        }
      } catch (_) {
      }
    }();
    function makeError(constructor, super_) {
      if (super_ == null || super_ === Error) {
        super_ = BaseError;
      } else if (typeof super_ !== "function") {
        throw new TypeError("super_ should be a function");
      }
      var name;
      if (typeof constructor === "string") {
        name = constructor;
        constructor = construct !== void 0 ? function() {
          return construct(super_, arguments, this.constructor);
        } : function() {
          super_.apply(this, arguments);
        };
        if (setFunctionName !== void 0) {
          setFunctionName(constructor, name);
          name = void 0;
        }
      } else if (typeof constructor !== "function") {
        throw new TypeError("constructor should be either a string or a function");
      }
      constructor.super_ = constructor["super"] = super_;
      var properties = {
        constructor: {
          configurable: true,
          value: constructor,
          writable: true
        }
      };
      if (name !== void 0) {
        properties.name = {
          configurable: true,
          value: name,
          writable: true
        };
      }
      constructor.prototype = Object.create(super_.prototype, properties);
      return constructor;
    }
    exports2 = module2.exports = makeError;
    exports2.BaseError = BaseError;
  }
});

// ../../../node_modules/yn/lenient.js
var require_lenient = __commonJS({
  "../../../node_modules/yn/lenient.js"(exports2, module2) {
    "use strict";
    var YES_MATCH_SCORE_THRESHOLD = 2;
    var NO_MATCH_SCORE_THRESHOLD = 1.25;
    var yMatch = /* @__PURE__ */ new Map([
      [5, 0.25],
      [6, 0.25],
      [7, 0.25],
      ["t", 0.75],
      ["y", 1],
      ["u", 0.75],
      ["g", 0.25],
      ["h", 0.25],
      ["j", 0.25]
    ]);
    var eMatch = /* @__PURE__ */ new Map([
      [2, 0.25],
      [3, 0.25],
      [4, 0.25],
      ["w", 0.75],
      ["e", 1],
      ["r", 0.75],
      ["s", 0.25],
      ["d", 0.25],
      ["f", 0.25]
    ]);
    var sMatch = /* @__PURE__ */ new Map([
      ["q", 0.25],
      ["w", 0.25],
      ["e", 0.25],
      ["a", 0.75],
      ["s", 1],
      ["d", 0.75],
      ["z", 0.25],
      ["x", 0.25],
      ["c", 0.25]
    ]);
    var nMatch = /* @__PURE__ */ new Map([
      ["h", 0.25],
      ["j", 0.25],
      ["k", 0.25],
      ["b", 0.75],
      ["n", 1],
      ["m", 0.75]
    ]);
    var oMatch = /* @__PURE__ */ new Map([
      [9, 0.25],
      [0, 0.25],
      ["i", 0.75],
      ["o", 1],
      ["p", 0.75],
      ["k", 0.25],
      ["l", 0.25]
    ]);
    function getYesMatchScore(value2) {
      const [y, e, s] = value2;
      let score = 0;
      if (yMatch.has(y)) {
        score += yMatch.get(y);
      }
      if (eMatch.has(e)) {
        score += eMatch.get(e);
      }
      if (sMatch.has(s)) {
        score += sMatch.get(s);
      }
      return score;
    }
    function getNoMatchScore(value2) {
      const [n, o] = value2;
      let score = 0;
      if (nMatch.has(n)) {
        score += nMatch.get(n);
      }
      if (oMatch.has(o)) {
        score += oMatch.get(o);
      }
      return score;
    }
    module2.exports = (input, options) => {
      if (getYesMatchScore(input) >= YES_MATCH_SCORE_THRESHOLD) {
        return true;
      }
      if (getNoMatchScore(input) >= NO_MATCH_SCORE_THRESHOLD) {
        return false;
      }
      return options.default;
    };
  }
});

// ../../../node_modules/yn/index.js
var require_yn = __commonJS({
  "../../../node_modules/yn/index.js"(exports2, module2) {
    "use strict";
    var lenient = require_lenient();
    var yn = (input, options) => {
      input = String(input).trim();
      options = Object.assign({
        lenient: false,
        default: null
      }, options);
      if (options.default !== null && typeof options.default !== "boolean") {
        throw new TypeError(`Expected the \`default\` option to be of type \`boolean\`, got \`${typeof options.default}\``);
      }
      if (/^(?:y|yes|true|1)$/i.test(input)) {
        return true;
      }
      if (/^(?:n|no|false|0)$/i.test(input)) {
        return false;
      }
      if (options.lenient === true) {
        return lenient(input, options);
      }
      return options.default;
    };
    module2.exports = yn;
    module2.exports.default = yn;
  }
});

// ../../../node_modules/create-require/create-require.js
var require_create_require = __commonJS({
  "../../../node_modules/create-require/create-require.js"(exports2, module2) {
    "use strict";
    var nativeModule = require("module");
    var path5 = require("path");
    var fs = require("fs");
    function createRequire(filename) {
      if (!filename) {
        filename = process.cwd();
      }
      if (isDir(filename)) {
        filename = path5.join(filename, "index.js");
      }
      if (nativeModule.createRequire) {
        return nativeModule.createRequire(filename);
      }
      if (nativeModule.createRequireFromPath) {
        return nativeModule.createRequireFromPath(filename);
      }
      return _createRequire(filename);
    }
    function _createRequire(filename) {
      const mod = new nativeModule.Module(filename, null);
      mod.filename = filename;
      mod.paths = nativeModule.Module._nodeModulePaths(path5.dirname(filename));
      mod._compile("module.exports = require;", filename);
      return mod.exports;
    }
    function isDir(path6) {
      try {
        const stat = fs.lstatSync(path6);
        return stat.isDirectory();
      } catch (e) {
        return false;
      }
    }
    module2.exports = createRequire;
  }
});

// ../../../node_modules/v8-compile-cache-lib/v8-compile-cache.js
var require_v8_compile_cache = __commonJS({
  "../../../node_modules/v8-compile-cache-lib/v8-compile-cache.js"(exports2, module2) {
    "use strict";
    var Module = require("module");
    var crypto = require("crypto");
    var fs = require("fs");
    var path5 = require("path");
    var vm = require("vm");
    var os = require("os");
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var FileSystemBlobStore = class {
      constructor(directory, prefix) {
        const name = prefix ? slashEscape(prefix + ".") : "";
        this._blobFilename = path5.join(directory, name + "BLOB");
        this._mapFilename = path5.join(directory, name + "MAP");
        this._lockFilename = path5.join(directory, name + "LOCK");
        this._directory = directory;
        this._load();
      }
      has(key, invalidationKey) {
        if (hasOwnProperty.call(this._memoryBlobs, key)) {
          return this._invalidationKeys[key] === invalidationKey;
        } else if (hasOwnProperty.call(this._storedMap, key)) {
          return this._storedMap[key][0] === invalidationKey;
        }
        return false;
      }
      get(key, invalidationKey) {
        if (hasOwnProperty.call(this._memoryBlobs, key)) {
          if (this._invalidationKeys[key] === invalidationKey) {
            return this._memoryBlobs[key];
          }
        } else if (hasOwnProperty.call(this._storedMap, key)) {
          const mapping = this._storedMap[key];
          if (mapping[0] === invalidationKey) {
            return this._storedBlob.slice(mapping[1], mapping[2]);
          }
        }
      }
      set(key, invalidationKey, buffer) {
        this._invalidationKeys[key] = invalidationKey;
        this._memoryBlobs[key] = buffer;
        this._dirty = true;
      }
      delete(key) {
        if (hasOwnProperty.call(this._memoryBlobs, key)) {
          this._dirty = true;
          delete this._memoryBlobs[key];
        }
        if (hasOwnProperty.call(this._invalidationKeys, key)) {
          this._dirty = true;
          delete this._invalidationKeys[key];
        }
        if (hasOwnProperty.call(this._storedMap, key)) {
          this._dirty = true;
          delete this._storedMap[key];
        }
      }
      isDirty() {
        return this._dirty;
      }
      save() {
        const dump = this._getDump();
        const blobToStore = Buffer.concat(dump[0]);
        const mapToStore = JSON.stringify(dump[1]);
        try {
          mkdirpSync(this._directory);
          fs.writeFileSync(this._lockFilename, "LOCK", { flag: "wx" });
        } catch (error) {
          return false;
        }
        try {
          fs.writeFileSync(this._blobFilename, blobToStore);
          fs.writeFileSync(this._mapFilename, mapToStore);
        } finally {
          fs.unlinkSync(this._lockFilename);
        }
        return true;
      }
      _load() {
        try {
          this._storedBlob = fs.readFileSync(this._blobFilename);
          this._storedMap = JSON.parse(fs.readFileSync(this._mapFilename));
        } catch (e) {
          this._storedBlob = Buffer.alloc(0);
          this._storedMap = {};
        }
        this._dirty = false;
        this._memoryBlobs = {};
        this._invalidationKeys = {};
      }
      _getDump() {
        const buffers = [];
        const newMap = {};
        let offset = 0;
        function push(key, invalidationKey, buffer) {
          buffers.push(buffer);
          newMap[key] = [invalidationKey, offset, offset + buffer.length];
          offset += buffer.length;
        }
        for (const key of Object.keys(this._memoryBlobs)) {
          const buffer = this._memoryBlobs[key];
          const invalidationKey = this._invalidationKeys[key];
          push(key, invalidationKey, buffer);
        }
        for (const key of Object.keys(this._storedMap)) {
          if (hasOwnProperty.call(newMap, key))
            continue;
          const mapping = this._storedMap[key];
          const buffer = this._storedBlob.slice(mapping[1], mapping[2]);
          push(key, mapping[0], buffer);
        }
        return [buffers, newMap];
      }
    };
    var NativeCompileCache = class {
      constructor() {
        this._cacheStore = null;
        this._previousModuleCompile = null;
      }
      setCacheStore(cacheStore) {
        this._cacheStore = cacheStore;
      }
      install() {
        const self2 = this;
        const hasRequireResolvePaths = typeof require.resolve.paths === "function";
        this._previousModuleCompile = Module.prototype._compile;
        Module.prototype._compile = this._ownModuleCompile = _ownModuleCompile;
        self2.enabled = true;
        function _ownModuleCompile(content, filename) {
          if (!self2.enabled)
            return this._previousModuleCompile.apply(this, arguments);
          const mod = this;
          function require2(id) {
            return mod.require(id);
          }
          function resolve2(request, options) {
            return Module._resolveFilename(request, mod, false, options);
          }
          require2.resolve = resolve2;
          if (hasRequireResolvePaths) {
            resolve2.paths = function paths(request) {
              return Module._resolveLookupPaths(request, mod, true);
            };
          }
          require2.main = process.mainModule;
          require2.extensions = Module._extensions;
          require2.cache = Module._cache;
          const dirname3 = path5.dirname(filename);
          const compiledWrapper = self2._moduleCompile(filename, content);
          const args5 = [mod.exports, require2, mod, filename, dirname3, process, global, Buffer];
          return compiledWrapper.apply(mod.exports, args5);
        }
      }
      uninstall() {
        this.enabled = false;
        if (Module.prototype._compile === this._ownModuleCompile) {
          Module.prototype._compile = this._previousModuleCompile;
        }
      }
      _moduleCompile(filename, content) {
        var contLen = content.length;
        if (contLen >= 2) {
          if (content.charCodeAt(0) === 35 && content.charCodeAt(1) === 33) {
            if (contLen === 2) {
              content = "";
            } else {
              var i = 2;
              for (; i < contLen; ++i) {
                var code = content.charCodeAt(i);
                if (code === 10 || code === 13)
                  break;
              }
              if (i === contLen) {
                content = "";
              } else {
                content = content.slice(i);
              }
            }
          }
        }
        var wrapper = Module.wrap(content);
        var invalidationKey = crypto.createHash("sha1").update(content, "utf8").digest("hex");
        var buffer = this._cacheStore.get(filename, invalidationKey);
        var script = new vm.Script(wrapper, {
          filename,
          lineOffset: 0,
          displayErrors: true,
          cachedData: buffer,
          produceCachedData: true
        });
        if (script.cachedDataProduced) {
          this._cacheStore.set(filename, invalidationKey, script.cachedData);
        } else if (script.cachedDataRejected) {
          this._cacheStore.delete(filename);
        }
        var compiledWrapper = script.runInThisContext({
          filename,
          lineOffset: 0,
          columnOffset: 0,
          displayErrors: true
        });
        return compiledWrapper;
      }
    };
    function mkdirpSync(p_) {
      _mkdirpSync(path5.resolve(p_), 511);
    }
    function _mkdirpSync(p, mode) {
      try {
        fs.mkdirSync(p, mode);
      } catch (err0) {
        if (err0.code === "ENOENT") {
          _mkdirpSync(path5.dirname(p));
          _mkdirpSync(p);
        } else {
          try {
            const stat = fs.statSync(p);
            if (!stat.isDirectory()) {
              throw err0;
            }
          } catch (err1) {
            throw err0;
          }
        }
      }
    }
    function slashEscape(str) {
      const ESCAPE_LOOKUP = {
        "\\": "zB",
        ":": "zC",
        "/": "zS",
        "\0": "z0",
        "z": "zZ"
      };
      const ESCAPE_REGEX = /[\\:/\x00z]/g;
      return str.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    function supportsCachedData() {
      const script = new vm.Script('""', { produceCachedData: true });
      return script.cachedDataProduced === true;
    }
    function getCacheDir() {
      const v8_compile_cache_cache_dir = process.env.V8_COMPILE_CACHE_CACHE_DIR;
      if (v8_compile_cache_cache_dir) {
        return v8_compile_cache_cache_dir;
      }
      const dirname3 = typeof process.getuid === "function" ? "v8-compile-cache-" + process.getuid() : "v8-compile-cache";
      const version = typeof process.versions.v8 === "string" ? process.versions.v8 : typeof process.versions.chakracore === "string" ? "chakracore-" + process.versions.chakracore : "node-" + process.version;
      const cacheDir = path5.join(os.tmpdir(), dirname3, version);
      return cacheDir;
    }
    function getMainName() {
      const mainName = require.main && typeof require.main.filename === "string" ? require.main.filename : process.cwd();
      return mainName;
    }
    function install(opts) {
      if (!process.env.DISABLE_V8_COMPILE_CACHE && supportsCachedData()) {
        if (typeof opts === "undefined")
          opts = {};
        let cacheDir = opts.cacheDir;
        if (typeof cacheDir === "undefined")
          cacheDir = getCacheDir();
        let prefix = opts.prefix;
        if (typeof prefix === "undefined")
          prefix = getMainName();
        const blobStore = new FileSystemBlobStore(cacheDir, prefix);
        const nativeCompileCache = new NativeCompileCache();
        nativeCompileCache.setCacheStore(blobStore);
        nativeCompileCache.install();
        let uninstalled = false;
        const uninstall = () => {
          if (uninstalled)
            return;
          uninstalled = true;
          process.removeListener("exit", uninstall);
          if (blobStore.isDirty()) {
            blobStore.save();
          }
          nativeCompileCache.uninstall();
        };
        process.once("exit", uninstall);
        return { uninstall };
      }
    }
    module2.exports.install = install;
    module2.exports.__TEST__ = {
      FileSystemBlobStore,
      NativeCompileCache,
      mkdirpSync,
      slashEscape,
      supportsCachedData,
      getCacheDir,
      getMainName
    };
  }
});

// ../../../node_modules/ts-node/dist/util.js
var require_util = __commonJS({
  "../../../node_modules/ts-node/dist/util.js"(exports2) {
    "use strict";
    var _a2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.versionGteLt = exports2.once = exports2.getBasePathForProjectLocalDependencyResolution = exports2.createProjectLocalResolveHelper = exports2.attemptRequireWithV8CompileCache = exports2.cachedLookup = exports2.hasOwnProperty = exports2.normalizeSlashes = exports2.parse = exports2.split = exports2.assign = exports2.yn = exports2.createRequire = void 0;
    var module_1 = require("module");
    var ynModule = require_yn();
    var path_1 = require("path");
    exports2.createRequire = (_a2 = module_1.createRequire !== null && module_1.createRequire !== void 0 ? module_1.createRequire : module_1.createRequireFromPath) !== null && _a2 !== void 0 ? _a2 : require_create_require();
    function yn(value2) {
      var _a3;
      return (_a3 = ynModule(value2)) !== null && _a3 !== void 0 ? _a3 : void 0;
    }
    exports2.yn = yn;
    function assign(initialValue, ...sources) {
      for (const source of sources) {
        for (const key of Object.keys(source)) {
          const value2 = source[key];
          if (value2 !== void 0)
            initialValue[key] = value2;
        }
      }
      return initialValue;
    }
    exports2.assign = assign;
    function split(value2) {
      return typeof value2 === "string" ? value2.split(/ *, */g).filter((v) => v !== "") : void 0;
    }
    exports2.split = split;
    function parse2(value2) {
      return typeof value2 === "string" ? JSON.parse(value2) : void 0;
    }
    exports2.parse = parse2;
    var directorySeparator = "/";
    var backslashRegExp = /\\/g;
    function normalizeSlashes(value2) {
      return value2.replace(backslashRegExp, directorySeparator);
    }
    exports2.normalizeSlashes = normalizeSlashes;
    function hasOwnProperty(object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }
    exports2.hasOwnProperty = hasOwnProperty;
    function cachedLookup(fn) {
      const cache = /* @__PURE__ */ new Map();
      return (arg) => {
        if (!cache.has(arg)) {
          const v = fn(arg);
          cache.set(arg, v);
          return v;
        }
        return cache.get(arg);
      };
    }
    exports2.cachedLookup = cachedLookup;
    function attemptRequireWithV8CompileCache(requireFn, specifier) {
      try {
        const v8CC = require_v8_compile_cache().install();
        try {
          return requireFn(specifier);
        } finally {
          v8CC === null || v8CC === void 0 ? void 0 : v8CC.uninstall();
        }
      } catch (e) {
        return requireFn(specifier);
      }
    }
    exports2.attemptRequireWithV8CompileCache = attemptRequireWithV8CompileCache;
    function createProjectLocalResolveHelper(localDirectory) {
      return function projectLocalResolveHelper(specifier, fallbackToTsNodeRelative) {
        return require.resolve(specifier, {
          paths: fallbackToTsNodeRelative ? [localDirectory, __dirname] : [localDirectory]
        });
      };
    }
    exports2.createProjectLocalResolveHelper = createProjectLocalResolveHelper;
    function getBasePathForProjectLocalDependencyResolution(configFilePath, projectSearchDirOption, projectOption, cwdOption) {
      var _a3;
      if (configFilePath != null)
        return (0, path_1.dirname)(configFilePath);
      return (_a3 = projectSearchDirOption !== null && projectSearchDirOption !== void 0 ? projectSearchDirOption : projectOption) !== null && _a3 !== void 0 ? _a3 : cwdOption;
    }
    exports2.getBasePathForProjectLocalDependencyResolution = getBasePathForProjectLocalDependencyResolution;
    function once(fn) {
      let value2;
      let ran = false;
      function onceFn(...args5) {
        if (ran)
          return value2;
        value2 = fn(...args5);
        ran = true;
        return value2;
      }
      return onceFn;
    }
    exports2.once = once;
    function versionGteLt(version, gteRequirement, ltRequirement) {
      const [major, minor, patch, extra] = parse3(version);
      const [gteMajor, gteMinor, gtePatch] = parse3(gteRequirement);
      const isGte = major > gteMajor || major === gteMajor && (minor > gteMinor || minor === gteMinor && patch >= gtePatch);
      let isLt = true;
      if (ltRequirement) {
        const [ltMajor, ltMinor, ltPatch] = parse3(ltRequirement);
        isLt = major < ltMajor || major === ltMajor && (minor < ltMinor || minor === ltMinor && patch < ltPatch);
      }
      return isGte && isLt;
      function parse3(requirement) {
        return requirement.split(/[\.-]/).map((s) => parseInt(s, 10));
      }
    }
    exports2.versionGteLt = versionGteLt;
  }
});

// ../../../node_modules/ts-node/dist/ts-internals.js
var require_ts_internals = __commonJS({
  "../../../node_modules/ts-node/dist/ts-internals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPatternFromSpec = exports2.createTsInternals = void 0;
    var path_1 = require("path");
    var util_1 = require_util();
    exports2.createTsInternals = (0, util_1.cachedLookup)(createTsInternalsUncached);
    function createTsInternalsUncached(_ts) {
      const ts = _ts;
      function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {
        extendedConfig = (0, util_1.normalizeSlashes)(extendedConfig);
        if (isRootedDiskPath(extendedConfig) || startsWith(extendedConfig, "./") || startsWith(extendedConfig, "../")) {
          let extendedConfigPath = getNormalizedAbsolutePath(extendedConfig, basePath);
          if (!host.fileExists(extendedConfigPath) && !endsWith(extendedConfigPath, ts.Extension.Json)) {
            extendedConfigPath = `${extendedConfigPath}.json`;
            if (!host.fileExists(extendedConfigPath)) {
              errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
              return void 0;
            }
          }
          return extendedConfigPath;
        }
        const resolved = ts.nodeModuleNameResolver(
          extendedConfig,
          combinePaths(basePath, "tsconfig.json"),
          { moduleResolution: ts.ModuleResolutionKind.NodeJs },
          host,
          /*cache*/
          void 0,
          /*projectRefs*/
          void 0,
          /*lookupConfig*/
          true
        );
        if (resolved.resolvedModule) {
          return resolved.resolvedModule.resolvedFileName;
        }
        errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
        return void 0;
      }
      return { getExtendsConfigPath };
    }
    function isRootedDiskPath(path5) {
      return (0, path_1.isAbsolute)(path5);
    }
    function combinePaths(path5, ...paths) {
      return (0, util_1.normalizeSlashes)((0, path_1.resolve)(path5, ...paths.filter((path6) => path6)));
    }
    function getNormalizedAbsolutePath(fileName, currentDirectory) {
      return (0, util_1.normalizeSlashes)(currentDirectory != null ? (0, path_1.resolve)(currentDirectory, fileName) : (0, path_1.resolve)(fileName));
    }
    function startsWith(str, prefix) {
      return str.lastIndexOf(prefix, 0) === 0;
    }
    function endsWith(str, suffix) {
      const expectedPos = str.length - suffix.length;
      return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;
    }
    var reservedCharacterPattern = /[^\w\s\/]/g;
    function getPatternFromSpec(spec, basePath) {
      const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);
      return pattern && `^(${pattern})${"($|/)"}`;
    }
    exports2.getPatternFromSpec = getPatternFromSpec;
    function getSubPatternFromSpec(spec, basePath, { singleAsteriskRegexFragment, doubleAsteriskRegexFragment, replaceWildcardCharacter: replaceWildcardCharacter2 }) {
      let subpattern = "";
      let hasWrittenComponent = false;
      const components = getNormalizedPathComponents(spec, basePath);
      const lastComponent = last(components);
      components[0] = removeTrailingDirectorySeparator(components[0]);
      if (isImplicitGlob(lastComponent)) {
        components.push("**", "*");
      }
      let optionalCount = 0;
      for (let component of components) {
        if (component === "**") {
          subpattern += doubleAsteriskRegexFragment;
        } else {
          if (hasWrittenComponent) {
            subpattern += directorySeparator;
          }
          subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter2);
        }
        hasWrittenComponent = true;
      }
      while (optionalCount > 0) {
        subpattern += ")?";
        optionalCount--;
      }
      return subpattern;
    }
    var excludeMatcher = {
      singleAsteriskRegexFragment: "[^/]*",
      doubleAsteriskRegexFragment: "(/.+?)?",
      replaceWildcardCharacter: (match) => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)
    };
    function getNormalizedPathComponents(path5, currentDirectory) {
      return reducePathComponents(getPathComponents(path5, currentDirectory));
    }
    function getPathComponents(path5, currentDirectory = "") {
      path5 = combinePaths(currentDirectory, path5);
      return pathComponents(path5, getRootLength(path5));
    }
    function reducePathComponents(components) {
      if (!some(components))
        return [];
      const reduced = [components[0]];
      for (let i = 1; i < components.length; i++) {
        const component = components[i];
        if (!component)
          continue;
        if (component === ".")
          continue;
        if (component === "..") {
          if (reduced.length > 1) {
            if (reduced[reduced.length - 1] !== "..") {
              reduced.pop();
              continue;
            }
          } else if (reduced[0])
            continue;
        }
        reduced.push(component);
      }
      return reduced;
    }
    function getRootLength(path5) {
      const rootLength = getEncodedRootLength(path5);
      return rootLength < 0 ? ~rootLength : rootLength;
    }
    function getEncodedRootLength(path5) {
      if (!path5)
        return 0;
      const ch0 = path5.charCodeAt(0);
      if (ch0 === 47 || ch0 === 92) {
        if (path5.charCodeAt(1) !== ch0)
          return 1;
        const p1 = path5.indexOf(ch0 === 47 ? directorySeparator : altDirectorySeparator, 2);
        if (p1 < 0)
          return path5.length;
        return p1 + 1;
      }
      if (isVolumeCharacter(ch0) && path5.charCodeAt(1) === 58) {
        const ch2 = path5.charCodeAt(2);
        if (ch2 === 47 || ch2 === 92)
          return 3;
        if (path5.length === 2)
          return 2;
      }
      const schemeEnd = path5.indexOf(urlSchemeSeparator);
      if (schemeEnd !== -1) {
        const authorityStart = schemeEnd + urlSchemeSeparator.length;
        const authorityEnd = path5.indexOf(directorySeparator, authorityStart);
        if (authorityEnd !== -1) {
          const scheme = path5.slice(0, schemeEnd);
          const authority = path5.slice(authorityStart, authorityEnd);
          if (scheme === "file" && (authority === "" || authority === "localhost") && isVolumeCharacter(path5.charCodeAt(authorityEnd + 1))) {
            const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path5, authorityEnd + 2);
            if (volumeSeparatorEnd !== -1) {
              if (path5.charCodeAt(volumeSeparatorEnd) === 47) {
                return ~(volumeSeparatorEnd + 1);
              }
              if (volumeSeparatorEnd === path5.length) {
                return ~volumeSeparatorEnd;
              }
            }
          }
          return ~(authorityEnd + 1);
        }
        return ~path5.length;
      }
      return 0;
    }
    function hasTrailingDirectorySeparator(path5) {
      return path5.length > 0 && isAnyDirectorySeparator(path5.charCodeAt(path5.length - 1));
    }
    function isAnyDirectorySeparator(charCode) {
      return charCode === 47 || charCode === 92;
    }
    function removeTrailingDirectorySeparator(path5) {
      if (hasTrailingDirectorySeparator(path5)) {
        return path5.substr(0, path5.length - 1);
      }
      return path5;
    }
    var directorySeparator = "/";
    var altDirectorySeparator = "\\";
    var urlSchemeSeparator = "://";
    function isVolumeCharacter(charCode) {
      return charCode >= 97 && charCode <= 122 || charCode >= 65 && charCode <= 90;
    }
    function getFileUrlVolumeSeparatorEnd(url, start) {
      const ch0 = url.charCodeAt(start);
      if (ch0 === 58)
        return start + 1;
      if (ch0 === 37 && url.charCodeAt(start + 1) === 51) {
        const ch2 = url.charCodeAt(start + 2);
        if (ch2 === 97 || ch2 === 65)
          return start + 3;
      }
      return -1;
    }
    function some(array, predicate) {
      if (array) {
        if (predicate) {
          for (const v of array) {
            if (predicate(v)) {
              return true;
            }
          }
        } else {
          return array.length > 0;
        }
      }
      return false;
    }
    function pathComponents(path5, rootLength) {
      const root = path5.substring(0, rootLength);
      const rest = path5.substring(rootLength).split(directorySeparator);
      if (rest.length && !lastOrUndefined(rest))
        rest.pop();
      return [root, ...rest];
    }
    function lastOrUndefined(array) {
      return array.length === 0 ? void 0 : array[array.length - 1];
    }
    function last(array) {
      return array[array.length - 1];
    }
    function replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
      return match === "*" ? singleAsteriskRegexFragment : match === "?" ? "[^/]" : "\\" + match;
    }
    function isImplicitGlob(lastPathComponent) {
      return !/[.*?]/.test(lastPathComponent);
    }
  }
});

// ../../../node_modules/@tsconfig/node16/tsconfig.json
var require_tsconfig = __commonJS({
  "../../../node_modules/@tsconfig/node16/tsconfig.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json.schemastore.org/tsconfig",
      display: "Node 16",
      compilerOptions: {
        lib: ["es2021"],
        module: "Node16",
        target: "es2021",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node"
      }
    };
  }
});

// ../../../node_modules/@tsconfig/node14/tsconfig.json
var require_tsconfig2 = __commonJS({
  "../../../node_modules/@tsconfig/node14/tsconfig.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json.schemastore.org/tsconfig",
      display: "Node 14",
      compilerOptions: {
        lib: ["es2020"],
        module: "commonjs",
        target: "es2020",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node"
      }
    };
  }
});

// ../../../node_modules/@tsconfig/node12/tsconfig.json
var require_tsconfig3 = __commonJS({
  "../../../node_modules/@tsconfig/node12/tsconfig.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json.schemastore.org/tsconfig",
      display: "Node 12",
      compilerOptions: {
        lib: ["es2019", "es2020.promise", "es2020.bigint", "es2020.string"],
        module: "commonjs",
        target: "es2019",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node"
      }
    };
  }
});

// ../../../node_modules/@tsconfig/node10/tsconfig.json
var require_tsconfig4 = __commonJS({
  "../../../node_modules/@tsconfig/node10/tsconfig.json"(exports2, module2) {
    module2.exports = {
      $schema: "https://json.schemastore.org/tsconfig",
      display: "Node 10",
      compilerOptions: {
        lib: ["es2018"],
        module: "commonjs",
        target: "es2018",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        moduleResolution: "node"
      }
    };
  }
});

// ../../../node_modules/ts-node/dist/tsconfigs.js
var require_tsconfigs = __commonJS({
  "../../../node_modules/ts-node/dist/tsconfigs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultTsconfigJsonForNodeVersion = void 0;
    var nodeMajor = parseInt(process.versions.node.split(".")[0], 10);
    function getDefaultTsconfigJsonForNodeVersion(ts) {
      const tsInternal = ts;
      if (nodeMajor >= 16) {
        const config = require_tsconfig();
        if (configCompatible(config))
          return config;
      }
      if (nodeMajor >= 14) {
        const config = require_tsconfig2();
        if (configCompatible(config))
          return config;
      }
      if (nodeMajor >= 12) {
        const config = require_tsconfig3();
        if (configCompatible(config))
          return config;
      }
      return require_tsconfig4();
      function configCompatible(config) {
        return typeof ts.ScriptTarget[config.compilerOptions.target.toUpperCase()] === "number" && tsInternal.libs && config.compilerOptions.lib.every((lib) => tsInternal.libs.includes(lib));
      }
    }
    exports2.getDefaultTsconfigJsonForNodeVersion = getDefaultTsconfigJsonForNodeVersion;
  }
});

// ../../../node_modules/ts-node/dist/configuration.js
var require_configuration = __commonJS({
  "../../../node_modules/ts-node/dist/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getTsConfigDefaults = exports2.ComputeAsCommonRootOfFiles = exports2.loadCompiler = exports2.resolveAndLoadCompiler = exports2.readConfig = exports2.findAndReadConfig = void 0;
    var path_1 = require("path");
    var index_1 = require_dist2();
    var ts_internals_1 = require_ts_internals();
    var tsconfigs_1 = require_tsconfigs();
    var util_1 = require_util();
    var TS_NODE_COMPILER_OPTIONS = {
      sourceMap: true,
      inlineSourceMap: false,
      inlineSources: true,
      declaration: false,
      noEmit: false,
      outDir: ".ts-node"
    };
    function fixConfig(ts, config) {
      delete config.options.out;
      delete config.options.outFile;
      delete config.options.composite;
      delete config.options.declarationDir;
      delete config.options.declarationMap;
      delete config.options.emitDeclarationOnly;
      if (config.options.target === void 0) {
        config.options.target = ts.ScriptTarget.ES5;
      }
      if (config.options.module === void 0) {
        config.options.module = ts.ModuleKind.CommonJS;
      }
      return config;
    }
    function findAndReadConfig(rawOptions) {
      var _a2, _b2, _c2, _d, _e;
      const cwd = (0, path_1.resolve)((_c2 = (_b2 = (_a2 = rawOptions.cwd) !== null && _a2 !== void 0 ? _a2 : rawOptions.dir) !== null && _b2 !== void 0 ? _b2 : index_1.DEFAULTS.cwd) !== null && _c2 !== void 0 ? _c2 : process.cwd());
      const compilerName = (_d = rawOptions.compiler) !== null && _d !== void 0 ? _d : index_1.DEFAULTS.compiler;
      let projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(void 0, rawOptions.projectSearchDir, rawOptions.project, cwd);
      let { compiler, ts } = resolveAndLoadCompiler(compilerName, projectLocalResolveDir);
      const { configFilePath, config, tsNodeOptionsFromTsconfig, optionBasePaths } = readConfig(cwd, ts, rawOptions);
      const options = (0, util_1.assign)({}, index_1.DEFAULTS, tsNodeOptionsFromTsconfig || {}, { optionBasePaths }, rawOptions);
      options.require = [
        ...tsNodeOptionsFromTsconfig.require || [],
        ...rawOptions.require || []
      ];
      if (configFilePath) {
        projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(configFilePath, rawOptions.projectSearchDir, rawOptions.project, cwd);
        ({ compiler } = resolveCompiler(options.compiler, (_e = optionBasePaths.compiler) !== null && _e !== void 0 ? _e : projectLocalResolveDir));
      }
      return {
        options,
        config,
        projectLocalResolveDir,
        optionBasePaths,
        configFilePath,
        cwd,
        compiler
      };
    }
    exports2.findAndReadConfig = findAndReadConfig;
    function readConfig(cwd, ts, rawApiOptions) {
      var _a2, _b2, _c2;
      const configChain = [];
      let config = { compilerOptions: {} };
      let basePath = cwd;
      let configFilePath = void 0;
      const projectSearchDir = (0, path_1.resolve)(cwd, (_a2 = rawApiOptions.projectSearchDir) !== null && _a2 !== void 0 ? _a2 : cwd);
      const { fileExists = ts.sys.fileExists, readFile: readFile2 = ts.sys.readFile, skipProject = index_1.DEFAULTS.skipProject, project = index_1.DEFAULTS.project, tsTrace = index_1.DEFAULTS.tsTrace } = rawApiOptions;
      if (!skipProject) {
        if (project) {
          const resolved = (0, path_1.resolve)(cwd, project);
          const nested = (0, path_1.join)(resolved, "tsconfig.json");
          configFilePath = fileExists(nested) ? nested : resolved;
        } else {
          configFilePath = ts.findConfigFile(projectSearchDir, fileExists);
        }
        if (configFilePath) {
          let pathToNextConfigInChain = configFilePath;
          const tsInternals = (0, ts_internals_1.createTsInternals)(ts);
          const errors = [];
          while (true) {
            const result = ts.readConfigFile(pathToNextConfigInChain, readFile2);
            if (result.error) {
              return {
                configFilePath,
                config: { errors: [result.error], fileNames: [], options: {} },
                tsNodeOptionsFromTsconfig: {},
                optionBasePaths: {}
              };
            }
            const c = result.config;
            const bp = (0, path_1.dirname)(pathToNextConfigInChain);
            configChain.push({
              config: c,
              basePath: bp,
              configPath: pathToNextConfigInChain
            });
            if (c.extends == null)
              break;
            const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(c.extends, {
              fileExists,
              readDirectory: ts.sys.readDirectory,
              readFile: readFile2,
              useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,
              trace: tsTrace
            }, bp, errors, ts.createCompilerDiagnostic);
            if (errors.length) {
              return {
                configFilePath,
                config: { errors, fileNames: [], options: {} },
                tsNodeOptionsFromTsconfig: {},
                optionBasePaths: {}
              };
            }
            if (resolvedExtendedConfigPath == null)
              break;
            pathToNextConfigInChain = resolvedExtendedConfigPath;
          }
          ({ config, basePath } = configChain[0]);
        }
      }
      const tsNodeOptionsFromTsconfig = {};
      const optionBasePaths = {};
      for (let i = configChain.length - 1; i >= 0; i--) {
        const { config: config2, basePath: basePath2, configPath } = configChain[i];
        const options = filterRecognizedTsConfigTsNodeOptions(config2["ts-node"]).recognized;
        if (options.require) {
          const tsconfigRelativeResolver = (0, util_1.createProjectLocalResolveHelper)((0, path_1.dirname)(configPath));
          options.require = options.require.map((path5) => tsconfigRelativeResolver(path5, false));
        }
        if (options.scopeDir) {
          options.scopeDir = (0, path_1.resolve)(basePath2, options.scopeDir);
        }
        if (options.moduleTypes) {
          optionBasePaths.moduleTypes = basePath2;
        }
        if (options.transpiler != null) {
          optionBasePaths.transpiler = basePath2;
        }
        if (options.compiler != null) {
          optionBasePaths.compiler = basePath2;
        }
        if (options.swc != null) {
          optionBasePaths.swc = basePath2;
        }
        (0, util_1.assign)(tsNodeOptionsFromTsconfig, options);
      }
      const files = (_c2 = (_b2 = rawApiOptions.files) !== null && _b2 !== void 0 ? _b2 : tsNodeOptionsFromTsconfig.files) !== null && _c2 !== void 0 ? _c2 : index_1.DEFAULTS.files;
      const skipDefaultCompilerOptions = configFilePath != null;
      const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions ? void 0 : {
        ...(0, tsconfigs_1.getDefaultTsconfigJsonForNodeVersion)(ts).compilerOptions,
        types: ["node"]
      };
      config.compilerOptions = Object.assign(
        {},
        // automatically-applied options from @tsconfig/bases
        defaultCompilerOptionsForNodeVersion,
        // tsconfig.json "compilerOptions"
        config.compilerOptions,
        // from env var
        index_1.DEFAULTS.compilerOptions,
        // tsconfig.json "ts-node": "compilerOptions"
        tsNodeOptionsFromTsconfig.compilerOptions,
        // passed programmatically
        rawApiOptions.compilerOptions,
        // overrides required by ts-node, cannot be changed
        TS_NODE_COMPILER_OPTIONS
      );
      const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {
        fileExists,
        readFile: readFile2,
        // Only used for globbing "files", "include", "exclude"
        // When `files` option disabled, we want to avoid the fs calls
        readDirectory: files ? ts.sys.readDirectory : () => [],
        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames
      }, basePath, void 0, configFilePath));
      return {
        configFilePath,
        config: fixedConfig,
        tsNodeOptionsFromTsconfig,
        optionBasePaths
      };
    }
    exports2.readConfig = readConfig;
    function resolveAndLoadCompiler(name, relativeToPath) {
      const { compiler } = resolveCompiler(name, relativeToPath);
      const ts = loadCompiler(compiler);
      return { compiler, ts };
    }
    exports2.resolveAndLoadCompiler = resolveAndLoadCompiler;
    function resolveCompiler(name, relativeToPath) {
      const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(relativeToPath);
      const compiler = projectLocalResolveHelper(name || "typescript", true);
      return { compiler };
    }
    function loadCompiler(compiler) {
      return (0, util_1.attemptRequireWithV8CompileCache)(require, compiler);
    }
    exports2.loadCompiler = loadCompiler;
    function filterRecognizedTsConfigTsNodeOptions(jsonObject) {
      if (jsonObject == null)
        return { recognized: {}, unrecognized: {} };
      const { compiler, compilerHost, compilerOptions, emit, files, ignore, ignoreDiagnostics, logError, preferTsExts, pretty, require: require2, skipIgnore, transpileOnly, typeCheck, transpiler, scope, scopeDir, moduleTypes, experimentalReplAwait, swc, experimentalResolver, esm, experimentalSpecifierResolution, experimentalTsImportSpecifiers, ...unrecognized } = jsonObject;
      const filteredTsConfigOptions = {
        compiler,
        compilerHost,
        compilerOptions,
        emit,
        experimentalReplAwait,
        files,
        ignore,
        ignoreDiagnostics,
        logError,
        preferTsExts,
        pretty,
        require: require2,
        skipIgnore,
        transpileOnly,
        typeCheck,
        transpiler,
        scope,
        scopeDir,
        moduleTypes,
        swc,
        experimentalResolver,
        esm,
        experimentalSpecifierResolution,
        experimentalTsImportSpecifiers
      };
      const catchExtraneousProps = null;
      const catchMissingProps = null;
      return { recognized: filteredTsConfigOptions, unrecognized };
    }
    exports2.ComputeAsCommonRootOfFiles = Symbol();
    function getTsConfigDefaults(config, basePath, _files, _include, _exclude) {
      const { composite = false } = config.options;
      let rootDir = config.options.rootDir;
      if (rootDir == null) {
        if (composite)
          rootDir = basePath;
        else
          rootDir = exports2.ComputeAsCommonRootOfFiles;
      }
      const { outDir = rootDir } = config.options;
      const include = _files ? [] : ["**/*"];
      const files = _files !== null && _files !== void 0 ? _files : [];
      const exclude = _exclude !== null && _exclude !== void 0 ? _exclude : [outDir];
      return { rootDir, outDir, include, files, exclude, composite };
    }
    exports2.getTsConfigDefaults = getTsConfigDefaults;
  }
});

// ../../../node_modules/ts-node/dist/module-type-classifier.js
var require_module_type_classifier = __commonJS({
  "../../../node_modules/ts-node/dist/module-type-classifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createModuleTypeClassifier = void 0;
    var ts_internals_1 = require_ts_internals();
    var util_1 = require_util();
    function createModuleTypeClassifier(options) {
      const { patterns, basePath: _basePath } = options;
      const basePath = _basePath !== void 0 ? (0, util_1.normalizeSlashes)(_basePath).replace(/\/$/, "") : void 0;
      const patternTypePairs = Object.entries(patterns !== null && patterns !== void 0 ? patterns : []).map(([_pattern, type]) => {
        const pattern = (0, util_1.normalizeSlashes)(_pattern);
        return { pattern: parsePattern(basePath, pattern), type };
      });
      const classifications = {
        package: {
          moduleType: "auto"
        },
        cjs: {
          moduleType: "cjs"
        },
        esm: {
          moduleType: "esm"
        }
      };
      const auto = classifications.package;
      function classifyModuleNonCached(path5) {
        const matched = matchPatterns(patternTypePairs, (_) => _.pattern, path5);
        if (matched)
          return classifications[matched.type];
        return auto;
      }
      const classifyModule = (0, util_1.cachedLookup)(classifyModuleNonCached);
      function classifyModuleAuto(path5) {
        return auto;
      }
      return {
        classifyModuleByModuleTypeOverrides: patternTypePairs.length ? classifyModule : classifyModuleAuto
      };
    }
    exports2.createModuleTypeClassifier = createModuleTypeClassifier;
    function parsePattern(basePath, patternString) {
      const pattern = (0, ts_internals_1.getPatternFromSpec)(patternString, basePath);
      return pattern !== void 0 ? new RegExp(pattern) : /(?:)/;
    }
    function matchPatterns(objects, getPattern, candidate) {
      for (let i = objects.length - 1; i >= 0; i--) {
        const object = objects[i];
        const pattern = getPattern(object);
        if (pattern === null || pattern === void 0 ? void 0 : pattern.test(candidate)) {
          return object;
        }
      }
    }
  }
});

// ../../../node_modules/ts-node/dist/resolver-functions.js
var require_resolver_functions = __commonJS({
  "../../../node_modules/ts-node/dist/resolver-functions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createResolverFunctions = void 0;
    var path_1 = require("path");
    function createResolverFunctions(kwargs) {
      const { host, ts, config, cwd, getCanonicalFileName, projectLocalResolveHelper, options, extensions } = kwargs;
      const moduleResolutionCache = ts.createModuleResolutionCache(cwd, getCanonicalFileName, config.options);
      const knownInternalFilenames = /* @__PURE__ */ new Set();
      const internalBuckets = /* @__PURE__ */ new Set();
      const moduleBucketRe = /.*\/node_modules\/(?:@[^\/]+\/)?[^\/]+\//;
      function getModuleBucket(filename) {
        const find = moduleBucketRe.exec(filename);
        if (find)
          return find[0];
        return "";
      }
      function markBucketOfFilenameInternal(filename) {
        internalBuckets.add(getModuleBucket(filename));
      }
      function isFileInInternalBucket(filename) {
        return internalBuckets.has(getModuleBucket(filename));
      }
      function isFileKnownToBeInternal(filename) {
        return knownInternalFilenames.has(filename);
      }
      const fixupResolvedModule = (resolvedModule) => {
        const { resolvedFileName } = resolvedModule;
        if (resolvedFileName === void 0)
          return;
        if (resolvedModule.isExternalLibraryImport && (resolvedFileName.endsWith(".ts") && !resolvedFileName.endsWith(".d.ts") || resolvedFileName.endsWith(".cts") && !resolvedFileName.endsWith(".d.cts") || resolvedFileName.endsWith(".mts") && !resolvedFileName.endsWith(".d.mts") || isFileKnownToBeInternal(resolvedFileName) || isFileInInternalBucket(resolvedFileName))) {
          resolvedModule.isExternalLibraryImport = false;
        }
        if (!resolvedModule.isExternalLibraryImport) {
          knownInternalFilenames.add(resolvedFileName);
        }
      };
      const resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, optionsOnlyWithNewerTsVersions, containingSourceFile) => {
        return moduleNames.map((moduleName, i) => {
          var _a2, _b2;
          const mode = containingSourceFile ? (_b2 = (_a2 = ts).getModeForResolutionAtIndex) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, containingSourceFile, i) : void 0;
          let { resolvedModule } = ts.resolveModuleName(moduleName, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode);
          if (!resolvedModule && options.experimentalTsImportSpecifiers) {
            const lastDotIndex = moduleName.lastIndexOf(".");
            const ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : "";
            if (ext) {
              const replacements = extensions.tsResolverEquivalents.get(ext);
              for (const replacementExt of replacements !== null && replacements !== void 0 ? replacements : []) {
                ({ resolvedModule } = ts.resolveModuleName(moduleName.slice(0, -ext.length) + replacementExt, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode));
                if (resolvedModule)
                  break;
              }
            }
          }
          if (resolvedModule) {
            fixupResolvedModule(resolvedModule);
          }
          return resolvedModule;
        });
      };
      const getResolvedModuleWithFailedLookupLocationsFromCache = (moduleName, containingFile, resolutionMode) => {
        const ret = ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache, resolutionMode);
        if (ret && ret.resolvedModule) {
          fixupResolvedModule(ret.resolvedModule);
        }
        return ret;
      };
      const resolveTypeReferenceDirectives = (typeDirectiveNames, containingFile, redirectedReference, options2, containingFileMode) => {
        return typeDirectiveNames.map((typeDirectiveName) => {
          const nameIsString = typeof typeDirectiveName === "string";
          const mode = nameIsString ? void 0 : ts.getModeForFileReference(typeDirectiveName, containingFileMode);
          const strName = nameIsString ? typeDirectiveName : typeDirectiveName.fileName.toLowerCase();
          let { resolvedTypeReferenceDirective } = ts.resolveTypeReferenceDirective(strName, containingFile, config.options, host, redirectedReference, void 0, mode);
          if (typeDirectiveName === "node" && !resolvedTypeReferenceDirective) {
            let typesNodePackageJsonPath;
            try {
              typesNodePackageJsonPath = projectLocalResolveHelper("@types/node/package.json", true);
            } catch {
            }
            if (typesNodePackageJsonPath) {
              const typeRoots = [(0, path_1.resolve)(typesNodePackageJsonPath, "../..")];
              ({ resolvedTypeReferenceDirective } = ts.resolveTypeReferenceDirective(typeDirectiveName, containingFile, {
                ...config.options,
                typeRoots
              }, host, redirectedReference));
            }
          }
          if (resolvedTypeReferenceDirective) {
            fixupResolvedModule(resolvedTypeReferenceDirective);
          }
          return resolvedTypeReferenceDirective;
        });
      };
      return {
        resolveModuleNames,
        getResolvedModuleWithFailedLookupLocationsFromCache,
        resolveTypeReferenceDirectives,
        isFileKnownToBeInternal,
        markBucketOfFilenameInternal
      };
    }
    exports2.createResolverFunctions = createResolverFunctions;
  }
});

// ../../../node_modules/ts-node/dist/cjs-resolve-hooks.js
var require_cjs_resolve_hooks = __commonJS({
  "../../../node_modules/ts-node/dist/cjs-resolve-hooks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.installCommonjsResolveHooksIfNecessary = void 0;
    function installCommonjsResolveHooksIfNecessary(tsNodeService) {
      const Module = require("module");
      const originalResolveFilename = Module._resolveFilename;
      const originalFindPath = Module._findPath;
      const shouldInstallHook = tsNodeService.options.experimentalResolver;
      if (shouldInstallHook) {
        let _resolveFilename = function(request, parent, isMain, options, ...rest) {
          if (!tsNodeService.enabled())
            return originalResolveFilename.call(this, request, parent, isMain, options, ...rest);
          return Module_resolveFilename.call(this, request, parent, isMain, options, ...rest);
        }, _findPath = function() {
          if (!tsNodeService.enabled())
            return originalFindPath.apply(this, arguments);
          return Module_findPath.apply(this, arguments);
        };
        const { Module_findPath, Module_resolveFilename } = tsNodeService.getNodeCjsLoader();
        Module._resolveFilename = _resolveFilename;
        Module._findPath = _findPath;
      }
    }
    exports2.installCommonjsResolveHooksIfNecessary = installCommonjsResolveHooksIfNecessary;
  }
});

// ../../../node_modules/ts-node/dist-raw/node-primordials.js
var require_node_primordials = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-primordials.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ArrayFrom: Array.from,
      ArrayIsArray: Array.isArray,
      ArrayPrototypeShift: (obj) => Array.prototype.shift.call(obj),
      ArrayPrototypeForEach: (arr, ...rest) => Array.prototype.forEach.apply(arr, rest),
      ArrayPrototypeIncludes: (arr, ...rest) => Array.prototype.includes.apply(arr, rest),
      ArrayPrototypeJoin: (arr, ...rest) => Array.prototype.join.apply(arr, rest),
      ArrayPrototypePop: (arr, ...rest) => Array.prototype.pop.apply(arr, rest),
      ArrayPrototypePush: (arr, ...rest) => Array.prototype.push.apply(arr, rest),
      FunctionPrototype: Function.prototype,
      JSONParse: JSON.parse,
      JSONStringify: JSON.stringify,
      ObjectFreeze: Object.freeze,
      ObjectKeys: Object.keys,
      ObjectGetOwnPropertyNames: Object.getOwnPropertyNames,
      ObjectDefineProperty: Object.defineProperty,
      ObjectPrototypeHasOwnProperty: (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop),
      RegExpPrototypeExec: (obj, string) => RegExp.prototype.exec.call(obj, string),
      RegExpPrototypeTest: (obj, string) => RegExp.prototype.test.call(obj, string),
      RegExpPrototypeSymbolReplace: (obj, ...rest) => RegExp.prototype[Symbol.replace].apply(obj, rest),
      SafeMap: Map,
      SafeSet: Set,
      SafeWeakMap: WeakMap,
      StringPrototypeEndsWith: (str, ...rest) => String.prototype.endsWith.apply(str, rest),
      StringPrototypeIncludes: (str, ...rest) => String.prototype.includes.apply(str, rest),
      StringPrototypeLastIndexOf: (str, ...rest) => String.prototype.lastIndexOf.apply(str, rest),
      StringPrototypeIndexOf: (str, ...rest) => String.prototype.indexOf.apply(str, rest),
      StringPrototypeRepeat: (str, ...rest) => String.prototype.repeat.apply(str, rest),
      StringPrototypeReplace: (str, ...rest) => String.prototype.replace.apply(str, rest),
      StringPrototypeSlice: (str, ...rest) => String.prototype.slice.apply(str, rest),
      StringPrototypeSplit: (str, ...rest) => String.prototype.split.apply(str, rest),
      StringPrototypeStartsWith: (str, ...rest) => String.prototype.startsWith.apply(str, rest),
      StringPrototypeSubstr: (str, ...rest) => String.prototype.substr.apply(str, rest),
      StringPrototypeCharCodeAt: (str, ...rest) => String.prototype.charCodeAt.apply(str, rest),
      StringPrototypeMatch: (str, ...rest) => String.prototype.match.apply(str, rest),
      SyntaxError
    };
  }
});

// ../../../node_modules/ts-node/dist-raw/node-nativemodule.js
var require_node_nativemodule = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-nativemodule.js"(exports2) {
    "use strict";
    var Module = require("module");
    var NativeModule = {
      canBeRequiredByUsers(specifier) {
        return Module.builtinModules.includes(specifier);
      }
    };
    exports2.NativeModule = NativeModule;
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internalBinding-fs.js
var require_node_internalBinding_fs = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internalBinding-fs.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var { versionGteLt } = require_util();
    function internalModuleReadJSON(path5) {
      let string;
      try {
        string = fs.readFileSync(path5, "utf8");
      } catch (e) {
        if (e.code === "ENOENT")
          return [];
        throw e;
      }
      const containsKeys = true;
      return [string, containsKeys];
    }
    function internalModuleStat(path5) {
      const stat = fs.statSync(path5, { throwIfNoEntry: false });
      if (!stat)
        return -1;
      if (stat.isFile())
        return 0;
      if (stat.isDirectory())
        return 1;
    }
    function internalModuleStatInefficient(path5) {
      try {
        const stat = fs.statSync(path5);
        if (stat.isFile())
          return 0;
        if (stat.isDirectory())
          return 1;
      } catch (e) {
        return -e.errno || -1;
      }
    }
    var statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, "15.3.0") || versionGteLt(process.versions.node, "14.17.0", "15.0.0");
    module2.exports = {
      internalModuleReadJSON,
      internalModuleStat: statSupportsThrowIfNoEntry ? internalModuleStat : internalModuleStatInefficient
    };
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internal-modules-package_json_reader.js
var require_node_internal_modules_package_json_reader = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internal-modules-package_json_reader.js"(exports2, module2) {
    "use strict";
    var { SafeMap } = require_node_primordials();
    var { internalModuleReadJSON } = require_node_internalBinding_fs();
    var { pathToFileURL } = require("url");
    var { toNamespacedPath } = require("path");
    var cache = new SafeMap();
    var manifest;
    function read(jsonPath) {
      if (cache.has(jsonPath)) {
        return cache.get(jsonPath);
      }
      const [string, containsKeys] = internalModuleReadJSON(
        toNamespacedPath(jsonPath)
      );
      const result = { string, containsKeys };
      if (string !== void 0) {
        if (manifest === void 0) {
          manifest = null;
        }
        if (manifest !== null) {
          const jsonURL = pathToFileURL(jsonPath);
          manifest.assertIntegrity(jsonURL, string);
        }
      }
      cache.set(jsonPath, result);
      return result;
    }
    module2.exports = { read };
  }
});

// ../../../node_modules/ts-node/node_modules/arg/index.js
var require_arg = __commonJS({
  "../../../node_modules/ts-node/node_modules/arg/index.js"(exports2, module2) {
    "use strict";
    var flagSymbol = Symbol("arg flag");
    function arg(opts, { argv: argv2 = process.argv.slice(2), permissive = false, stopAtPositional = false } = {}) {
      if (!opts) {
        throw new Error("Argument specification object is required");
      }
      const result = { _: [] };
      const aliases = {};
      const handlers = {};
      for (const key of Object.keys(opts)) {
        if (!key) {
          throw new TypeError("Argument key cannot be an empty string");
        }
        if (key[0] !== "-") {
          throw new TypeError(`Argument key must start with '-' but found: '${key}'`);
        }
        if (key.length === 1) {
          throw new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${key}`);
        }
        if (typeof opts[key] === "string") {
          aliases[key] = opts[key];
          continue;
        }
        let type = opts[key];
        let isFlag = false;
        if (Array.isArray(type) && type.length === 1 && typeof type[0] === "function") {
          const [fn] = type;
          type = (value2, name, prev = []) => {
            prev.push(fn(value2, name, prev[prev.length - 1]));
            return prev;
          };
          isFlag = fn === Boolean || fn[flagSymbol] === true;
        } else if (typeof type === "function") {
          isFlag = type === Boolean || type[flagSymbol] === true;
        } else {
          throw new TypeError(`Type missing or not a function or valid array type: ${key}`);
        }
        if (key[1] !== "-" && key.length > 2) {
          throw new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${key}`);
        }
        handlers[key] = [type, isFlag];
      }
      for (let i = 0, len = argv2.length; i < len; i++) {
        const wholeArg = argv2[i];
        if (stopAtPositional && result._.length > 0) {
          result._ = result._.concat(argv2.slice(i));
          break;
        }
        if (wholeArg === "--") {
          result._ = result._.concat(argv2.slice(i + 1));
          break;
        }
        if (wholeArg.length > 1 && wholeArg[0] === "-") {
          const separatedArguments = wholeArg[1] === "-" || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split("").map((a) => `-${a}`);
          for (let j = 0; j < separatedArguments.length; j++) {
            const arg2 = separatedArguments[j];
            const [originalArgName, argStr] = arg2[1] === "-" ? arg2.split(/=(.*)/, 2) : [arg2, void 0];
            let argName = originalArgName;
            while (argName in aliases) {
              argName = aliases[argName];
            }
            if (!(argName in handlers)) {
              if (permissive) {
                result._.push(arg2);
                continue;
              } else {
                const err = new Error(`Unknown or unexpected option: ${originalArgName}`);
                err.code = "ARG_UNKNOWN_OPTION";
                throw err;
              }
            }
            const [type, isFlag] = handlers[argName];
            if (!isFlag && j + 1 < separatedArguments.length) {
              throw new TypeError(`Option requires argument (but was followed by another short argument): ${originalArgName}`);
            }
            if (isFlag) {
              result[argName] = type(true, argName, result[argName]);
            } else if (argStr === void 0) {
              if (argv2.length < i + 2 || argv2[i + 1].length > 1 && argv2[i + 1][0] === "-" && !(argv2[i + 1].match(/^-?\d*(\.(?=\d))?\d*$/) && (type === Number || // eslint-disable-next-line no-undef
              typeof BigInt !== "undefined" && type === BigInt))) {
                const extended = originalArgName === argName ? "" : ` (alias for ${argName})`;
                throw new Error(`Option requires argument: ${originalArgName}${extended}`);
              }
              result[argName] = type(argv2[i + 1], argName, result[argName]);
              ++i;
            } else {
              result[argName] = type(argStr, argName, result[argName]);
            }
          }
        } else {
          result._.push(wholeArg);
        }
      }
      return result;
    }
    arg.flag = (fn) => {
      fn[flagSymbol] = true;
      return fn;
    };
    arg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);
    module2.exports = arg;
  }
});

// ../../../node_modules/ts-node/dist-raw/node-options.js
var require_node_options = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-options.js"(exports2) {
    "use strict";
    exports2.getOptionValue = getOptionValue;
    function getOptionValue(opt) {
      parseOptions();
      return options[opt];
    }
    var options;
    function parseOptions() {
      if (!options) {
        options = {
          "--preserve-symlinks": false,
          "--preserve-symlinks-main": false,
          "--input-type": void 0,
          "--experimental-specifier-resolution": "explicit",
          "--experimental-policy": void 0,
          "--conditions": [],
          "--pending-deprecation": false,
          ...parseArgv(getNodeOptionsEnvArgv()),
          ...parseArgv(process.execArgv),
          ...getOptionValuesFromOtherEnvVars()
        };
      }
    }
    function parseArgv(argv2) {
      return require_arg()({
        "--preserve-symlinks": Boolean,
        "--preserve-symlinks-main": Boolean,
        "--input-type": String,
        "--experimental-specifier-resolution": String,
        // Legacy alias for node versions prior to 12.16
        "--es-module-specifier-resolution": "--experimental-specifier-resolution",
        "--experimental-policy": String,
        "--conditions": [String],
        "--pending-deprecation": Boolean,
        "--experimental-json-modules": Boolean,
        "--experimental-wasm-modules": Boolean
      }, {
        argv: argv2,
        permissive: true
      });
    }
    function getNodeOptionsEnvArgv() {
      const errors = [];
      const envArgv = ParseNodeOptionsEnvVar(process.env.NODE_OPTIONS || "", errors);
      if (errors.length !== 0) {
      }
      return envArgv;
    }
    function ParseNodeOptionsEnvVar(node_options, errors) {
      const env_argv = [];
      let is_in_string = false;
      let will_start_new_arg = true;
      for (let index = 0; index < node_options.length; ++index) {
        let c = node_options[index];
        if (c === "\\" && is_in_string) {
          if (index + 1 === node_options.length) {
            errors.push("invalid value for NODE_OPTIONS (invalid escape)\n");
            return env_argv;
          } else {
            c = node_options[++index];
          }
        } else if (c === " " && !is_in_string) {
          will_start_new_arg = true;
          continue;
        } else if (c === '"') {
          is_in_string = !is_in_string;
          continue;
        }
        if (will_start_new_arg) {
          env_argv.push(c);
          will_start_new_arg = false;
        } else {
          env_argv[env_argv.length - 1] += c;
        }
      }
      if (is_in_string) {
        errors.push("invalid value for NODE_OPTIONS (unterminated string)\n");
      }
      return env_argv;
    }
    function getOptionValuesFromOtherEnvVars() {
      const options2 = {};
      if (process.env.NODE_PENDING_DEPRECATION === "1") {
        options2["--pending-deprecation"] = true;
      }
      return options2;
    }
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internal-modules-cjs-helpers.js
var require_node_internal_modules_cjs_helpers = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internal-modules-cjs-helpers.js"(exports2) {
    "use strict";
    var {
      ArrayPrototypeForEach,
      ObjectDefineProperty,
      ObjectPrototypeHasOwnProperty,
      SafeSet,
      StringPrototypeIncludes,
      StringPrototypeStartsWith
    } = require_node_primordials();
    var { getOptionValue } = require_node_options();
    var userConditions = getOptionValue("--conditions");
    var noAddons = getOptionValue("--no-addons");
    var addonConditions = noAddons ? [] : ["node-addons"];
    var cjsConditions = new SafeSet([
      "require",
      "node",
      ...addonConditions,
      ...userConditions
    ]);
    function addBuiltinLibsToObject(object, dummyModuleName) {
      const Module = require("module").Module;
      const { builtinModules } = Module;
      const dummyModule = new Module(dummyModuleName);
      ArrayPrototypeForEach(builtinModules, (name) => {
        if (StringPrototypeStartsWith(name, "_") || StringPrototypeIncludes(name, "/") || ObjectPrototypeHasOwnProperty(object, name)) {
          return;
        }
        const setReal = (val) => {
          delete object[name];
          object[name] = val;
        };
        ObjectDefineProperty(object, name, {
          get: () => {
            const lib = (dummyModule.require || require)(name);
            delete object[name];
            ObjectDefineProperty(object, name, {
              get: () => lib,
              set: setReal,
              configurable: true,
              enumerable: false
            });
            return lib;
          },
          set: setReal,
          configurable: true,
          enumerable: false
        });
      });
    }
    exports2.addBuiltinLibsToObject = addBuiltinLibsToObject;
    exports2.cjsConditions = cjsConditions;
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internal-errors.js
var require_node_internal_errors = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internal-errors.js"(exports2) {
    "use strict";
    var path5 = require("path");
    exports2.codes = {
      ERR_INPUT_TYPE_NOT_ALLOWED: createErrorCtor(joinArgs("ERR_INPUT_TYPE_NOT_ALLOWED")),
      ERR_INVALID_ARG_VALUE: createErrorCtor(joinArgs("ERR_INVALID_ARG_VALUE")),
      ERR_INVALID_MODULE_SPECIFIER: createErrorCtor(joinArgs("ERR_INVALID_MODULE_SPECIFIER")),
      ERR_INVALID_PACKAGE_CONFIG: createErrorCtor(joinArgs("ERR_INVALID_PACKAGE_CONFIG")),
      ERR_INVALID_PACKAGE_TARGET: createErrorCtor(joinArgs("ERR_INVALID_PACKAGE_TARGET")),
      ERR_MANIFEST_DEPENDENCY_MISSING: createErrorCtor(joinArgs("ERR_MANIFEST_DEPENDENCY_MISSING")),
      ERR_MODULE_NOT_FOUND: createErrorCtor((path6, base, type = "package") => {
        return `Cannot find ${type} '${path6}' imported from ${base}`;
      }),
      ERR_PACKAGE_IMPORT_NOT_DEFINED: createErrorCtor(joinArgs("ERR_PACKAGE_IMPORT_NOT_DEFINED")),
      ERR_PACKAGE_PATH_NOT_EXPORTED: createErrorCtor(joinArgs("ERR_PACKAGE_PATH_NOT_EXPORTED")),
      ERR_UNSUPPORTED_DIR_IMPORT: createErrorCtor(joinArgs("ERR_UNSUPPORTED_DIR_IMPORT")),
      ERR_UNSUPPORTED_ESM_URL_SCHEME: createErrorCtor(joinArgs("ERR_UNSUPPORTED_ESM_URL_SCHEME")),
      ERR_UNKNOWN_FILE_EXTENSION: createErrorCtor(joinArgs("ERR_UNKNOWN_FILE_EXTENSION"))
    };
    function joinArgs(name) {
      return (...args5) => {
        return [name, ...args5].join(" ");
      };
    }
    function createErrorCtor(errorMessageCreator) {
      return class CustomError extends Error {
        constructor(...args5) {
          super(errorMessageCreator(...args5));
        }
      };
    }
    exports2.createErrRequireEsm = createErrRequireEsm;
    function createErrRequireEsm(filename, parentPath, packageJsonPath) {
      const code = "ERR_REQUIRE_ESM";
      const err = new Error(getErrRequireEsmMessage(filename, parentPath, packageJsonPath));
      err.name = `Error [${code}]`;
      err.stack;
      Object.defineProperty(err, "name", {
        value: "Error",
        enumerable: false,
        writable: true,
        configurable: true
      });
      err.code = code;
      return err;
    }
    function getErrRequireEsmMessage(filename, parentPath = null, packageJsonPath = null) {
      const ext = path5.extname(filename);
      let msg = `Must use import to load ES Module: ${filename}`;
      if (parentPath && packageJsonPath) {
        const path6 = require("path");
        const basename2 = path6.basename(filename) === path6.basename(parentPath) ? filename : path6.basename(filename);
        msg += `
require() of ES modules is not supported.
require() of ${filename} ${parentPath ? `from ${parentPath} ` : ""}is an ES module file as it is a ${ext} file whose nearest parent package.json contains "type": "module" which defines all ${ext} files in that package scope as ES modules.
Instead change the requiring code to use import(), or remove "type": "module" from ${packageJsonPath}.
`;
        return msg;
      }
      return msg;
    }
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internal-constants.js
var require_node_internal_constants = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internal-constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      CHAR_FORWARD_SLASH: 47
      /* / */
    };
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internal-modules-cjs-loader.js
var require_node_internal_modules_cjs_loader = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internal-modules-cjs-loader.js"(exports2, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypePush,
      JSONParse,
      ObjectKeys,
      RegExpPrototypeTest,
      SafeMap,
      SafeWeakMap,
      StringPrototypeCharCodeAt,
      StringPrototypeEndsWith,
      StringPrototypeLastIndexOf,
      StringPrototypeIndexOf,
      StringPrototypeMatch,
      StringPrototypeSlice,
      StringPrototypeStartsWith
    } = require_node_primordials();
    var { NativeModule } = require_node_nativemodule();
    var { pathToFileURL, fileURLToPath } = require("url");
    var fs = require("fs");
    var path5 = require("path");
    var { sep } = path5;
    var { internalModuleStat } = require_node_internalBinding_fs();
    var packageJsonReader = require_node_internal_modules_package_json_reader();
    var {
      cjsConditions
    } = require_node_internal_modules_cjs_helpers();
    var { getOptionValue } = require_node_options();
    var preserveSymlinks = getOptionValue("--preserve-symlinks");
    var preserveSymlinksMain = getOptionValue("--preserve-symlinks-main");
    var { normalizeSlashes } = require_util();
    var { createErrRequireEsm } = require_node_internal_errors();
    var {
      codes: {
        ERR_INVALID_MODULE_SPECIFIER
      }
    } = require_node_internal_errors();
    var {
      CHAR_FORWARD_SLASH
    } = require_node_internal_constants();
    var Module = require("module");
    var isWindows = process.platform === "win32";
    var statCache = null;
    function stat(filename) {
      filename = path5.toNamespacedPath(filename);
      if (statCache !== null) {
        const result2 = statCache.get(filename);
        if (result2 !== void 0)
          return result2;
      }
      const result = internalModuleStat(filename);
      if (statCache !== null && result >= 0) {
        statCache.set(filename, result);
      }
      return result;
    }
    var moduleParentCache = new SafeWeakMap();
    var packageJsonCache = new SafeMap();
    function readPackage(requestPath) {
      const jsonPath = path5.resolve(requestPath, "package.json");
      const existing = packageJsonCache.get(jsonPath);
      if (existing !== void 0)
        return existing;
      const result = packageJsonReader.read(jsonPath);
      const json = result.containsKeys === false ? "{}" : result.string;
      if (json === void 0) {
        packageJsonCache.set(jsonPath, false);
        return false;
      }
      try {
        const parsed = JSONParse(json);
        const filtered = {
          name: parsed.name,
          main: parsed.main,
          exports: parsed.exports,
          imports: parsed.imports,
          type: parsed.type
        };
        packageJsonCache.set(jsonPath, filtered);
        return filtered;
      } catch (e) {
        e.path = jsonPath;
        e.message = "Error parsing " + jsonPath + ": " + e.message;
        throw e;
      }
    }
    function readPackageScope(checkPath) {
      const rootSeparatorIndex = StringPrototypeIndexOf(checkPath, sep);
      let separatorIndex;
      do {
        separatorIndex = StringPrototypeLastIndexOf(checkPath, sep);
        checkPath = StringPrototypeSlice(checkPath, 0, separatorIndex);
        if (StringPrototypeEndsWith(checkPath, sep + "node_modules"))
          return false;
        const pjson = readPackage(checkPath + sep);
        if (pjson)
          return {
            data: pjson,
            path: checkPath
          };
      } while (separatorIndex > rootSeparatorIndex);
      return false;
    }
    function createCjsLoader(opts) {
      const { nodeEsmResolver, preferTsExts } = opts;
      const { replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx } = opts.extensions;
      const {
        encodedSepRegEx,
        packageExportsResolve,
        packageImportsResolve
      } = nodeEsmResolver;
      function tryPackage(requestPath, exts, isMain, originalPath) {
        const tmp = readPackage(requestPath);
        const pkg = tmp != null ? tmp.main : void 0;
        if (!pkg) {
          return tryExtensions(path5.resolve(requestPath, "index"), exts, isMain);
        }
        const filename = path5.resolve(requestPath, pkg);
        let actual = tryReplacementExtensions(filename, isMain) || tryFile(filename, isMain) || tryExtensions(filename, exts, isMain) || tryExtensions(path5.resolve(filename, "index"), exts, isMain);
        if (actual === false) {
          actual = tryExtensions(path5.resolve(requestPath, "index"), exts, isMain);
          if (!actual) {
            const err = new Error(
              `Cannot find module '${filename}'. Please verify that the package.json has a valid "main" entry`
            );
            err.code = "MODULE_NOT_FOUND";
            err.path = path5.resolve(requestPath, "package.json");
            err.requestPath = originalPath;
            throw err;
          } else {
            const jsonPath = path5.resolve(requestPath, "package.json");
            process.emitWarning(
              `Invalid 'main' field in '${jsonPath}' of '${pkg}'. Please either fix that or report it to the module author`,
              "DeprecationWarning",
              "DEP0128"
            );
          }
        }
        return actual;
      }
      const realpathCache = new SafeMap();
      function tryFile(requestPath, isMain) {
        const rc = stat(requestPath);
        if (rc !== 0)
          return;
        if (preserveSymlinks && !isMain) {
          return path5.resolve(requestPath);
        }
        return toRealPath(requestPath);
      }
      function toRealPath(requestPath) {
        return fs.realpathSync(requestPath, {
          // [internalFS.realpathCacheKey]: realpathCache
        });
      }
      function statReplacementExtensions(p) {
        const lastDotIndex = p.lastIndexOf(".");
        if (lastDotIndex >= 0) {
          const ext = p.slice(lastDotIndex);
          if (ext === ".js" || ext === ".jsx" || ext === ".mjs" || ext === ".cjs") {
            const pathnameWithoutExtension = p.slice(0, lastDotIndex);
            const replacementExts = ext === ".js" ? replacementsForJs : ext === ".jsx" ? replacementsForJsx : ext === ".mjs" ? replacementsForMjs : replacementsForCjs;
            for (let i = 0; i < replacementExts.length; i++) {
              const filename = pathnameWithoutExtension + replacementExts[i];
              const rc = stat(filename);
              if (rc === 0) {
                return [rc, filename];
              }
            }
          }
        }
        return [stat(p), p];
      }
      function tryReplacementExtensions(p, isMain) {
        const lastDotIndex = p.lastIndexOf(".");
        if (lastDotIndex >= 0) {
          const ext = p.slice(lastDotIndex);
          if (ext === ".js" || ext === ".jsx" || ext === ".mjs" || ext === ".cjs") {
            const pathnameWithoutExtension = p.slice(0, lastDotIndex);
            const replacementExts = ext === ".js" ? replacementsForJs : ext === ".jsx" ? replacementsForJsx : ext === ".mjs" ? replacementsForMjs : replacementsForCjs;
            for (let i = 0; i < replacementExts.length; i++) {
              const filename = tryFile(pathnameWithoutExtension + replacementExts[i], isMain);
              if (filename) {
                return filename;
              }
            }
          }
        }
        return false;
      }
      function tryExtensions(p, exts, isMain) {
        for (let i = 0; i < exts.length; i++) {
          const filename = tryFile(p + exts[i], isMain);
          if (filename) {
            return filename;
          }
        }
        return false;
      }
      function trySelfParentPath(parent) {
        if (!parent)
          return false;
        if (parent.filename) {
          return parent.filename;
        } else if (parent.id === "<repl>" || parent.id === "internal/preload") {
          try {
            return process.cwd() + path5.sep;
          } catch {
            return false;
          }
        }
      }
      function trySelf(parentPath, request) {
        if (!parentPath)
          return false;
        const { data: pkg, path: pkgPath } = readPackageScope(parentPath) || {};
        if (!pkg || pkg.exports === void 0)
          return false;
        if (typeof pkg.name !== "string")
          return false;
        let expansion;
        if (request === pkg.name) {
          expansion = ".";
        } else if (StringPrototypeStartsWith(request, `${pkg.name}/`)) {
          expansion = "." + StringPrototypeSlice(request, pkg.name.length);
        } else {
          return false;
        }
        try {
          return finalizeEsmResolution(packageExportsResolve(
            pathToFileURL(pkgPath + "/package.json"),
            expansion,
            pkg,
            pathToFileURL(parentPath),
            cjsConditions
          ).resolved, parentPath, pkgPath);
        } catch (e) {
          if (e.code === "ERR_MODULE_NOT_FOUND")
            throw createEsmNotFoundErr(request, pkgPath + "/package.json");
          throw e;
        }
      }
      const EXPORTS_PATTERN = /^((?:@[^/\\%]+\/)?[^./\\%][^/\\%]*)(\/.*)?$/;
      function resolveExports(nmPath, request) {
        const { 1: name, 2: expansion = "" } = StringPrototypeMatch(request, EXPORTS_PATTERN) || [];
        if (!name)
          return;
        const pkgPath = path5.resolve(nmPath, name);
        const pkg = readPackage(pkgPath);
        if (pkg != null && pkg.exports != null) {
          try {
            return finalizeEsmResolution(packageExportsResolve(
              pathToFileURL(pkgPath + "/package.json"),
              "." + expansion,
              pkg,
              null,
              cjsConditions
            ).resolved, null, pkgPath);
          } catch (e) {
            if (e.code === "ERR_MODULE_NOT_FOUND")
              throw createEsmNotFoundErr(request, pkgPath + "/package.json");
            throw e;
          }
        }
      }
      const hasModulePathCache = !!require("module")._pathCache;
      const Module_pathCache = /* @__PURE__ */ Object.create(null);
      const Module_pathCache_get = hasModulePathCache ? (cacheKey) => Module._pathCache[cacheKey] : (cacheKey) => Module_pathCache[cacheKey];
      const Module_pathCache_set = hasModulePathCache ? (cacheKey, value2) => Module._pathCache[cacheKey] = value2 : (cacheKey) => Module_pathCache[cacheKey] = value;
      const trailingSlashRegex = /(?:^|\/)\.?\.$/;
      const Module_findPath = function _findPath(request, paths, isMain) {
        const absoluteRequest = path5.isAbsolute(request);
        if (absoluteRequest) {
          paths = [""];
        } else if (!paths || paths.length === 0) {
          return false;
        }
        const cacheKey = request + "\0" + ArrayPrototypeJoin(paths, "\0");
        const entry = Module_pathCache_get(cacheKey);
        if (entry)
          return entry;
        let exts;
        let trailingSlash = request.length > 0 && StringPrototypeCharCodeAt(request, request.length - 1) === CHAR_FORWARD_SLASH;
        if (!trailingSlash) {
          trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);
        }
        for (let i = 0; i < paths.length; i++) {
          const curPath = paths[i];
          if (curPath && stat(curPath) < 1)
            continue;
          if (!absoluteRequest) {
            const exportsResolved = resolveExports(curPath, request);
            if (exportsResolved)
              return exportsResolved;
          }
          const _basePath = path5.resolve(curPath, request);
          let filename;
          const [rc, basePath] = statReplacementExtensions(_basePath);
          if (!trailingSlash) {
            if (rc === 0) {
              if (!isMain) {
                if (preserveSymlinks) {
                  filename = path5.resolve(basePath);
                } else {
                  filename = toRealPath(basePath);
                }
              } else if (preserveSymlinksMain) {
                filename = path5.resolve(basePath);
              } else {
                filename = toRealPath(basePath);
              }
            }
            if (!filename) {
              if (exts === void 0)
                exts = ObjectKeys(Module._extensions);
              filename = tryExtensions(basePath, exts, isMain);
            }
          }
          if (!filename && rc === 1) {
            if (exts === void 0)
              exts = ObjectKeys(Module._extensions);
            filename = tryPackage(basePath, exts, isMain, request);
          }
          if (filename) {
            Module_pathCache_set(cacheKey, filename);
            return filename;
          }
        }
        return false;
      };
      const Module_resolveFilename = function _resolveFilename(request, parent, isMain, options) {
        if (StringPrototypeStartsWith(request, "node:") || NativeModule.canBeRequiredByUsers(request)) {
          return request;
        }
        let paths;
        if (typeof options === "object" && options !== null) {
          if (ArrayIsArray(options.paths)) {
            const isRelative = StringPrototypeStartsWith(request, "./") || StringPrototypeStartsWith(request, "../") || (isWindows && StringPrototypeStartsWith(request, ".\\") || StringPrototypeStartsWith(request, "..\\"));
            if (isRelative) {
              paths = options.paths;
            } else {
              const fakeParent = new Module("", null);
              paths = [];
              for (let i = 0; i < options.paths.length; i++) {
                const path6 = options.paths[i];
                fakeParent.paths = Module._nodeModulePaths(path6);
                const lookupPaths = Module._resolveLookupPaths(request, fakeParent);
                for (let j = 0; j < lookupPaths.length; j++) {
                  if (!ArrayPrototypeIncludes(paths, lookupPaths[j]))
                    ArrayPrototypePush(paths, lookupPaths[j]);
                }
              }
            }
          } else if (options.paths === void 0) {
            paths = Module._resolveLookupPaths(request, parent);
          } else {
            throw new ERR_INVALID_ARG_VALUE("options.paths", options.paths);
          }
        } else {
          paths = Module._resolveLookupPaths(request, parent);
        }
        if (parent != null && parent.filename) {
          if (request[0] === "#") {
            const pkg = readPackageScope(parent.filename) || {};
            if (pkg.data != null && pkg.data.imports != null) {
              try {
                return finalizeEsmResolution(
                  packageImportsResolve(
                    request,
                    pathToFileURL(parent.filename),
                    cjsConditions
                  ),
                  parent.filename,
                  pkg.path
                );
              } catch (e) {
                if (e.code === "ERR_MODULE_NOT_FOUND")
                  throw createEsmNotFoundErr(request);
                throw e;
              }
            }
          }
        }
        const parentPath = trySelfParentPath(parent);
        const selfResolved = trySelf(parentPath, request);
        if (selfResolved) {
          const cacheKey = request + "\0" + (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths, "\0"));
          Module._pathCache[cacheKey] = selfResolved;
          return selfResolved;
        }
        const filename = Module._findPath(request, paths, isMain, false);
        if (filename)
          return filename;
        const requireStack = [];
        for (let cursor = parent; cursor; cursor = moduleParentCache.get(cursor)) {
          ArrayPrototypePush(requireStack, cursor.filename || cursor.id);
        }
        let message = `Cannot find module '${request}'`;
        if (requireStack.length > 0) {
          message = message + "\nRequire stack:\n- " + ArrayPrototypeJoin(requireStack, "\n- ");
        }
        const err = new Error(message);
        err.code = "MODULE_NOT_FOUND";
        err.requireStack = requireStack;
        throw err;
      };
      function finalizeEsmResolution(resolved, parentPath, pkgPath) {
        if (RegExpPrototypeTest(encodedSepRegEx, resolved))
          throw new ERR_INVALID_MODULE_SPECIFIER(
            resolved,
            'must not include encoded "/" or "\\" characters',
            parentPath
          );
        const filename = fileURLToPath(resolved);
        const actual = tryReplacementExtensions(filename) || tryFile(filename);
        if (actual)
          return actual;
        const err = createEsmNotFoundErr(
          filename,
          path5.resolve(pkgPath, "package.json")
        );
        throw err;
      }
      function createEsmNotFoundErr(request, path6) {
        const err = new Error(`Cannot find module '${request}'`);
        err.code = "MODULE_NOT_FOUND";
        if (path6)
          err.path = path6;
        return err;
      }
      return {
        Module_findPath,
        Module_resolveFilename
      };
    }
    function assertScriptCanLoadAsCJSImpl(service, module3, filename) {
      const pkg = readPackageScope(filename);
      const tsNodeClassification = service.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizeSlashes(filename));
      if (tsNodeClassification.moduleType === "cjs")
        return;
      const lastDotIndex = filename.lastIndexOf(".");
      const ext = lastDotIndex >= 0 ? filename.slice(lastDotIndex) : "";
      if ((ext === ".cts" || ext === ".cjs") && tsNodeClassification.moduleType === "auto")
        return;
      if (ext === ".mts" || ext === ".mjs" || tsNodeClassification.moduleType === "esm" || pkg && pkg.data && pkg.data.type === "module") {
        const parentPath = module3.parent && module3.parent.filename;
        const packageJsonPath = pkg ? path5.resolve(pkg.path, "package.json") : null;
        throw createErrRequireEsm(filename, parentPath, packageJsonPath);
      }
    }
    module2.exports = {
      createCjsLoader,
      assertScriptCanLoadAsCJSImpl,
      readPackageScope
    };
  }
});

// ../../../node_modules/ts-node/dist/node-module-type-classifier.js
var require_node_module_type_classifier = __commonJS({
  "../../../node_modules/ts-node/dist/node-module-type-classifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.classifyModule = void 0;
    var node_internal_modules_cjs_loader_1 = require_node_internal_modules_cjs_loader();
    function classifyModule(nativeFilename, isNodeModuleType) {
      const lastDotIndex = nativeFilename.lastIndexOf(".");
      const ext = lastDotIndex >= 0 ? nativeFilename.slice(lastDotIndex) : "";
      switch (ext) {
        case ".cjs":
        case ".cts":
          return isNodeModuleType ? "nodecjs" : "cjs";
        case ".mjs":
        case ".mts":
          return isNodeModuleType ? "nodeesm" : "esm";
      }
      if (isNodeModuleType) {
        const packageScope = (0, node_internal_modules_cjs_loader_1.readPackageScope)(nativeFilename);
        if (packageScope && packageScope.data.type === "module")
          return "nodeesm";
        return "nodecjs";
      }
      return void 0;
    }
    exports2.classifyModule = classifyModule;
  }
});

// ../../../node_modules/ts-node/dist/file-extensions.js
var require_file_extensions = __commonJS({
  "../../../node_modules/ts-node/dist/file-extensions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getExtensions = void 0;
    var util_1 = require_util();
    var nodeEquivalents = /* @__PURE__ */ new Map([
      [".ts", ".js"],
      [".tsx", ".js"],
      [".jsx", ".js"],
      [".mts", ".mjs"],
      [".cts", ".cjs"]
    ]);
    var tsResolverEquivalents = /* @__PURE__ */ new Map([
      [".ts", [".js"]],
      [".tsx", [".js", ".jsx"]],
      [".mts", [".mjs"]],
      [".cts", [".cjs"]]
    ]);
    var vanillaNodeExtensions = [
      ".js",
      ".json",
      ".node",
      ".mjs",
      ".cjs"
    ];
    var nodeDoesNotUnderstand = [
      ".ts",
      ".tsx",
      ".jsx",
      ".cts",
      ".mts"
    ];
    function getExtensions(config, options, tsVersion) {
      const tsSupportsMtsCtsExts = (0, util_1.versionGteLt)(tsVersion, "4.5.0");
      const requiresHigherTypescriptVersion = [];
      if (!tsSupportsMtsCtsExts)
        requiresHigherTypescriptVersion.push(".cts", ".cjs", ".mts", ".mjs");
      const allPossibleExtensionsSortedByPreference = Array.from(/* @__PURE__ */ new Set([
        ...options.preferTsExts ? nodeDoesNotUnderstand : [],
        ...vanillaNodeExtensions,
        ...nodeDoesNotUnderstand
      ]));
      const compiledJsUnsorted = [".ts"];
      const compiledJsxUnsorted = [];
      if (config.options.jsx)
        compiledJsxUnsorted.push(".tsx");
      if (tsSupportsMtsCtsExts)
        compiledJsUnsorted.push(".mts", ".cts");
      if (config.options.allowJs) {
        compiledJsUnsorted.push(".js");
        if (config.options.jsx)
          compiledJsxUnsorted.push(".jsx");
        if (tsSupportsMtsCtsExts)
          compiledJsUnsorted.push(".mjs", ".cjs");
      }
      const compiledUnsorted = [...compiledJsUnsorted, ...compiledJsxUnsorted];
      const compiled = allPossibleExtensionsSortedByPreference.filter((ext) => compiledUnsorted.includes(ext));
      const compiledNodeDoesNotUnderstand = nodeDoesNotUnderstand.filter((ext) => compiled.includes(ext));
      const r = allPossibleExtensionsSortedByPreference.filter((ext) => [...compiledUnsorted, ".js", ".mjs", ".cjs", ".mts", ".cts"].includes(ext));
      const replacementsForJs = r.filter((ext) => [".js", ".jsx", ".ts", ".tsx"].includes(ext));
      const replacementsForJsx = r.filter((ext) => [".jsx", ".tsx"].includes(ext));
      const replacementsForMjs = r.filter((ext) => [".mjs", ".mts"].includes(ext));
      const replacementsForCjs = r.filter((ext) => [".cjs", ".cts"].includes(ext));
      const replacementsForJsOrMjs = r.filter((ext) => [".js", ".jsx", ".ts", ".tsx", ".mjs", ".mts"].includes(ext));
      const experimentalSpecifierResolutionAddsIfOmitted = Array.from(/* @__PURE__ */ new Set([...replacementsForJsOrMjs, ".json", ".node"]));
      const legacyMainResolveAddsIfOmitted = Array.from(/* @__PURE__ */ new Set([...replacementsForJs, ".json", ".node"]));
      return {
        /** All file extensions we transform, ordered by resolution preference according to preferTsExts */
        compiled,
        /** Resolved extensions that vanilla node will not understand; we should handle them */
        nodeDoesNotUnderstand,
        /** Like the above, but only the ones we're compiling */
        compiledNodeDoesNotUnderstand,
        /**
         * Mapping from extensions understood by tsc to the equivalent for node,
         * as far as getFormat is concerned.
         */
        nodeEquivalents,
        /**
         * Mapping from extensions rejected by TSC in import specifiers, to the
         * possible alternatives that TS's resolver will accept.
         *
         * When we allow users to opt-in to .ts extensions in import specifiers, TS's
         * resolver requires us to replace the .ts extensions with .js alternatives.
         * Otherwise, resolution fails.
         *
         * Note TS's resolver is only used by, and only required for, typechecking.
         * This is separate from node's resolver, which we hook separately and which
         * does not require this mapping.
         */
        tsResolverEquivalents,
        /**
         * Extensions that we can support if the user upgrades their typescript version.
         * Used when raising hints.
         */
        requiresHigherTypescriptVersion,
        /**
         * --experimental-specifier-resolution=node will add these extensions.
         */
        experimentalSpecifierResolutionAddsIfOmitted,
        /**
         * ESM loader will add these extensions to package.json "main" field
         */
        legacyMainResolveAddsIfOmitted,
        replacementsForMjs,
        replacementsForCjs,
        replacementsForJsx,
        replacementsForJs
      };
    }
    exports2.getExtensions = getExtensions;
  }
});

// ../../../node_modules/ts-node/dist/ts-transpile-module.js
var require_ts_transpile_module = __commonJS({
  "../../../node_modules/ts-node/dist/ts-transpile-module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTsTranspileModule = void 0;
    function createTsTranspileModule(ts, transpileOptions) {
      const { createProgram, createSourceFile, getDefaultCompilerOptions, getImpliedNodeFormatForFile, fixupCompilerOptions, transpileOptionValueCompilerOptions, getNewLineCharacter, fileExtensionIs, normalizePath: normalizePath2, Debug, toPath, getSetExternalModuleIndicator, getEntries, addRange, hasProperty, getEmitScriptTarget, getDirectoryPath } = ts;
      const compilerOptionsDiagnostics = [];
      const options = transpileOptions.compilerOptions ? fixupCompilerOptions(transpileOptions.compilerOptions, compilerOptionsDiagnostics) : {};
      const defaultOptions = getDefaultCompilerOptions();
      for (const key in defaultOptions) {
        if (hasProperty(defaultOptions, key) && options[key] === void 0) {
          options[key] = defaultOptions[key];
        }
      }
      for (const option of transpileOptionValueCompilerOptions) {
        options[option.name] = option.transpileOptionValue;
      }
      options.suppressOutputPathCheck = true;
      options.allowNonTsExtensions = true;
      const newLine = getNewLineCharacter(options);
      const compilerHost = {
        getSourceFile: (fileName) => fileName === normalizePath2(inputFileName) ? sourceFile : void 0,
        writeFile: (name, text) => {
          if (fileExtensionIs(name, ".map")) {
            Debug.assertEqual(sourceMapText, void 0, "Unexpected multiple source map outputs, file:", name);
            sourceMapText = text;
          } else {
            Debug.assertEqual(outputText, void 0, "Unexpected multiple outputs, file:", name);
            outputText = text;
          }
        },
        getDefaultLibFileName: () => "lib.d.ts",
        useCaseSensitiveFileNames: () => true,
        getCanonicalFileName: (fileName) => fileName,
        getCurrentDirectory: () => "",
        getNewLine: () => newLine,
        fileExists: (fileName) => fileName === inputFileName || fileName === packageJsonFileName,
        readFile: (fileName) => fileName === packageJsonFileName ? `{"type": "${_packageJsonType}"}` : "",
        directoryExists: () => true,
        getDirectories: () => []
      };
      let inputFileName;
      let packageJsonFileName;
      let _packageJsonType;
      let sourceFile;
      let outputText;
      let sourceMapText;
      return transpileModule;
      function transpileModule(input, transpileOptions2, packageJsonType = "commonjs") {
        inputFileName = transpileOptions2.fileName || (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx ? "module.tsx" : "module.ts");
        packageJsonFileName = getDirectoryPath(inputFileName) + "/package.json";
        _packageJsonType = packageJsonType;
        sourceFile = createSourceFile(inputFileName, input, {
          languageVersion: getEmitScriptTarget(options),
          impliedNodeFormat: getImpliedNodeFormatForFile(
            toPath(inputFileName, "", compilerHost.getCanonicalFileName),
            /*cache*/
            void 0,
            compilerHost,
            options
          ),
          setExternalModuleIndicator: getSetExternalModuleIndicator(options)
        });
        if (transpileOptions2.moduleName) {
          sourceFile.moduleName = transpileOptions2.moduleName;
        }
        if (transpileOptions2.renamedDependencies) {
          sourceFile.renamedDependencies = new Map(getEntries(transpileOptions2.renamedDependencies));
        }
        outputText = void 0;
        sourceMapText = void 0;
        const program = createProgram([inputFileName], options, compilerHost);
        const diagnostics = compilerOptionsDiagnostics.slice();
        if (transpileOptions.reportDiagnostics) {
          addRange(
            /*to*/
            diagnostics,
            /*from*/
            program.getSyntacticDiagnostics(sourceFile)
          );
          addRange(
            /*to*/
            diagnostics,
            /*from*/
            program.getOptionsDiagnostics()
          );
        }
        program.emit(
          /*targetSourceFile*/
          void 0,
          /*writeFile*/
          void 0,
          /*cancellationToken*/
          void 0,
          /*emitOnlyDtsFiles*/
          void 0,
          transpileOptions.transformers
        );
        if (outputText === void 0)
          return Debug.fail("Output generation failed");
        return { outputText, diagnostics, sourceMapText };
      }
    }
    exports2.createTsTranspileModule = createTsTranspileModule;
  }
});

// ../../../node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "../../../node_modules/acorn/dist/acorn.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports2, function(exports3) {
      "use strict";
      var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$1 = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };
      var keywordRelationalOperator = /^in(stanceof)?$/;
      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
      function isInAstralSet(code, set) {
        var pos = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos += set[i2];
          if (pos > code) {
            return false;
          }
          pos += set[i2 + 1];
          if (pos >= code) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart(code, astral) {
        if (code < 65) {
          return code === 36;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes);
      }
      function isIdentifierChar(code, astral) {
        if (code < 48) {
          return code === 36;
        }
        if (code < 58) {
          return true;
        }
        if (code < 65) {
          return false;
        }
        if (code < 91) {
          return true;
        }
        if (code < 97) {
          return code === 95;
        }
        if (code < 123) {
          return true;
        }
        if (code <= 65535) {
          return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
      }
      var TokenType = function TokenType2(label, conf) {
        if (conf === void 0)
          conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop(name, prec) {
        return new TokenType(name, { beforeExpr: true, binop: prec });
      }
      var beforeExpr = { beforeExpr: true }, startsExpr = { startsExpr: true };
      var keywords = {};
      function kw(name, options) {
        if (options === void 0)
          options = {};
        options.keyword = name;
        return keywords[name] = new TokenType(name, options);
      }
      var types$1 = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        privateId: new TokenType("privateId", startsExpr),
        eof: new TokenType("eof"),
        // Punctuation token types.
        bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        questionDot: new TokenType("?."),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", { beforeExpr: true }),
        coalesce: binop("??", 1),
        // Keyword token types.
        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", { isLoop: true, beforeExpr: true }),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", { isLoop: true }),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", { isLoop: true }),
        _with: kw("with"),
        _new: kw("new", { beforeExpr: true, startsExpr: true }),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");
      function isNewLine(code) {
        return code === 10 || code === 13 || code === 8232 || code === 8233;
      }
      function nextLineBreak(code, from, end) {
        if (end === void 0)
          end = code.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code.charCodeAt(i2);
          if (isNewLine(next)) {
            return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;
      var hasOwn = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty.call(obj, propName);
      };
      var isArray = Array.isArray || function(obj) {
        return toString.call(obj) === "[object Array]";
      };
      function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      function codePointToString(code) {
        if (code <= 65535) {
          return String.fromCharCode(code);
        }
        code -= 65536;
        return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
      }
      var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position = function Position2(line, col) {
        this.line = line;
        this.column = col;
      };
      Position.prototype.offset = function offset(n) {
        return new Position(this.line, this.column + n);
      };
      var SourceLocation = function SourceLocation2(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak(input, cur, offset);
          if (nextBreak < 0) {
            return new Position(line, offset - cur);
          }
          ++line;
          cur = nextBreak;
        }
      }
      var defaultOptions = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called
        // when a semicolon is automatically inserted. It will be passed
        // the position of the comma as an offset, and if `locations` is
        // enabled, it is given the location as a `{line, column}` object
        // as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: true,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion = false;
      function getOptions(opts) {
        var options = {};
        for (var opt in defaultOptions) {
          options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray(options.onComment)) {
          options.onComment = pushComment(options, options.onComment);
        }
        return options;
      }
      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
      }
      var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5;
      var Parser2 = function Parser3(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$1.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser2.prototype.parse = function parse3() {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node);
      };
      prototypeAccessors.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
      };
      prototypeAccessors.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION) {
            return (scope.flags & SCOPE_ASYNC) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors.allowSuper.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
      };
      prototypeAccessors.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors.allowNewDotTarget.get = function() {
        var ref2 = this.currentThisScope();
        var flags = ref2.flags;
        var inClassFieldInit = ref2.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
      };
      prototypeAccessors.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
      };
      Parser2.extend = function extend() {
        var plugins = [], len = arguments.length;
        while (len--)
          plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser2.parse = function parse3(input, options) {
        return new this(options, input).parse();
      };
      Parser2.parseExpressionAt = function parseExpressionAt2(input, pos, options) {
        var parser3 = new this(options, input, pos);
        parser3.nextToken();
        return parser3.parseExpression();
      };
      Parser2.tokenizer = function tokenizer2(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser2.prototype, prototypeAccessors);
      var pp$9 = Parser2.prototype;
      var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp$9.strictDirective = function(start) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace.lastIndex = start + match[0].length;
            var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start += match[0].length;
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";") {
            start++;
          }
        }
      };
      pp$9.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$9.isContextual = function(name) {
        return this.type === types$1.name && this.value === name && !this.containsEsc;
      };
      pp$9.eatContextual = function(name) {
        if (!this.isContextual(name)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$9.expectContextual = function(name) {
        if (!this.eatContextual(name)) {
          this.unexpected();
        }
      };
      pp$9.canInsertSemicolon = function() {
        return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$9.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$9.semicolon = function() {
        if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$9.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$9.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$9.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors = function DestructuringErrors2() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$9.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$9.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$8 = Parser2.prototype;
      pp$8.parseTopLevel = function(node) {
        var exports4 = /* @__PURE__ */ Object.create(null);
        if (!node.body) {
          node.body = [];
        }
        while (this.type !== types$1.eof) {
          var stmt = this.parseStatement(null, true, exports4);
          node.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list2 = Object.keys(this.undefinedExports); i2 < list2.length; i2 += 1) {
            var name = list2[i2];
            this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program");
      };
      var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
      pp$8.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$8.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$8.parseStatement = function(context, topLevel, exports4) {
        var starttype = this.type, node = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$1._var;
          kind = "let";
        }
        switch (starttype) {
          case types$1._break:
          case types$1._continue:
            return this.parseBreakContinueStatement(node, starttype.keyword);
          case types$1._debugger:
            return this.parseDebuggerStatement(node);
          case types$1._do:
            return this.parseDoStatement(node);
          case types$1._for:
            return this.parseForStatement(node);
          case types$1._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node, false, !context);
          case types$1._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node, true);
          case types$1._if:
            return this.parseIfStatement(node);
          case types$1._return:
            return this.parseReturnStatement(node);
          case types$1._switch:
            return this.parseSwitchStatement(node);
          case types$1._throw:
            return this.parseThrowStatement(node);
          case types$1._try:
            return this.parseTryStatement(node);
          case types$1._const:
          case types$1._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node, kind);
          case types$1._while:
            return this.parseWhileStatement(node);
          case types$1._with:
            return this.parseWithStatement(node);
          case types$1.braceL:
            return this.parseBlock(true, node);
          case types$1.semi:
            return this.parseEmptyStatement(node);
          case types$1._export:
          case types$1._import:
            if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports4);
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
              return this.parseLabeledStatement(node, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node, expr);
            }
        }
      };
      pp$8.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.label = null;
        } else if (this.type !== types$1.name) {
          this.unexpected();
        } else {
          node.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$8.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      };
      pp$8.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$1._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$1.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "DoWhileStatement");
      };
      pp$8.parseForStatement = function(node) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types$1.parenL);
        if (this.type === types$1.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        var isLet = this.isLet();
        if (this.type === types$1._var || this.type === types$1._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$1._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors();
        var init = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$1._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node.await = awaitAt > -1;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLValPattern(init);
          return this.parseForIn(node, init);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      };
      pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
      };
      pp$8.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement");
      };
      pp$8.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$1.semi) || this.insertSemicolon()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      };
      pp$8.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types$1.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$1.braceR; ) {
          if (this.type === types$1._case || this.type === types$1._default) {
            var isCase = this.type === types$1._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$1.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      };
      pp$8.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      };
      var empty$1 = [];
      pp$8.parseCatchClauseParam = function() {
        var param = this.parseBindingAtom();
        var simple = param.type === "Identifier";
        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
        this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
        this.expect(types$1.parenR);
        return param;
      };
      pp$8.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types$1._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$1.parenL)) {
            clause.param = this.parseCatchClauseParam();
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(node.start, "Missing catch or finally clause");
        }
        return this.finishNode(node, "TryStatement");
      };
      pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      };
      pp$8.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement");
      };
      pp$8.parseWithStatement = function(node) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement");
      };
      pp$8.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      };
      pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list2 = this.labels; i$1 < list2.length; i$1 += 1) {
          var label = list2[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      };
      pp$8.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      };
      pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
        if (createNewLexicalScope === void 0)
          createNewLexicalScope = true;
        if (node === void 0)
          node = this.startNode();
        node.body = [];
        this.expect(types$1.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node, "BlockStatement");
      };
      pp$8.parseFor = function(node, init) {
        node.init = init;
        this.expect(types$1.semi);
        node.test = this.type === types$1.semi ? null : this.parseExpression();
        this.expect(types$1.semi);
        node.update = this.type === types$1.parenR ? null : this.parseExpression();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement");
      };
      pp$8.parseForIn = function(node, init) {
        var isForIn = this.type === types$1._in;
        this.next();
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$1.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
        node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$1.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$1.comma)) {
            break;
          }
        }
        return node;
      };
      pp$8.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };
      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
      pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
            this.unexpected();
          }
          node.generator = this.eat(types$1.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT) {
          node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
            this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));
        if (!(statement & FUNC_STATEMENT)) {
          node.id = this.type === types$1.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$8.parseFunctionParams = function(node) {
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$8.parseClass = function(node, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$1.braceL);
        while (this.type !== types$1.braceR) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) {
                this.raiseRecoverable(element.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
              this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$8.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$1.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$1.braceL)) {
            this.parseClassStaticBlock(node);
            return node;
          }
          if (this.isClassElementNameStart() || this.type === types$1.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$1.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node.computed = false;
          node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node.key.name = keyName;
          this.finishNode(node.key, "Identifier");
        } else {
          this.parseClassElementName(node);
        }
        if (ecmaVersion2 < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node.static && checkKeyName(node, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node.key.start, "Constructor can't have get/set modifier");
          }
          node.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node);
        }
        return node;
      };
      pp$8.isClassElementNameStart = function() {
        return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
      };
      pp$8.parseClassElementName = function(element) {
        if (this.type === types$1.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element.computed = false;
          element.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element);
        }
      };
      pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value2.params.length !== 0) {
          this.raiseRecoverable(value2.start, "getter should have no params");
        }
        if (method.kind === "set" && value2.params.length !== 1) {
          this.raiseRecoverable(value2.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value2.params[0].type === "RestElement") {
          this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$8.parseClassField = function(field) {
        if (checkKeyName(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$1.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$8.parseClassStaticBlock = function(node) {
        node.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
        while (this.type !== types$1.braceR) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node, "StaticBlock");
      };
      pp$8.parseClassId = function(node, isStatement) {
        if (this.type === types$1.name) {
          node.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node.id, BIND_LEXICAL, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node.id = null;
        }
      };
      pp$8.parseClassSuper = function(node) {
        node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$8.enterClassBody = function() {
        var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element);
        return element.declared;
      };
      pp$8.exitClassBody = function() {
        var ref2 = this.privateNameStack.pop();
        var declared = ref2.declared;
        var used = ref2.used;
        if (!this.options.checkPrivateFields) {
          return;
        }
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id = used[i2];
          if (!hasOwn(declared, id.name)) {
            if (parent) {
              parent.used.push(id);
            } else {
              this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted(privateNameMap, element) {
        var name = element.key.name;
        var curr = privateNameMap[name];
        var next = "true";
        if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
          next = (element.static ? "s" : "i") + element.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName(node, name) {
        var computed = node.computed;
        var key = node.key;
        return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
      }
      pp$8.parseExportAllDeclaration = function(node, exports4) {
        if (this.options.ecmaVersion >= 11) {
          if (this.eatContextual("as")) {
            node.exported = this.parseModuleExportName();
            this.checkExport(exports4, node.exported, this.lastTokStart);
          } else {
            node.exported = null;
          }
        }
        this.expectContextual("from");
        if (this.type !== types$1.string) {
          this.unexpected();
        }
        node.source = this.parseExprAtom();
        this.semicolon();
        return this.finishNode(node, "ExportAllDeclaration");
      };
      pp$8.parseExport = function(node, exports4) {
        this.next();
        if (this.eat(types$1.star)) {
          return this.parseExportAllDeclaration(node, exports4);
        }
        if (this.eat(types$1._default)) {
          this.checkExport(exports4, "default", this.lastTokStart);
          node.declaration = this.parseExportDefaultDeclaration();
          return this.finishNode(node, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseExportDeclaration(node);
          if (node.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports4, node.declaration.declarations);
          } else {
            this.checkExport(exports4, node.declaration.id, node.declaration.id.start);
          }
          node.specifiers = [];
          node.source = null;
        } else {
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports4);
          if (this.eatContextual("from")) {
            if (this.type !== types$1.string) {
              this.unexpected();
            }
            node.source = this.parseExprAtom();
          } else {
            for (var i2 = 0, list2 = node.specifiers; i2 < list2.length; i2 += 1) {
              var spec = list2[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration");
      };
      pp$8.parseExportDeclaration = function(node) {
        return this.parseStatement(null);
      };
      pp$8.parseExportDefaultDeclaration = function() {
        var isAsync;
        if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
          var fNode = this.startNode();
          this.next();
          if (isAsync) {
            this.next();
          }
          return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
        } else if (this.type === types$1._class) {
          var cNode = this.startNode();
          return this.parseClass(cNode, "nullableID");
        } else {
          var declaration = this.parseMaybeAssign();
          this.semicolon();
          return declaration;
        }
      };
      pp$8.checkExport = function(exports4, name, pos) {
        if (!exports4) {
          return;
        }
        if (typeof name !== "string") {
          name = name.type === "Identifier" ? name.name : name.value;
        }
        if (hasOwn(exports4, name)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
        }
        exports4[name] = true;
      };
      pp$8.checkPatternExport = function(exports4, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports4, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list2 = pat.properties; i2 < list2.length; i2 += 1) {
            var prop = list2[i2];
            this.checkPatternExport(exports4, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports4, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports4, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports4, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports4, pat.argument);
        } else if (type === "ParenthesizedExpression") {
          this.checkPatternExport(exports4, pat.expression);
        }
      };
      pp$8.checkVariableExport = function(exports4, decls) {
        if (!exports4) {
          return;
        }
        for (var i2 = 0, list2 = decls; i2 < list2.length; i2 += 1) {
          var decl = list2[i2];
          this.checkPatternExport(exports4, decl.id);
        }
      };
      pp$8.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$8.parseExportSpecifier = function(exports4) {
        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
        this.checkExport(
          exports4,
          node.exported,
          node.exported.start
        );
        return this.finishNode(node, "ExportSpecifier");
      };
      pp$8.parseExportSpecifiers = function(exports4) {
        var nodes = [], first = true;
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseExportSpecifier(exports4));
        }
        return nodes;
      };
      pp$8.parseImport = function(node) {
        this.next();
        if (this.type === types$1.string) {
          node.specifiers = empty$1;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };
      pp$8.parseImportSpecifier = function() {
        var node = this.startNode();
        node.imported = this.parseModuleExportName();
        if (this.eatContextual("as")) {
          node.local = this.parseIdent();
        } else {
          this.checkUnreserved(node.imported);
          node.local = node.imported;
        }
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportSpecifier");
      };
      pp$8.parseImportDefaultSpecifier = function() {
        var node = this.startNode();
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportDefaultSpecifier");
      };
      pp$8.parseImportNamespaceSpecifier = function() {
        var node = this.startNode();
        this.next();
        this.expectContextual("as");
        node.local = this.parseIdent();
        this.checkLValSimple(node.local, BIND_LEXICAL);
        return this.finishNode(node, "ImportNamespaceSpecifier");
      };
      pp$8.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$1.name) {
          nodes.push(this.parseImportDefaultSpecifier());
          if (!this.eat(types$1.comma)) {
            return nodes;
          }
        }
        if (this.type === types$1.star) {
          nodes.push(this.parseImportNamespaceSpecifier());
          return nodes;
        }
        this.expect(types$1.braceL);
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          nodes.push(this.parseImportSpecifier());
        }
        return nodes;
      };
      pp$8.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$8.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$8.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$7 = Parser2.prototype;
      pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await") {
                this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list2 = node.properties; i2 < list2.length; i2 += 1) {
                var prop = list2[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node.kind !== "init") {
                this.raise(node.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node.value, isBinding);
              break;
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node.elements, isBinding);
              break;
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern") {
                this.raise(node.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node.operator !== "=") {
                this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node;
      };
      pp$7.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$7.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement");
      };
      pp$7.parseRestBinding = function() {
        var node = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
          this.unexpected();
        }
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      };
      pp$7.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$1.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types$1.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern");
            case types$1.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$1.comma);
          }
          if (allowEmpty && this.type === types$1.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$1.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            elts.push(this.parseAssignableListItem(allowModifiers));
          }
        }
        return elts;
      };
      pp$7.parseAssignableListItem = function(allowModifiers) {
        var elem = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(elem);
        return elem;
      };
      pp$7.parseBindingListItem = function(param) {
        return param;
      };
      pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
          return left;
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern");
      };
      pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        var isBind = bindingType !== BIND_NONE;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list2 = expr.properties; i2 < list2.length; i2 += 1) {
              var prop = list2[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0)
          bindingType = BIND_NONE;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };
      var pp$6 = Parser2.prototype;
      pp$6.initialContext = function() {
        return [types.b_stat];
      };
      pp$6.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$6.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types.f_expr || parent === types.f_stat) {
          return true;
        }
        if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
          return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
          return true;
        }
        if (prevType === types$1.braceL) {
          return parent === types.b_stat;
        }
        if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$6.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$6.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$1.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$6.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$1.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
        this.exprAllowed = true;
      };
      types$1.dollarBraceL.updateContext = function() {
        this.context.push(types.b_tmpl);
        this.exprAllowed = true;
      };
      types$1.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
        this.context.push(statementParens ? types.p_stat : types.p_expr);
        this.exprAllowed = true;
      };
      types$1.incDec.updateContext = function() {
      };
      types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
          this.context.push(types.f_expr);
        } else {
          this.context.push(types.f_stat);
        }
        this.exprAllowed = false;
      };
      types$1.backQuote.updateContext = function() {
        if (this.curContext() === types.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$1.star.updateContext = function(prevType) {
        if (prevType === types$1._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types.f_expr) {
            this.context[index] = types.f_expr_gen;
          } else {
            this.context[index] = types.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$1.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$5 = Parser2.prototype;
      pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name;
        switch (key.type) {
          case "Identifier":
            name = key.name;
            break;
          case "Literal":
            name = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$5.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$1.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types$1.comma)) {
            node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      };
      pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$1.parenL || this.type === types$1.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          if (this.type === types$1.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$1.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node.left = left;
          this.next();
          node.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$1.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types$1.colon);
          node.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      };
      pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$1._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
            var coalesce = this.type === types$1.coalesce;
            if (coalesce) {
              prec = types$1.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types$1.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node.argument);
          } else if (this.strict && node.operator === "delete" && node.argument.type === "Identifier") {
            this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
          } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
            this.raiseRecoverable(node.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$1.privateId) {
          if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$1._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$1.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isPrivateFieldAccess(node) {
        return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression);
      }
      pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
        var optionalChained = false;
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element.optional) {
            optionalChained = true;
          }
          if (element === base || element.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element;
              element = this.finishNode(chainNode, "ChainExpression");
            }
            return element;
          }
          base = element;
        }
      };
      pp$5.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(types$1.arrow);
      };
      pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
      };
      pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$1.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$1.bracketL);
        if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          if (computed) {
            node.property = this.parseExpression();
            this.expect(types$1.bracketR);
          } else if (this.type === types$1.privateId && base.type !== "Super") {
            node.property = this.parsePrivateIdent();
          } else {
            node.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node.computed = !!computed;
          if (optionalSupported) {
            node.optional = optional;
          }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types$1.parenL)) {
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && this.shouldParseAsyncArrow()) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$1.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base;
      };
      pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
        if (this.type === types$1.slash) {
          this.readRegexp();
        }
        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$1._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node = this.startNode();
            this.next();
            if (this.type === types$1.parenL && !this.allowDirectSuper) {
              this.raise(node.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
              this.unexpected();
            }
            return this.finishNode(node, "Super");
          case types$1._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case types$1.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
              this.overrideContext(types.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$1.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
              }
            }
            return id;
          case types$1.regexp:
            var value2 = this.value;
            node = this.parseLiteral(value2.value);
            node.regex = { pattern: value2.pattern, flags: value2.flags };
            return node;
          case types$1.num:
          case types$1.string:
            return this.parseLiteral(this.value);
          case types$1._null:
          case types$1._true:
          case types$1._false:
            node = this.startNode();
            node.value = this.type === types$1._null ? null : this.type === types$1._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal");
          case types$1.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start;
              }
            }
            return expr;
          case types$1.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression");
          case types$1.braceL:
            this.overrideContext(types.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$1._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0);
          case types$1._class:
            return this.parseClass(this.startNode(), false);
          case types$1._new:
            return this.parseNew();
          case types$1.backQuote:
            return this.parseTemplate();
          case types$1._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport(forNew);
            } else {
              return this.unexpected();
            }
          default:
            return this.parseExprAtomDefault();
        }
      };
      pp$5.parseExprAtomDefault = function() {
        this.unexpected();
      };
      pp$5.parseExprImport = function(forNew) {
        var node = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        if (this.type === types$1.parenL && !forNew) {
          return this.parseDynamicImport(node);
        } else if (this.type === types$1.dot) {
          node.meta = meta;
          return this.parseImportMeta(node);
        } else {
          this.unexpected();
        }
      };
      pp$5.parseDynamicImport = function(node) {
        this.next();
        node.source = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node, "ImportExpression");
      };
      pp$5.parseImportMeta = function(node) {
        this.next();
        var containsEsc = this.containsEsc;
        node.property = this.parseIdent(true);
        if (node.property.name !== "meta") {
          this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node, "MetaProperty");
      };
      pp$5.parseLiteral = function(value2) {
        var node = this.startNode();
        node.value = value2;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
          node.bigint = node.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node, "Literal");
      };
      pp$5.parseParenExpression = function() {
        this.expect(types$1.parenL);
        var val = this.parseExpression();
        this.expect(types$1.parenR);
        return val;
      };
      pp$5.shouldParseArrow = function(exprList) {
        return !this.canInsertSemicolon();
      };
      pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$1.parenR) {
            first ? first = false : this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$1.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$1.comma) {
                this.raiseRecoverable(
                  this.start,
                  "Comma is not permitted after the rest element"
                );
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$1.parenR);
          if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$5.parseParenItem = function(item) {
        return item;
      };
      pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty = [];
      pp$5.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target") {
            this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc;
        node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
        if (this.eat(types$1.parenL)) {
          node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node.arguments = empty;
        }
        return this.finishNode(node, "NewExpression");
      };
      pp$5.parseTemplateElement = function(ref2) {
        var isTagged = ref2.isTagged;
        var elem = this.startNode();
        if (this.type === types$1.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$1.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$5.parseTemplate = function(ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var isTagged = ref2.isTagged;
        if (isTagged === void 0)
          isTagged = false;
        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$1.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$1.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types$1.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral");
      };
      pp$5.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$5.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types$1.braceR)) {
          if (!first) {
            this.expect(types$1.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$1.comma) {
              this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$1.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$5.parseGetterSetter = function(prop) {
        prop.kind = prop.key.name;
        this.parsePropertyName(prop);
        prop.value = this.parseMethod(false);
        var paramCount = prop.kind === "get" ? 0 : 1;
        if (prop.value.params.length !== paramCount) {
          var start = prop.value.start;
          if (prop.kind === "get") {
            this.raiseRecoverable(start, "getter should have no params");
          } else {
            this.raiseRecoverable(start, "setter should have exactly one param");
          }
        } else {
          if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
            this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
          }
        }
      };
      pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$1.colon) {
          this.unexpected();
        }
        if (this.eat(types$1.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.parseGetterSetter(prop);
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$1.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$5.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$1.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$1.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$5.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) {
          node.generator = node.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = false;
        }
      };
      pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node);
        if (this.options.ecmaVersion >= 6) {
          node.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
        this.expect(types$1.parenL);
        node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression");
      };
      pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) {
          node.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression");
      };
      pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$1.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node.body = this.parseMaybeAssign(forInit);
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          if (this.strict && node.id) {
            this.checkLValSimple(node.id, BIND_OUTSIDE);
          }
          node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$5.isSimpleParamList = function(params) {
        for (var i2 = 0, list2 = params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$5.checkParams = function(node, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list2 = node.params; i2 < list2.length; i2 += 1) {
          var param = list2[i2];
          this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };
      pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$1.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$1.comma) {
            elt = null;
          } else if (this.type === types$1.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$5.checkUnreserved = function(ref2) {
        var start = ref2.start;
        var end = ref2.end;
        var name = ref2.name;
        if (this.inGenerator && name === "yield") {
          this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name === "await") {
          this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name === "arguments") {
          this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
          this.raise(start, "Cannot use " + name + " in class static initialization block");
        }
        if (this.keywords.test(name)) {
          this.raise(start, "Unexpected keyword '" + name + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await") {
            this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
        }
      };
      pp$5.parseIdent = function(liberal) {
        var node = this.parseIdentNode();
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node.start;
          }
        }
        return node;
      };
      pp$5.parseIdentNode = function() {
        var node = this.startNode();
        if (this.type === types$1.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;
          if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        return node;
      };
      pp$5.parsePrivateIdent = function() {
        var node = this.startNode();
        if (this.type === types$1.privateId) {
          node.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node, "PrivateIdentifier");
        if (this.options.checkPrivateFields) {
          if (this.privateNameStack.length === 0) {
            this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
          } else {
            this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
          }
        }
        return node;
      };
      pp$5.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node = this.startNode();
        this.next();
        if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types$1.star);
          node.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node, "YieldExpression");
      };
      pp$5.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node, "AwaitExpression");
      };
      var pp$4 = Parser2.prototype;
      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$4.raiseRecoverable = pp$4.raise;
      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$3 = Parser2.prototype;
      var Scope = function Scope2(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$3.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };
      pp$3.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$3.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
      };
      pp$3.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && scope.flags & SCOPE_TOP) {
            delete this.undefinedExports[name];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
          }
          scope$2.functions.push(name);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name);
            if (this.inModule && scope$3.flags & SCOPE_TOP) {
              delete this.undefinedExports[name];
            }
            if (scope$3.flags & SCOPE_VAR) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
        }
      };
      pp$3.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };
      pp$3.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$3.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR) {
            return scope;
          }
        }
      };
      pp$3.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
            return scope;
          }
        }
      };
      var Node = function Node2(parser3, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser3.options.locations) {
          this.loc = new SourceLocation(parser3, loc);
        }
        if (parser3.options.directSourceFile) {
          this.sourceFile = parser3.options.directSourceFile;
        }
        if (parser3.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$2 = Parser2.prototype;
      pp$2.startNode = function() {
        return new Node(this, this.start, this.startLoc);
      };
      pp$2.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc);
      };
      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations) {
          node.loc.end = loc;
        }
        if (this.options.ranges) {
          node.range[1] = pos;
        }
        return node;
      }
      pp$2.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$2.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc);
      };
      pp$2.copyNode = function(node) {
        var newNode = new Node(this, node.start, this.startLoc);
        for (var prop in node) {
          newNode[prop] = node[prop];
        }
        return newNode;
      };
      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties = ecma12BinaryProperties;
      var ecma14BinaryProperties = ecma13BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties,
        12: ecma12BinaryProperties,
        13: ecma13BinaryProperties,
        14: ecma14BinaryProperties
      };
      var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
      var unicodeBinaryPropertiesOfStrings = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: ecma14BinaryPropertiesOfStrings
      };
      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues,
        12: ecma12ScriptValues,
        13: ecma13ScriptValues,
        14: ecma14ScriptValues
      };
      var data = {};
      function buildUnicodeData(ecmaVersion2) {
        var d = data[ecmaVersion2] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion2] + " " + unicodeGeneralCategoryValues),
          binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion2]),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
        var ecmaVersion = list[i];
        buildUnicodeData(ecmaVersion);
      }
      var pp$1 = Parser2.prototype;
      var RegExpValidationState = function RegExpValidationState2(parser3) {
        this.parser = parser3;
        this.validFlags = "gim" + (parser3.options.ecmaVersion >= 6 ? "uy" : "") + (parser3.options.ecmaVersion >= 9 ? "s" : "") + (parser3.options.ecmaVersion >= 13 ? "d" : "") + (parser3.options.ecmaVersion >= 15 ? "v" : "");
        this.unicodeProperties = data[parser3.options.ecmaVersion >= 14 ? 14 : parser3.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchV = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
        var unicodeSets = flags.indexOf("v") !== -1;
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
          this.switchU = true;
          this.switchV = true;
          this.switchN = true;
        } else {
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchV = false;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        }
      };
      RegExpValidationState.prototype.raise = function raise(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState.prototype.at = function at(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
        if (forceU === void 0)
          forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState.prototype.current = function current(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
        if (forceU === void 0)
          forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState.prototype.advance = function advance(forceU) {
        if (forceU === void 0)
          forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState.prototype.eat = function eat(ch, forceU) {
        if (forceU === void 0)
          forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
        if (forceU === void 0)
          forceU = false;
        var pos = this.pos;
        for (var i2 = 0, list2 = chs; i2 < list2.length; i2 += 1) {
          var ch = list2[i2];
          var current = this.at(pos, forceU);
          if (current === -1 || current !== ch) {
            return false;
          }
          pos = this.nextIndex(pos, forceU);
        }
        this.pos = pos;
        return true;
      };
      pp$1.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        var u = false;
        var v = false;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
          if (flag === "u") {
            u = true;
          }
          if (flag === "v") {
            v = true;
          }
        }
        if (this.options.ecmaVersion >= 15 && u && v) {
          this.raise(state.start, "Invalid regular expression flag");
        }
      };
      pp$1.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$1.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list2 = state.backReferenceNames; i2 < list2.length; i2 += 1) {
          var name = list2[i2];
          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$1.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$1.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$1.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$1.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start;
        return false;
      };
      pp$1.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0)
          noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$1.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          ) && state.eat(
            58
            /* : */
          )) {
            this.regexp_disjunction(state);
            if (state.eat(
              41
              /* ) */
            )) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$1.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$1.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start;
      };
      pp$1.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$1.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
      }
      pp$1.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start;
        return false;
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$1.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$1.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$1.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$1.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0)
          forceU = false;
        var start = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 56320 && trail <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }
        return false;
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$1.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      var CharSetNone = 0;
      var CharSetOk = 1;
      var CharSetString = 2;
      pp$1.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return CharSetOk;
        }
        var negate = false;
        if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          var result;
          if (state.eat(
            123
            /* { */
          ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
            125
            /* } */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Invalid property name");
            }
            return result;
          }
          state.raise("Invalid property name");
        }
        return CharSetNone;
      };
      function isCharacterClassEscape(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value2 = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value2);
            return CharSetOk;
          }
        }
        state.pos = start;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
        }
        return CharSetNone;
      };
      pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value2) {
        if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name].test(value2)) {
          state.raise("Invalid property value");
        }
      };
      pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (state.unicodeProperties.binary.test(nameOrValue)) {
          return CharSetOk;
        }
        if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
          return CharSetString;
        }
        state.raise("Invalid property name");
      };
      pp$1.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 95;
      }
      pp$1.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
      }
      pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$1.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (!state.eat(
            93
            /* ] */
          )) {
            state.raise("Unterminated character class");
          }
          if (negate && result === CharSetString) {
            state.raise("Negated character class may contain strings");
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_classContents = function(state) {
        if (state.current() === 93) {
          return CharSetOk;
        }
        if (state.switchV) {
          return this.regexp_classSetExpression(state);
        }
        this.regexp_nonEmptyClassRanges(state);
        return CharSetOk;
      };
      pp$1.regexp_nonEmptyClassRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$1.regexp_eatClassAtom = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatClassEscape = function(state) {
        var start = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$1.regexp_classSetExpression = function(state) {
        var result = CharSetOk, subResult;
        if (this.regexp_eatClassSetRange(state))
          ;
        else if (subResult = this.regexp_eatClassSetOperand(state)) {
          if (subResult === CharSetString) {
            result = CharSetString;
          }
          var start = state.pos;
          while (state.eatChars(
            [38, 38]
            /* && */
          )) {
            if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
              if (subResult !== CharSetString) {
                result = CharSetOk;
              }
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
          while (state.eatChars(
            [45, 45]
            /* -- */
          )) {
            if (this.regexp_eatClassSetOperand(state)) {
              continue;
            }
            state.raise("Invalid character in character class");
          }
          if (start !== state.pos) {
            return result;
          }
        } else {
          state.raise("Invalid character in character class");
        }
        for (; ; ) {
          if (this.regexp_eatClassSetRange(state)) {
            continue;
          }
          subResult = this.regexp_eatClassSetOperand(state);
          if (!subResult) {
            return result;
          }
          if (subResult === CharSetString) {
            result = CharSetString;
          }
        }
      };
      pp$1.regexp_eatClassSetRange = function(state) {
        var start = state.pos;
        if (this.regexp_eatClassSetCharacter(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(state)) {
            var right = state.lastIntValue;
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
            return true;
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatClassSetOperand = function(state) {
        if (this.regexp_eatClassSetCharacter(state)) {
          return CharSetOk;
        }
        return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
      };
      pp$1.regexp_eatNestedClass = function(state) {
        var start = state.pos;
        if (state.eat(
          91
          /* [ */
        )) {
          var negate = state.eat(
            94
            /* ^ */
          );
          var result = this.regexp_classContents(state);
          if (state.eat(
            93
            /* ] */
          )) {
            if (negate && result === CharSetString) {
              state.raise("Negated character class may contain strings");
            }
            return result;
          }
          state.pos = start;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          var result$1 = this.regexp_eatCharacterClassEscape(state);
          if (result$1) {
            return result$1;
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_eatClassStringDisjunction = function(state) {
        var start = state.pos;
        if (state.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (state.eat(
            123
            /* { */
          )) {
            var result = this.regexp_classStringDisjunctionContents(state);
            if (state.eat(
              125
              /* } */
            )) {
              return result;
            }
          } else {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return null;
      };
      pp$1.regexp_classStringDisjunctionContents = function(state) {
        var result = this.regexp_classString(state);
        while (state.eat(
          124
          /* | */
        )) {
          if (this.regexp_classString(state) === CharSetString) {
            result = CharSetString;
          }
        }
        return result;
      };
      pp$1.regexp_classString = function(state) {
        var count = 0;
        while (this.regexp_eatClassSetCharacter(state)) {
          count++;
        }
        return count === 1 ? CharSetOk : CharSetString;
      };
      pp$1.regexp_eatClassSetCharacter = function(state) {
        var start = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
            return true;
          }
          if (state.eat(
            98
            /* b */
          )) {
            state.lastIntValue = 8;
            return true;
          }
          state.pos = start;
          return false;
        }
        var ch = state.current();
        if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
          return false;
        }
        if (isClassSetSyntaxCharacter(ch)) {
          return false;
        }
        state.advance();
        state.lastIntValue = ch;
        return true;
      };
      function isClassSetReservedDoublePunctuatorCharacter(ch) {
        return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
      }
      function isClassSetSyntaxCharacter(ch) {
        return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
      }
      pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
        var ch = state.current();
        if (isClassSetReservedPunctuator(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isClassSetReservedPunctuator(ch) {
        return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
      }
      pp$1.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$1.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false;
      };
      pp$1.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start;
      };
      function isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$1.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start;
      };
      function isHexDigit(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$1.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$1.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true;
      };
      var Token = function Token2(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp = Parser2.prototype;
      pp.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp.getToken = function() {
        this.next();
        return new Token(this);
      };
      if (typeof Symbol !== "undefined") {
        pp[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$1.eof,
                value: token
              };
            }
          };
        };
      }
      pp.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$1.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code);
      };
      pp.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 55295 || code >= 56320) {
          return code;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
      };
      pp.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start + 2, end),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start + startSkip, this.pos),
            start,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp.skipSpace = function() {
        loop:
          while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 32:
              case 160:
                ++this.pos;
                break;
              case 13:
                if (this.input.charCodeAt(this.pos + 1) === 10) {
                  ++this.pos;
                }
              case 10:
              case 8232:
              case 8233:
                ++this.pos;
                if (this.options.locations) {
                  ++this.curLine;
                  this.lineStart = this.pos;
                }
                break;
              case 47:
                switch (this.input.charCodeAt(this.pos + 1)) {
                  case 42:
                    this.skipBlockComment();
                    break;
                  case 47:
                    this.skipLineComment(2);
                    break;
                  default:
                    break loop;
                }
                break;
              default:
                if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                  ++this.pos;
                } else {
                  break loop;
                }
            }
          }
      };
      pp.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$1.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$1.dot);
        }
      };
      pp.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.slash, 1);
      };
      pp.readToken_mult_modulo_exp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types$1.star : types$1.modulo;
        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types$1.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp.readToken_pipe_amp = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$1.assign, 3);
            }
          }
          return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
      };
      pp.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.bitwiseXOR, 1);
      };
      pp.readToken_plus_min = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$1.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$1.assign, 2);
        }
        return this.finishOp(types$1.plusMin, 1);
      };
      pp.readToken_lt_gt = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$1.assign, size + 1);
          }
          return this.finishOp(types$1.bitShift, size);
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$1.relational, size);
      };
      pp.readToken_eq_excl = function(code) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$1.arrow);
        }
        return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
      };
      pp.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$1.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$1.assign, 3);
              }
            }
            return this.finishOp(types$1.coalesce, 2);
          }
        }
        return this.finishOp(types$1.question, 1);
      };
      pp.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code = this.fullCharCodeAtPos();
          if (isIdentifierStart(code, true) || code === 92) {
            return this.finishToken(types$1.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.getTokenFromCode = function(code) {
        switch (code) {
          case 46:
            return this.readToken_dot();
          case 40:
            ++this.pos;
            return this.finishToken(types$1.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$1.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$1.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$1.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$1.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$1.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$1.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$1.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$1.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$1.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          case 34:
          case 39:
            return this.readString(code);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code);
          case 60:
          case 62:
            return this.readToken_lt_gt(code);
          case 61:
          case 33:
            return this.readToken_eq_excl(code);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$1.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
      };
      pp.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) {
            this.raise(start, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value2 = null;
        try {
          value2 = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$1.regexp, { pattern, flags, value: value2 });
      };
      pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code;
            continue;
          }
          if (code >= 97) {
            val = code - 97 + 10;
          } else if (code >= 65) {
            val = code - 65 + 10;
          } else if (code >= 48 && code <= 57) {
            val = code - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start || len != null && this.pos - start !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$1.num, val);
      };
      pp.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start, "Invalid number");
        }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) {
          this.raise(start, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt(this.input.slice(start, this.pos));
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$1.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start, "Invalid number");
          }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber(this.input.slice(start, this.pos), octal);
        return this.finishToken(types$1.num, val);
      };
      pp.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code = this.readHexChar(4);
        }
        return code;
      };
      pp.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$1.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR = {};
      pp.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR;
        } else {
          this.raise(position, message);
        }
      };
      pp.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$1.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$1.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$1.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            case "`":
              return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return codePointToString(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine(ch)) {
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp.readWord = function() {
        var word = this.readWord1();
        var type = types$1.name;
        if (this.keywords.test(word)) {
          type = keywords[word];
        }
        return this.finishToken(type, word);
      };
      var version = "8.10.0";
      Parser2.acorn = {
        Parser: Parser2,
        version,
        defaultOptions,
        Position,
        SourceLocation,
        getLineInfo,
        Node,
        TokenType,
        tokTypes: types$1,
        keywordTypes: keywords,
        TokContext,
        tokContexts: types,
        isIdentifierChar,
        isIdentifierStart,
        Token,
        isNewLine,
        lineBreak,
        lineBreakG,
        nonASCIIwhitespace
      };
      function parse2(input, options) {
        return Parser2.parse(input, options);
      }
      function parseExpressionAt(input, pos, options) {
        return Parser2.parseExpressionAt(input, pos, options);
      }
      function tokenizer(input, options) {
        return Parser2.tokenizer(input, options);
      }
      exports3.Node = Node;
      exports3.Parser = Parser2;
      exports3.Position = Position;
      exports3.SourceLocation = SourceLocation;
      exports3.TokContext = TokContext;
      exports3.Token = Token;
      exports3.TokenType = TokenType;
      exports3.defaultOptions = defaultOptions;
      exports3.getLineInfo = getLineInfo;
      exports3.isIdentifierChar = isIdentifierChar;
      exports3.isIdentifierStart = isIdentifierStart;
      exports3.isNewLine = isNewLine;
      exports3.keywordTypes = keywords;
      exports3.lineBreak = lineBreak;
      exports3.lineBreakG = lineBreakG;
      exports3.nonASCIIwhitespace = nonASCIIwhitespace;
      exports3.parse = parse2;
      exports3.parseExpressionAt = parseExpressionAt;
      exports3.tokContexts = types;
      exports3.tokTypes = types$1;
      exports3.tokenizer = tokenizer;
      exports3.version = version;
    });
  }
});

// ../../../node_modules/acorn-walk/dist/walk.js
var require_walk = __commonJS({
  "../../../node_modules/acorn-walk/dist/walk.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory((global2.acorn = global2.acorn || {}, global2.acorn.walk = {})));
    })(exports2, function(exports3) {
      "use strict";
      function simple(node, visitors, baseVisitor, state, override) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        (function c(node2, st, override2) {
          var type = override2 || node2.type, found = visitors[type];
          baseVisitor[type](node2, st, c);
          if (found) {
            found(node2, st);
          }
        })(node, state, override);
      }
      function ancestor(node, visitors, baseVisitor, state, override) {
        var ancestors = [];
        if (!baseVisitor) {
          baseVisitor = base;
        }
        (function c(node2, st, override2) {
          var type = override2 || node2.type, found = visitors[type];
          var isNew = node2 !== ancestors[ancestors.length - 1];
          if (isNew) {
            ancestors.push(node2);
          }
          baseVisitor[type](node2, st, c);
          if (found) {
            found(node2, st || ancestors, ancestors);
          }
          if (isNew) {
            ancestors.pop();
          }
        })(node, state, override);
      }
      function recursive(node, state, funcs, baseVisitor, override) {
        var visitor = funcs ? make(funcs, baseVisitor || void 0) : baseVisitor;
        (function c(node2, st, override2) {
          visitor[override2 || node2.type](node2, st, c);
        })(node, state, override);
      }
      function makeTest(test) {
        if (typeof test === "string") {
          return function(type) {
            return type === test;
          };
        } else if (!test) {
          return function() {
            return true;
          };
        } else {
          return test;
        }
      }
      var Found = function Found2(node, state) {
        this.node = node;
        this.state = state;
      };
      function full(node, callback, baseVisitor, state, override) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var last;
        (function c(node2, st, override2) {
          var type = override2 || node2.type;
          baseVisitor[type](node2, st, c);
          if (last !== node2) {
            callback(node2, st, type);
            last = node2;
          }
        })(node, state, override);
      }
      function fullAncestor(node, callback, baseVisitor, state) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var ancestors = [], last;
        (function c(node2, st, override) {
          var type = override || node2.type;
          var isNew = node2 !== ancestors[ancestors.length - 1];
          if (isNew) {
            ancestors.push(node2);
          }
          baseVisitor[type](node2, st, c);
          if (last !== node2) {
            callback(node2, st || ancestors, ancestors, type);
            last = node2;
          }
          if (isNew) {
            ancestors.pop();
          }
        })(node, state);
      }
      function findNodeAt(node, start, end, test, baseVisitor, state) {
        if (!baseVisitor) {
          baseVisitor = base;
        }
        test = makeTest(test);
        try {
          (function c(node2, st, override) {
            var type = override || node2.type;
            if ((start == null || node2.start <= start) && (end == null || node2.end >= end)) {
              baseVisitor[type](node2, st, c);
            }
            if ((start == null || node2.start === start) && (end == null || node2.end === end) && test(type, node2)) {
              throw new Found(node2, st);
            }
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeAround(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        try {
          (function c(node2, st, override) {
            var type = override || node2.type;
            if (node2.start > pos || node2.end < pos) {
              return;
            }
            baseVisitor[type](node2, st, c);
            if (test(type, node2)) {
              throw new Found(node2, st);
            }
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeAfter(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        try {
          (function c(node2, st, override) {
            if (node2.end < pos) {
              return;
            }
            var type = override || node2.type;
            if (node2.start >= pos && test(type, node2)) {
              throw new Found(node2, st);
            }
            baseVisitor[type](node2, st, c);
          })(node, state);
        } catch (e) {
          if (e instanceof Found) {
            return e;
          }
          throw e;
        }
      }
      function findNodeBefore(node, pos, test, baseVisitor, state) {
        test = makeTest(test);
        if (!baseVisitor) {
          baseVisitor = base;
        }
        var max;
        (function c(node2, st, override) {
          if (node2.start > pos) {
            return;
          }
          var type = override || node2.type;
          if (node2.end <= pos && (!max || max.node.end < node2.end) && test(type, node2)) {
            max = new Found(node2, st);
          }
          baseVisitor[type](node2, st, c);
        })(node, state);
        return max;
      }
      function make(funcs, baseVisitor) {
        var visitor = Object.create(baseVisitor || base);
        for (var type in funcs) {
          visitor[type] = funcs[type];
        }
        return visitor;
      }
      function skipThrough(node, st, c) {
        c(node, st);
      }
      function ignore(_node, _st, _c2) {
      }
      var base = {};
      base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c) {
        for (var i = 0, list = node.body; i < list.length; i += 1) {
          var stmt = list[i];
          c(stmt, st, "Statement");
        }
      };
      base.Statement = skipThrough;
      base.EmptyStatement = ignore;
      base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
        return c(node.expression, st, "Expression");
      };
      base.IfStatement = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Statement");
        if (node.alternate) {
          c(node.alternate, st, "Statement");
        }
      };
      base.LabeledStatement = function(node, st, c) {
        return c(node.body, st, "Statement");
      };
      base.BreakStatement = base.ContinueStatement = ignore;
      base.WithStatement = function(node, st, c) {
        c(node.object, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.SwitchStatement = function(node, st, c) {
        c(node.discriminant, st, "Expression");
        for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {
          var cs = list$1[i$1];
          if (cs.test) {
            c(cs.test, st, "Expression");
          }
          for (var i = 0, list = cs.consequent; i < list.length; i += 1) {
            var cons = list[i];
            c(cons, st, "Statement");
          }
        }
      };
      base.SwitchCase = function(node, st, c) {
        if (node.test) {
          c(node.test, st, "Expression");
        }
        for (var i = 0, list = node.consequent; i < list.length; i += 1) {
          var cons = list[i];
          c(cons, st, "Statement");
        }
      };
      base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
        if (node.argument) {
          c(node.argument, st, "Expression");
        }
      };
      base.ThrowStatement = base.SpreadElement = function(node, st, c) {
        return c(node.argument, st, "Expression");
      };
      base.TryStatement = function(node, st, c) {
        c(node.block, st, "Statement");
        if (node.handler) {
          c(node.handler, st);
        }
        if (node.finalizer) {
          c(node.finalizer, st, "Statement");
        }
      };
      base.CatchClause = function(node, st, c) {
        if (node.param) {
          c(node.param, st, "Pattern");
        }
        c(node.body, st, "Statement");
      };
      base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForStatement = function(node, st, c) {
        if (node.init) {
          c(node.init, st, "ForInit");
        }
        if (node.test) {
          c(node.test, st, "Expression");
        }
        if (node.update) {
          c(node.update, st, "Expression");
        }
        c(node.body, st, "Statement");
      };
      base.ForInStatement = base.ForOfStatement = function(node, st, c) {
        c(node.left, st, "ForInit");
        c(node.right, st, "Expression");
        c(node.body, st, "Statement");
      };
      base.ForInit = function(node, st, c) {
        if (node.type === "VariableDeclaration") {
          c(node, st);
        } else {
          c(node, st, "Expression");
        }
      };
      base.DebuggerStatement = ignore;
      base.FunctionDeclaration = function(node, st, c) {
        return c(node, st, "Function");
      };
      base.VariableDeclaration = function(node, st, c) {
        for (var i = 0, list = node.declarations; i < list.length; i += 1) {
          var decl = list[i];
          c(decl, st);
        }
      };
      base.VariableDeclarator = function(node, st, c) {
        c(node.id, st, "Pattern");
        if (node.init) {
          c(node.init, st, "Expression");
        }
      };
      base.Function = function(node, st, c) {
        if (node.id) {
          c(node.id, st, "Pattern");
        }
        for (var i = 0, list = node.params; i < list.length; i += 1) {
          var param = list[i];
          c(param, st, "Pattern");
        }
        c(node.body, st, node.expression ? "Expression" : "Statement");
      };
      base.Pattern = function(node, st, c) {
        if (node.type === "Identifier") {
          c(node, st, "VariablePattern");
        } else if (node.type === "MemberExpression") {
          c(node, st, "MemberPattern");
        } else {
          c(node, st);
        }
      };
      base.VariablePattern = ignore;
      base.MemberPattern = skipThrough;
      base.RestElement = function(node, st, c) {
        return c(node.argument, st, "Pattern");
      };
      base.ArrayPattern = function(node, st, c) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var elt = list[i];
          if (elt) {
            c(elt, st, "Pattern");
          }
        }
      };
      base.ObjectPattern = function(node, st, c) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          if (prop.type === "Property") {
            if (prop.computed) {
              c(prop.key, st, "Expression");
            }
            c(prop.value, st, "Pattern");
          } else if (prop.type === "RestElement") {
            c(prop.argument, st, "Pattern");
          }
        }
      };
      base.Expression = skipThrough;
      base.ThisExpression = base.Super = base.MetaProperty = ignore;
      base.ArrayExpression = function(node, st, c) {
        for (var i = 0, list = node.elements; i < list.length; i += 1) {
          var elt = list[i];
          if (elt) {
            c(elt, st, "Expression");
          }
        }
      };
      base.ObjectExpression = function(node, st, c) {
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          c(prop, st);
        }
      };
      base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
      base.SequenceExpression = function(node, st, c) {
        for (var i = 0, list = node.expressions; i < list.length; i += 1) {
          var expr = list[i];
          c(expr, st, "Expression");
        }
      };
      base.TemplateLiteral = function(node, st, c) {
        for (var i = 0, list = node.quasis; i < list.length; i += 1) {
          var quasi = list[i];
          c(quasi, st);
        }
        for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
          var expr = list$1[i$1];
          c(expr, st, "Expression");
        }
      };
      base.TemplateElement = ignore;
      base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
        c(node.argument, st, "Expression");
      };
      base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
        c(node.left, st, "Expression");
        c(node.right, st, "Expression");
      };
      base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
        c(node.left, st, "Pattern");
        c(node.right, st, "Expression");
      };
      base.ConditionalExpression = function(node, st, c) {
        c(node.test, st, "Expression");
        c(node.consequent, st, "Expression");
        c(node.alternate, st, "Expression");
      };
      base.NewExpression = base.CallExpression = function(node, st, c) {
        c(node.callee, st, "Expression");
        if (node.arguments) {
          for (var i = 0, list = node.arguments; i < list.length; i += 1) {
            var arg = list[i];
            c(arg, st, "Expression");
          }
        }
      };
      base.MemberExpression = function(node, st, c) {
        c(node.object, st, "Expression");
        if (node.computed) {
          c(node.property, st, "Expression");
        }
      };
      base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
        if (node.declaration) {
          c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
        }
        if (node.source) {
          c(node.source, st, "Expression");
        }
      };
      base.ExportAllDeclaration = function(node, st, c) {
        if (node.exported) {
          c(node.exported, st);
        }
        c(node.source, st, "Expression");
      };
      base.ImportDeclaration = function(node, st, c) {
        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
          var spec = list[i];
          c(spec, st);
        }
        c(node.source, st, "Expression");
      };
      base.ImportExpression = function(node, st, c) {
        c(node.source, st, "Expression");
      };
      base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
      base.TaggedTemplateExpression = function(node, st, c) {
        c(node.tag, st, "Expression");
        c(node.quasi, st, "Expression");
      };
      base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
        return c(node, st, "Class");
      };
      base.Class = function(node, st, c) {
        if (node.id) {
          c(node.id, st, "Pattern");
        }
        if (node.superClass) {
          c(node.superClass, st, "Expression");
        }
        c(node.body, st);
      };
      base.ClassBody = function(node, st, c) {
        for (var i = 0, list = node.body; i < list.length; i += 1) {
          var elt = list[i];
          c(elt, st);
        }
      };
      base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c) {
        if (node.computed) {
          c(node.key, st, "Expression");
        }
        if (node.value) {
          c(node.value, st, "Expression");
        }
      };
      exports3.ancestor = ancestor;
      exports3.base = base;
      exports3.findNodeAfter = findNodeAfter;
      exports3.findNodeAround = findNodeAround;
      exports3.findNodeAt = findNodeAt;
      exports3.findNodeBefore = findNodeBefore;
      exports3.full = full;
      exports3.fullAncestor = fullAncestor;
      exports3.make = make;
      exports3.recursive = recursive;
      exports3.simple = simple;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internal-repl-await.js
var require_node_internal_repl_await = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internal-repl-await.js"(exports2, module2) {
    "use strict";
    var {
      ArrayFrom,
      ArrayPrototypeForEach,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypePop,
      ArrayPrototypePush,
      FunctionPrototype,
      ObjectKeys,
      RegExpPrototypeSymbolReplace,
      StringPrototypeEndsWith,
      StringPrototypeIncludes,
      StringPrototypeIndexOf,
      StringPrototypeRepeat,
      StringPrototypeSplit,
      StringPrototypeStartsWith,
      SyntaxError: SyntaxError2
    } = require_node_primordials();
    var parser3 = require_acorn().Parser;
    var walk = require_walk();
    var { Recoverable } = require("repl");
    function isTopLevelDeclaration(state) {
      return state.ancestors[state.ancestors.length - 2] === state.body;
    }
    var noop = FunctionPrototype;
    var visitorsWithoutAncestors = {
      ClassDeclaration(node, state, c) {
        if (isTopLevelDeclaration(state)) {
          state.prepend(node, `${node.id.name}=`);
          ArrayPrototypePush(
            state.hoistedDeclarationStatements,
            `let ${node.id.name}; `
          );
        }
        walk.base.ClassDeclaration(node, state, c);
      },
      ForOfStatement(node, state, c) {
        if (node.await === true) {
          state.containsAwait = true;
        }
        walk.base.ForOfStatement(node, state, c);
      },
      FunctionDeclaration(node, state, c) {
        state.prepend(node, `${node.id.name}=`);
        ArrayPrototypePush(
          state.hoistedDeclarationStatements,
          `var ${node.id.name}; `
        );
      },
      FunctionExpression: noop,
      ArrowFunctionExpression: noop,
      MethodDefinition: noop,
      AwaitExpression(node, state, c) {
        state.containsAwait = true;
        walk.base.AwaitExpression(node, state, c);
      },
      ReturnStatement(node, state, c) {
        state.containsReturn = true;
        walk.base.ReturnStatement(node, state, c);
      },
      VariableDeclaration(node, state, c) {
        const variableKind = node.kind;
        const isIterableForDeclaration = ArrayPrototypeIncludes(
          ["ForOfStatement", "ForInStatement"],
          state.ancestors[state.ancestors.length - 2].type
        );
        if (variableKind === "var" || isTopLevelDeclaration(state)) {
          let registerVariableDeclarationIdentifiers = function(node2) {
            switch (node2.type) {
              case "Identifier":
                ArrayPrototypePush(
                  variableIdentifiersToHoist[variableKind === "var" ? 0 : 1][1],
                  node2.name
                );
                break;
              case "ObjectPattern":
                ArrayPrototypeForEach(node2.properties, (property) => {
                  registerVariableDeclarationIdentifiers(property.value);
                });
                break;
              case "ArrayPattern":
                ArrayPrototypeForEach(node2.elements, (element) => {
                  registerVariableDeclarationIdentifiers(element);
                });
                break;
            }
          };
          state.replace(
            node.start,
            node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0),
            variableKind === "var" && isIterableForDeclaration ? "" : "void" + (node.declarations.length === 1 ? "" : " (")
          );
          if (!isIterableForDeclaration) {
            ArrayPrototypeForEach(node.declarations, (decl) => {
              state.prepend(decl, "(");
              state.append(decl, decl.init ? ")" : "=undefined)");
            });
            if (node.declarations.length !== 1) {
              state.append(node.declarations[node.declarations.length - 1], ")");
            }
          }
          const variableIdentifiersToHoist = [
            ["var", []],
            ["let", []]
          ];
          ArrayPrototypeForEach(node.declarations, (decl) => {
            registerVariableDeclarationIdentifiers(decl.id);
          });
          ArrayPrototypeForEach(
            variableIdentifiersToHoist,
            ({ 0: kind, 1: identifiers }) => {
              if (identifiers.length > 0) {
                ArrayPrototypePush(
                  state.hoistedDeclarationStatements,
                  `${kind} ${ArrayPrototypeJoin(identifiers, ", ")}; `
                );
              }
            }
          );
        }
        walk.base.VariableDeclaration(node, state, c);
      }
    };
    var visitors = {};
    for (const nodeType of ObjectKeys(walk.base)) {
      const callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];
      visitors[nodeType] = (node, state, c) => {
        const isNew = node !== state.ancestors[state.ancestors.length - 1];
        if (isNew) {
          ArrayPrototypePush(state.ancestors, node);
        }
        callback(node, state, c);
        if (isNew) {
          ArrayPrototypePop(state.ancestors);
        }
      };
    }
    function processTopLevelAwait(src) {
      const wrapPrefix = "(async () => { ";
      const wrapped = `${wrapPrefix}${src} })()`;
      const wrappedArray = ArrayFrom(wrapped);
      let root;
      try {
        root = parser3.parse(wrapped, { ecmaVersion: "latest" });
      } catch (e) {
        if (StringPrototypeStartsWith(e.message, "Unterminated "))
          throw new Recoverable(e);
        const awaitPos = StringPrototypeIndexOf(src, "await");
        const errPos = e.pos - wrapPrefix.length;
        if (awaitPos > errPos)
          return null;
        if (errPos === awaitPos + 6 && StringPrototypeIncludes(e.message, "Expecting Unicode escape sequence"))
          return null;
        if (errPos === awaitPos + 7 && StringPrototypeIncludes(e.message, "Unexpected token"))
          return null;
        const line = e.loc.line;
        const column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;
        let message = "\n" + StringPrototypeSplit(src, "\n")[line - 1] + "\n" + StringPrototypeRepeat(" ", column) + "^\n\n" + RegExpPrototypeSymbolReplace(/ \([^)]+\)/, e.message, "");
        if (StringPrototypeEndsWith(message, "Unexpected token"))
          message += " '" + // Wrapper end may cause acorn to report error position after the source
          (src.length - 1 >= e.pos - wrapPrefix.length ? src[e.pos - wrapPrefix.length] : src[src.length - 1]) + "'";
        throw new SyntaxError2(message);
      }
      const body = root.body[0].expression.callee.body;
      const state = {
        body,
        ancestors: [],
        hoistedDeclarationStatements: [],
        replace(from, to, str) {
          for (let i = from; i < to; i++) {
            wrappedArray[i] = "";
          }
          if (from === to)
            str += wrappedArray[from];
          wrappedArray[from] = str;
        },
        prepend(node, str) {
          wrappedArray[node.start] = str + wrappedArray[node.start];
        },
        append(node, str) {
          wrappedArray[node.end - 1] += str;
        },
        containsAwait: false,
        containsReturn: false
      };
      walk.recursive(body, state, visitors);
      if (!state.containsAwait || state.containsReturn) {
        return null;
      }
      const last = body.body[body.body.length - 1];
      if (last.type === "ExpressionStatement") {
        state.prepend(last, "return (");
        state.append(last.expression, ")");
      }
      return ArrayPrototypeJoin(state.hoistedDeclarationStatements, "") + ArrayPrototypeJoin(wrappedArray, "");
    }
    module2.exports = {
      processTopLevelAwait
    };
  }
});

// ../../../node_modules/diff/lib/diff/base.js
var require_base = __commonJS({
  "../../../node_modules/diff/lib/diff/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = Diff;
    function Diff() {
    }
    Diff.prototype = {
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      diff: function diff(oldString, newString) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var callback = options.callback;
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        this.options = options;
        var self2 = this;
        function done(value2) {
          if (callback) {
            setTimeout(function() {
              callback(void 0, value2);
            }, 0);
            return true;
          } else {
            return value2;
          }
        }
        oldString = this.castInput(oldString);
        newString = this.castInput(newString);
        oldString = this.removeEmpty(this.tokenize(oldString));
        newString = this.removeEmpty(this.tokenize(newString));
        var newLen = newString.length, oldLen = oldString.length;
        var editLength = 1;
        var maxEditLength = newLen + oldLen;
        var bestPath = [{
          newPos: -1,
          components: []
        }];
        var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
        if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
          return done([{
            value: this.join(newString),
            count: newString.length
          }]);
        }
        function execEditLength() {
          for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
            var basePath = (
              /*istanbul ignore start*/
              void 0
            );
            var addPath = bestPath[diagonalPath - 1], removePath = bestPath[diagonalPath + 1], _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
            if (addPath) {
              bestPath[diagonalPath - 1] = void 0;
            }
            var canAdd = addPath && addPath.newPos + 1 < newLen, canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
            if (!canAdd && !canRemove) {
              bestPath[diagonalPath] = void 0;
              continue;
            }
            if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
              basePath = clonePath(removePath);
              self2.pushComponent(basePath.components, void 0, true);
            } else {
              basePath = addPath;
              basePath.newPos++;
              self2.pushComponent(basePath.components, true, void 0);
            }
            _oldPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
            if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
              return done(buildValues(self2, basePath.components, newString, oldString, self2.useLongestToken));
            } else {
              bestPath[diagonalPath] = basePath;
            }
          }
          editLength++;
        }
        if (callback) {
          (function exec() {
            setTimeout(function() {
              if (editLength > maxEditLength) {
                return callback();
              }
              if (!execEditLength()) {
                exec();
              }
            }, 0);
          })();
        } else {
          while (editLength <= maxEditLength) {
            var ret = execEditLength();
            if (ret) {
              return ret;
            }
          }
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      pushComponent: function pushComponent(components, added, removed) {
        var last = components[components.length - 1];
        if (last && last.added === added && last.removed === removed) {
          components[components.length - 1] = {
            count: last.count + 1,
            added,
            removed
          };
        } else {
          components.push({
            count: 1,
            added,
            removed
          });
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
        var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = 0;
        while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
          newPos++;
          oldPos++;
          commonCount++;
        }
        if (commonCount) {
          basePath.components.push({
            count: commonCount
          });
        }
        basePath.newPos = newPos;
        return oldPos;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      equals: function equals(left, right) {
        if (this.options.comparator) {
          return this.options.comparator(left, right);
        } else {
          return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
        }
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      removeEmpty: function removeEmpty(array) {
        var ret = [];
        for (var i = 0; i < array.length; i++) {
          if (array[i]) {
            ret.push(array[i]);
          }
        }
        return ret;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      castInput: function castInput(value2) {
        return value2;
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      tokenize: function tokenize(value2) {
        return value2.split("");
      },
      /*istanbul ignore start*/
      /*istanbul ignore end*/
      join: function join16(chars) {
        return chars.join("");
      }
    };
    function buildValues(diff, components, newString, oldString, useLongestToken) {
      var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
      for (; componentPos < componentLen; componentPos++) {
        var component = components[componentPos];
        if (!component.removed) {
          if (!component.added && useLongestToken) {
            var value2 = newString.slice(newPos, newPos + component.count);
            value2 = value2.map(function(value3, i) {
              var oldValue = oldString[oldPos + i];
              return oldValue.length > value3.length ? oldValue : value3;
            });
            component.value = diff.join(value2);
          } else {
            component.value = diff.join(newString.slice(newPos, newPos + component.count));
          }
          newPos += component.count;
          if (!component.added) {
            oldPos += component.count;
          }
        } else {
          component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
          oldPos += component.count;
          if (componentPos && components[componentPos - 1].added) {
            var tmp = components[componentPos - 1];
            components[componentPos - 1] = components[componentPos];
            components[componentPos] = tmp;
          }
        }
      }
      var lastComponent = components[componentLen - 1];
      if (componentLen > 1 && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
        components[componentLen - 2].value += lastComponent.value;
        components.pop();
      }
      return components;
    }
    function clonePath(path5) {
      return {
        newPos: path5.newPos,
        components: path5.components.slice(0)
      };
    }
  }
});

// ../../../node_modules/diff/lib/diff/character.js
var require_character = __commonJS({
  "../../../node_modules/diff/lib/diff/character.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffChars = diffChars;
    exports2.characterDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var characterDiff = new /*istanbul ignore start*/
    _base.default();
    exports2.characterDiff = characterDiff;
    function diffChars(oldStr, newStr, options) {
      return characterDiff.diff(oldStr, newStr, options);
    }
  }
});

// ../../../node_modules/diff/lib/util/params.js
var require_params = __commonJS({
  "../../../node_modules/diff/lib/util/params.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.generateOptions = generateOptions;
    function generateOptions(options, defaults) {
      if (typeof options === "function") {
        defaults.callback = options;
      } else if (options) {
        for (var name in options) {
          if (options.hasOwnProperty(name)) {
            defaults[name] = options[name];
          }
        }
      }
      return defaults;
    }
  }
});

// ../../../node_modules/diff/lib/diff/word.js
var require_word = __commonJS({
  "../../../node_modules/diff/lib/diff/word.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffWords = diffWords;
    exports2.diffWordsWithSpace = diffWordsWithSpace;
    exports2.wordDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _params = require_params();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
    var reWhitespace = /\S/;
    var wordDiff = new /*istanbul ignore start*/
    _base.default();
    exports2.wordDiff = wordDiff;
    wordDiff.equals = function(left, right) {
      if (this.options.ignoreCase) {
        left = left.toLowerCase();
        right = right.toLowerCase();
      }
      return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
    };
    wordDiff.tokenize = function(value2) {
      var tokens = value2.split(/(\s+|[()[\]{}'"]|\b)/);
      for (var i = 0; i < tokens.length - 1; i++) {
        if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
          tokens[i] += tokens[i + 2];
          tokens.splice(i + 1, 2);
          i--;
        }
      }
      return tokens;
    };
    function diffWords(oldStr, newStr, options) {
      options = /*istanbul ignore start*/
      (0, /*istanbul ignore end*/
      /*istanbul ignore start*/
      _params.generateOptions)(options, {
        ignoreWhitespace: true
      });
      return wordDiff.diff(oldStr, newStr, options);
    }
    function diffWordsWithSpace(oldStr, newStr, options) {
      return wordDiff.diff(oldStr, newStr, options);
    }
  }
});

// ../../../node_modules/diff/lib/diff/line.js
var require_line = __commonJS({
  "../../../node_modules/diff/lib/diff/line.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffLines = diffLines;
    exports2.diffTrimmedLines = diffTrimmedLines;
    exports2.lineDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _params = require_params();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var lineDiff = new /*istanbul ignore start*/
    _base.default();
    exports2.lineDiff = lineDiff;
    lineDiff.tokenize = function(value2) {
      var retLines = [], linesAndNewlines = value2.split(/(\n|\r\n)/);
      if (!linesAndNewlines[linesAndNewlines.length - 1]) {
        linesAndNewlines.pop();
      }
      for (var i = 0; i < linesAndNewlines.length; i++) {
        var line = linesAndNewlines[i];
        if (i % 2 && !this.options.newlineIsToken) {
          retLines[retLines.length - 1] += line;
        } else {
          if (this.options.ignoreWhitespace) {
            line = line.trim();
          }
          retLines.push(line);
        }
      }
      return retLines;
    };
    function diffLines(oldStr, newStr, callback) {
      return lineDiff.diff(oldStr, newStr, callback);
    }
    function diffTrimmedLines(oldStr, newStr, callback) {
      var options = (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _params.generateOptions)(callback, {
          ignoreWhitespace: true
        })
      );
      return lineDiff.diff(oldStr, newStr, options);
    }
  }
});

// ../../../node_modules/diff/lib/diff/sentence.js
var require_sentence = __commonJS({
  "../../../node_modules/diff/lib/diff/sentence.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffSentences = diffSentences;
    exports2.sentenceDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var sentenceDiff = new /*istanbul ignore start*/
    _base.default();
    exports2.sentenceDiff = sentenceDiff;
    sentenceDiff.tokenize = function(value2) {
      return value2.split(/(\S.+?[.!?])(?=\s+|$)/);
    };
    function diffSentences(oldStr, newStr, callback) {
      return sentenceDiff.diff(oldStr, newStr, callback);
    }
  }
});

// ../../../node_modules/diff/lib/diff/css.js
var require_css = __commonJS({
  "../../../node_modules/diff/lib/diff/css.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffCss = diffCss;
    exports2.cssDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var cssDiff = new /*istanbul ignore start*/
    _base.default();
    exports2.cssDiff = cssDiff;
    cssDiff.tokenize = function(value2) {
      return value2.split(/([{}:;,]|\s+)/);
    };
    function diffCss(oldStr, newStr, callback) {
      return cssDiff.diff(oldStr, newStr, callback);
    }
  }
});

// ../../../node_modules/diff/lib/diff/json.js
var require_json2 = __commonJS({
  "../../../node_modules/diff/lib/diff/json.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffJson = diffJson;
    exports2.canonicalize = canonicalize;
    exports2.jsonDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    var _line = require_line();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var objectPrototypeToString = Object.prototype.toString;
    var jsonDiff = new /*istanbul ignore start*/
    _base.default();
    exports2.jsonDiff = jsonDiff;
    jsonDiff.useLongestToken = true;
    jsonDiff.tokenize = /*istanbul ignore start*/
    _line.lineDiff.tokenize;
    jsonDiff.castInput = function(value2) {
      var _this$options = (
        /*istanbul ignore end*/
        this.options
      ), undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
        return (
          /*istanbul ignore end*/
          typeof v === "undefined" ? undefinedReplacement : v
        );
      } : _this$options$stringi;
      return typeof value2 === "string" ? value2 : JSON.stringify(canonicalize(value2, null, null, stringifyReplacer), stringifyReplacer, "  ");
    };
    jsonDiff.equals = function(left, right) {
      return (
        /*istanbul ignore start*/
        _base.default.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"))
      );
    };
    function diffJson(oldObj, newObj, options) {
      return jsonDiff.diff(oldObj, newObj, options);
    }
    function canonicalize(obj, stack, replacementStack, replacer, key) {
      stack = stack || [];
      replacementStack = replacementStack || [];
      if (replacer) {
        obj = replacer(key, obj);
      }
      var i;
      for (i = 0; i < stack.length; i += 1) {
        if (stack[i] === obj) {
          return replacementStack[i];
        }
      }
      var canonicalizedObj;
      if ("[object Array]" === objectPrototypeToString.call(obj)) {
        stack.push(obj);
        canonicalizedObj = new Array(obj.length);
        replacementStack.push(canonicalizedObj);
        for (i = 0; i < obj.length; i += 1) {
          canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
        }
        stack.pop();
        replacementStack.pop();
        return canonicalizedObj;
      }
      if (obj && obj.toJSON) {
        obj = obj.toJSON();
      }
      if (
        /*istanbul ignore start*/
        _typeof(
          /*istanbul ignore end*/
          obj
        ) === "object" && obj !== null
      ) {
        stack.push(obj);
        canonicalizedObj = {};
        replacementStack.push(canonicalizedObj);
        var sortedKeys = [], _key;
        for (_key in obj) {
          if (obj.hasOwnProperty(_key)) {
            sortedKeys.push(_key);
          }
        }
        sortedKeys.sort();
        for (i = 0; i < sortedKeys.length; i += 1) {
          _key = sortedKeys[i];
          canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
        }
        stack.pop();
        replacementStack.pop();
      } else {
        canonicalizedObj = obj;
      }
      return canonicalizedObj;
    }
  }
});

// ../../../node_modules/diff/lib/diff/array.js
var require_array = __commonJS({
  "../../../node_modules/diff/lib/diff/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diffArrays = diffArrays;
    exports2.arrayDiff = void 0;
    var _base = _interopRequireDefault(require_base());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var arrayDiff = new /*istanbul ignore start*/
    _base.default();
    exports2.arrayDiff = arrayDiff;
    arrayDiff.tokenize = function(value2) {
      return value2.slice();
    };
    arrayDiff.join = arrayDiff.removeEmpty = function(value2) {
      return value2;
    };
    function diffArrays(oldArr, newArr, callback) {
      return arrayDiff.diff(oldArr, newArr, callback);
    }
  }
});

// ../../../node_modules/diff/lib/patch/parse.js
var require_parse2 = __commonJS({
  "../../../node_modules/diff/lib/patch/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parsePatch = parsePatch;
    function parsePatch(uniDiff) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/), delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [], list = [], i = 0;
      function parseIndex() {
        var index = {};
        list.push(index);
        while (i < diffstr.length) {
          var line = diffstr[i];
          if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
            break;
          }
          var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
          if (header) {
            index.index = header[1];
          }
          i++;
        }
        parseFileHeader(index);
        parseFileHeader(index);
        index.hunks = [];
        while (i < diffstr.length) {
          var _line = diffstr[i];
          if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
            break;
          } else if (/^@@/.test(_line)) {
            index.hunks.push(parseHunk());
          } else if (_line && options.strict) {
            throw new Error("Unknown line " + (i + 1) + " " + JSON.stringify(_line));
          } else {
            i++;
          }
        }
      }
      function parseFileHeader(index) {
        var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);
        if (fileHeader) {
          var keyPrefix = fileHeader[1] === "---" ? "old" : "new";
          var data = fileHeader[2].split("	", 2);
          var fileName = data[0].replace(/\\\\/g, "\\");
          if (/^".*"$/.test(fileName)) {
            fileName = fileName.substr(1, fileName.length - 2);
          }
          index[keyPrefix + "FileName"] = fileName;
          index[keyPrefix + "Header"] = (data[1] || "").trim();
          i++;
        }
      }
      function parseHunk() {
        var chunkHeaderIndex = i, chunkHeaderLine = diffstr[i++], chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
        var hunk = {
          oldStart: +chunkHeader[1],
          oldLines: +chunkHeader[2] || 1,
          newStart: +chunkHeader[3],
          newLines: +chunkHeader[4] || 1,
          lines: [],
          linedelimiters: []
        };
        var addCount = 0, removeCount = 0;
        for (; i < diffstr.length; i++) {
          if (diffstr[i].indexOf("--- ") === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf("+++ ") === 0 && diffstr[i + 2].indexOf("@@") === 0) {
            break;
          }
          var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? " " : diffstr[i][0];
          if (operation === "+" || operation === "-" || operation === " " || operation === "\\") {
            hunk.lines.push(diffstr[i]);
            hunk.linedelimiters.push(delimiters[i] || "\n");
            if (operation === "+") {
              addCount++;
            } else if (operation === "-") {
              removeCount++;
            } else if (operation === " ") {
              addCount++;
              removeCount++;
            }
          } else {
            break;
          }
        }
        if (!addCount && hunk.newLines === 1) {
          hunk.newLines = 0;
        }
        if (!removeCount && hunk.oldLines === 1) {
          hunk.oldLines = 0;
        }
        if (options.strict) {
          if (addCount !== hunk.newLines) {
            throw new Error("Added line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
          if (removeCount !== hunk.oldLines) {
            throw new Error("Removed line count did not match for hunk at line " + (chunkHeaderIndex + 1));
          }
        }
        return hunk;
      }
      while (i < diffstr.length) {
        parseIndex();
      }
      return list;
    }
  }
});

// ../../../node_modules/diff/lib/util/distance-iterator.js
var require_distance_iterator = __commonJS({
  "../../../node_modules/diff/lib/util/distance-iterator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    function _default(start, minLine, maxLine) {
      var wantForward = true, backwardExhausted = false, forwardExhausted = false, localOffset = 1;
      return function iterator() {
        if (wantForward && !forwardExhausted) {
          if (backwardExhausted) {
            localOffset++;
          } else {
            wantForward = false;
          }
          if (start + localOffset <= maxLine) {
            return localOffset;
          }
          forwardExhausted = true;
        }
        if (!backwardExhausted) {
          if (!forwardExhausted) {
            wantForward = true;
          }
          if (minLine <= start - localOffset) {
            return -localOffset++;
          }
          backwardExhausted = true;
          return iterator();
        }
      };
    }
  }
});

// ../../../node_modules/diff/lib/patch/apply.js
var require_apply = __commonJS({
  "../../../node_modules/diff/lib/patch/apply.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.applyPatch = applyPatch;
    exports2.applyPatches = applyPatches;
    var _parse = require_parse2();
    var _distanceIterator = _interopRequireDefault(require_distance_iterator());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function applyPatch(source, uniDiff) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (typeof uniDiff === "string") {
        uniDiff = /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _parse.parsePatch)(uniDiff);
      }
      if (Array.isArray(uniDiff)) {
        if (uniDiff.length > 1) {
          throw new Error("applyPatch only works with a single input.");
        }
        uniDiff = uniDiff[0];
      }
      var lines = source.split(/\r\n|[\n\v\f\r\x85]/), delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [], hunks = uniDiff.hunks, compareLine = options.compareLine || function(lineNumber, line2, operation2, patchContent) {
        return (
          /*istanbul ignore end*/
          line2 === patchContent
        );
      }, errorCount = 0, fuzzFactor = options.fuzzFactor || 0, minLine = 0, offset = 0, removeEOFNL, addEOFNL;
      function hunkFits(hunk2, toPos2) {
        for (var j2 = 0; j2 < hunk2.lines.length; j2++) {
          var line2 = hunk2.lines[j2], operation2 = line2.length > 0 ? line2[0] : " ", content2 = line2.length > 0 ? line2.substr(1) : line2;
          if (operation2 === " " || operation2 === "-") {
            if (!compareLine(toPos2 + 1, lines[toPos2], operation2, content2)) {
              errorCount++;
              if (errorCount > fuzzFactor) {
                return false;
              }
            }
            toPos2++;
          }
        }
        return true;
      }
      for (var i = 0; i < hunks.length; i++) {
        var hunk = hunks[i], maxLine = lines.length - hunk.oldLines, localOffset = 0, toPos = offset + hunk.oldStart - 1;
        var iterator = (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _distanceIterator.default)(toPos, minLine, maxLine)
        );
        for (; localOffset !== void 0; localOffset = iterator()) {
          if (hunkFits(hunk, toPos + localOffset)) {
            hunk.offset = offset += localOffset;
            break;
          }
        }
        if (localOffset === void 0) {
          return false;
        }
        minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
      }
      var diffOffset = 0;
      for (var _i = 0; _i < hunks.length; _i++) {
        var _hunk = hunks[_i], _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;
        diffOffset += _hunk.newLines - _hunk.oldLines;
        if (_toPos < 0) {
          _toPos = 0;
        }
        for (var j = 0; j < _hunk.lines.length; j++) {
          var line = _hunk.lines[j], operation = line.length > 0 ? line[0] : " ", content = line.length > 0 ? line.substr(1) : line, delimiter = _hunk.linedelimiters[j];
          if (operation === " ") {
            _toPos++;
          } else if (operation === "-") {
            lines.splice(_toPos, 1);
            delimiters.splice(_toPos, 1);
          } else if (operation === "+") {
            lines.splice(_toPos, 0, content);
            delimiters.splice(_toPos, 0, delimiter);
            _toPos++;
          } else if (operation === "\\") {
            var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
            if (previousOperation === "+") {
              removeEOFNL = true;
            } else if (previousOperation === "-") {
              addEOFNL = true;
            }
          }
        }
      }
      if (removeEOFNL) {
        while (!lines[lines.length - 1]) {
          lines.pop();
          delimiters.pop();
        }
      } else if (addEOFNL) {
        lines.push("");
        delimiters.push("\n");
      }
      for (var _k = 0; _k < lines.length - 1; _k++) {
        lines[_k] = lines[_k] + delimiters[_k];
      }
      return lines.join("");
    }
    function applyPatches(uniDiff, options) {
      if (typeof uniDiff === "string") {
        uniDiff = /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _parse.parsePatch)(uniDiff);
      }
      var currentIndex = 0;
      function processIndex() {
        var index = uniDiff[currentIndex++];
        if (!index) {
          return options.complete();
        }
        options.loadFile(index, function(err, data) {
          if (err) {
            return options.complete(err);
          }
          var updatedContent = applyPatch(data, index, options);
          options.patched(index, updatedContent, function(err2) {
            if (err2) {
              return options.complete(err2);
            }
            processIndex();
          });
        });
      }
      processIndex();
    }
  }
});

// ../../../node_modules/diff/lib/patch/create.js
var require_create2 = __commonJS({
  "../../../node_modules/diff/lib/patch/create.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.structuredPatch = structuredPatch;
    exports2.createTwoFilesPatch = createTwoFilesPatch;
    exports2.createPatch = createPatch;
    var _line = require_line();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
    }
    function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      if (!options) {
        options = {};
      }
      if (typeof options.context === "undefined") {
        options.context = 4;
      }
      var diff = (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _line.diffLines)(oldStr, newStr, options)
      );
      diff.push({
        value: "",
        lines: []
      });
      function contextLines(lines) {
        return lines.map(function(entry) {
          return " " + entry;
        });
      }
      var hunks = [];
      var oldRangeStart = 0, newRangeStart = 0, curRange = [], oldLine = 1, newLine = 1;
      var _loop = function _loop2(i2) {
        var current = diff[i2], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
        current.lines = lines;
        if (current.added || current.removed) {
          var _curRange;
          if (!oldRangeStart) {
            var prev = diff[i2 - 1];
            oldRangeStart = oldLine;
            newRangeStart = newLine;
            if (prev) {
              curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
              oldRangeStart -= curRange.length;
              newRangeStart -= curRange.length;
            }
          }
          (_curRange = /*istanbul ignore end*/
          curRange).push.apply(
            /*istanbul ignore start*/
            _curRange,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              lines.map(function(entry) {
                return (current.added ? "+" : "-") + entry;
              })
            )
          );
          if (current.added) {
            newLine += lines.length;
          } else {
            oldLine += lines.length;
          }
        } else {
          if (oldRangeStart) {
            if (lines.length <= options.context * 2 && i2 < diff.length - 2) {
              var _curRange2;
              (_curRange2 = /*istanbul ignore end*/
              curRange).push.apply(
                /*istanbul ignore start*/
                _curRange2,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  contextLines(lines)
                )
              );
            } else {
              var _curRange3;
              var contextSize = Math.min(lines.length, options.context);
              (_curRange3 = /*istanbul ignore end*/
              curRange).push.apply(
                /*istanbul ignore start*/
                _curRange3,
                /*istanbul ignore start*/
                _toConsumableArray(
                  /*istanbul ignore end*/
                  contextLines(lines.slice(0, contextSize))
                )
              );
              var hunk = {
                oldStart: oldRangeStart,
                oldLines: oldLine - oldRangeStart + contextSize,
                newStart: newRangeStart,
                newLines: newLine - newRangeStart + contextSize,
                lines: curRange
              };
              if (i2 >= diff.length - 2 && lines.length <= options.context) {
                var oldEOFNewline = /\n$/.test(oldStr);
                var newEOFNewline = /\n$/.test(newStr);
                var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;
                if (!oldEOFNewline && noNlBeforeAdds) {
                  curRange.splice(hunk.oldLines, 0, "\\ No newline at end of file");
                }
                if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                  curRange.push("\\ No newline at end of file");
                }
              }
              hunks.push(hunk);
              oldRangeStart = 0;
              newRangeStart = 0;
              curRange = [];
            }
          }
          oldLine += lines.length;
          newLine += lines.length;
        }
      };
      for (var i = 0; i < diff.length; i++) {
        _loop(
          /*istanbul ignore end*/
          i
        );
      }
      return {
        oldFileName,
        newFileName,
        oldHeader,
        newHeader,
        hunks
      };
    }
    function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
      var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
      var ret = [];
      if (oldFileName == newFileName) {
        ret.push("Index: " + oldFileName);
      }
      ret.push("===================================================================");
      ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
      ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
      for (var i = 0; i < diff.hunks.length; i++) {
        var hunk = diff.hunks[i];
        ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
        ret.push.apply(ret, hunk.lines);
      }
      return ret.join("\n") + "\n";
    }
    function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
      return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
    }
  }
});

// ../../../node_modules/diff/lib/util/array.js
var require_array2 = __commonJS({
  "../../../node_modules/diff/lib/util/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.arrayEqual = arrayEqual;
    exports2.arrayStartsWith = arrayStartsWith;
    function arrayEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      return arrayStartsWith(a, b);
    }
    function arrayStartsWith(array, start) {
      if (start.length > array.length) {
        return false;
      }
      for (var i = 0; i < start.length; i++) {
        if (start[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
  }
});

// ../../../node_modules/diff/lib/patch/merge.js
var require_merge = __commonJS({
  "../../../node_modules/diff/lib/patch/merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.calcLineCount = calcLineCount;
    exports2.merge = merge;
    var _create = require_create2();
    var _parse = require_parse2();
    var _array = require_array2();
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
    }
    function calcLineCount(hunk) {
      var _calcOldNewLineCount = (
        /*istanbul ignore end*/
        calcOldNewLineCount(hunk.lines)
      ), oldLines = _calcOldNewLineCount.oldLines, newLines = _calcOldNewLineCount.newLines;
      if (oldLines !== void 0) {
        hunk.oldLines = oldLines;
      } else {
        delete hunk.oldLines;
      }
      if (newLines !== void 0) {
        hunk.newLines = newLines;
      } else {
        delete hunk.newLines;
      }
    }
    function merge(mine, theirs, base) {
      mine = loadPatch(mine, base);
      theirs = loadPatch(theirs, base);
      var ret = {};
      if (mine.index || theirs.index) {
        ret.index = mine.index || theirs.index;
      }
      if (mine.newFileName || theirs.newFileName) {
        if (!fileNameChanged(mine)) {
          ret.oldFileName = theirs.oldFileName || mine.oldFileName;
          ret.newFileName = theirs.newFileName || mine.newFileName;
          ret.oldHeader = theirs.oldHeader || mine.oldHeader;
          ret.newHeader = theirs.newHeader || mine.newHeader;
        } else if (!fileNameChanged(theirs)) {
          ret.oldFileName = mine.oldFileName;
          ret.newFileName = mine.newFileName;
          ret.oldHeader = mine.oldHeader;
          ret.newHeader = mine.newHeader;
        } else {
          ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
          ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
          ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
          ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
        }
      }
      ret.hunks = [];
      var mineIndex = 0, theirsIndex = 0, mineOffset = 0, theirsOffset = 0;
      while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
        var mineCurrent = mine.hunks[mineIndex] || {
          oldStart: Infinity
        }, theirsCurrent = theirs.hunks[theirsIndex] || {
          oldStart: Infinity
        };
        if (hunkBefore(mineCurrent, theirsCurrent)) {
          ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
          mineIndex++;
          theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
        } else if (hunkBefore(theirsCurrent, mineCurrent)) {
          ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
          theirsIndex++;
          mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
        } else {
          var mergedHunk = {
            oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
            oldLines: 0,
            newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
            newLines: 0,
            lines: []
          };
          mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
          theirsIndex++;
          mineIndex++;
          ret.hunks.push(mergedHunk);
        }
      }
      return ret;
    }
    function loadPatch(param, base) {
      if (typeof param === "string") {
        if (/^@@/m.test(param) || /^Index:/m.test(param)) {
          return (
            /*istanbul ignore start*/
            (0, /*istanbul ignore end*/
            /*istanbul ignore start*/
            _parse.parsePatch)(param)[0]
          );
        }
        if (!base) {
          throw new Error("Must provide a base reference or pass in a patch");
        }
        return (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _create.structuredPatch)(void 0, void 0, base, param)
        );
      }
      return param;
    }
    function fileNameChanged(patch) {
      return patch.newFileName && patch.newFileName !== patch.oldFileName;
    }
    function selectField(index, mine, theirs) {
      if (mine === theirs) {
        return mine;
      } else {
        index.conflict = true;
        return {
          mine,
          theirs
        };
      }
    }
    function hunkBefore(test, check) {
      return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
    }
    function cloneHunk(hunk, offset) {
      return {
        oldStart: hunk.oldStart,
        oldLines: hunk.oldLines,
        newStart: hunk.newStart + offset,
        newLines: hunk.newLines,
        lines: hunk.lines
      };
    }
    function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
      var mine = {
        offset: mineOffset,
        lines: mineLines,
        index: 0
      }, their = {
        offset: theirOffset,
        lines: theirLines,
        index: 0
      };
      insertLeading(hunk, mine, their);
      insertLeading(hunk, their, mine);
      while (mine.index < mine.lines.length && their.index < their.lines.length) {
        var mineCurrent = mine.lines[mine.index], theirCurrent = their.lines[their.index];
        if ((mineCurrent[0] === "-" || mineCurrent[0] === "+") && (theirCurrent[0] === "-" || theirCurrent[0] === "+")) {
          mutualChange(hunk, mine, their);
        } else if (mineCurrent[0] === "+" && theirCurrent[0] === " ") {
          var _hunk$lines;
          (_hunk$lines = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              collectChange(mine)
            )
          );
        } else if (theirCurrent[0] === "+" && mineCurrent[0] === " ") {
          var _hunk$lines2;
          (_hunk$lines2 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines2,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              collectChange(their)
            )
          );
        } else if (mineCurrent[0] === "-" && theirCurrent[0] === " ") {
          removal(hunk, mine, their);
        } else if (theirCurrent[0] === "-" && mineCurrent[0] === " ") {
          removal(hunk, their, mine, true);
        } else if (mineCurrent === theirCurrent) {
          hunk.lines.push(mineCurrent);
          mine.index++;
          their.index++;
        } else {
          conflict(hunk, collectChange(mine), collectChange(their));
        }
      }
      insertTrailing(hunk, mine);
      insertTrailing(hunk, their);
      calcLineCount(hunk);
    }
    function mutualChange(hunk, mine, their) {
      var myChanges = collectChange(mine), theirChanges = collectChange(their);
      if (allRemoves(myChanges) && allRemoves(theirChanges)) {
        if (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _array.arrayStartsWith)(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)
        ) {
          var _hunk$lines3;
          (_hunk$lines3 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines3,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              myChanges
            )
          );
          return;
        } else if (
          /*istanbul ignore start*/
          (0, /*istanbul ignore end*/
          /*istanbul ignore start*/
          _array.arrayStartsWith)(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)
        ) {
          var _hunk$lines4;
          (_hunk$lines4 = /*istanbul ignore end*/
          hunk.lines).push.apply(
            /*istanbul ignore start*/
            _hunk$lines4,
            /*istanbul ignore start*/
            _toConsumableArray(
              /*istanbul ignore end*/
              theirChanges
            )
          );
          return;
        }
      } else if (
        /*istanbul ignore start*/
        (0, /*istanbul ignore end*/
        /*istanbul ignore start*/
        _array.arrayEqual)(myChanges, theirChanges)
      ) {
        var _hunk$lines5;
        (_hunk$lines5 = /*istanbul ignore end*/
        hunk.lines).push.apply(
          /*istanbul ignore start*/
          _hunk$lines5,
          /*istanbul ignore start*/
          _toConsumableArray(
            /*istanbul ignore end*/
            myChanges
          )
        );
        return;
      }
      conflict(hunk, myChanges, theirChanges);
    }
    function removal(hunk, mine, their, swap) {
      var myChanges = collectChange(mine), theirChanges = collectContext(their, myChanges);
      if (theirChanges.merged) {
        var _hunk$lines6;
        (_hunk$lines6 = /*istanbul ignore end*/
        hunk.lines).push.apply(
          /*istanbul ignore start*/
          _hunk$lines6,
          /*istanbul ignore start*/
          _toConsumableArray(
            /*istanbul ignore end*/
            theirChanges.merged
          )
        );
      } else {
        conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
      }
    }
    function conflict(hunk, mine, their) {
      hunk.conflict = true;
      hunk.lines.push({
        conflict: true,
        mine,
        theirs: their
      });
    }
    function insertLeading(hunk, insert, their) {
      while (insert.offset < their.offset && insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
        insert.offset++;
      }
    }
    function insertTrailing(hunk, insert) {
      while (insert.index < insert.lines.length) {
        var line = insert.lines[insert.index++];
        hunk.lines.push(line);
      }
    }
    function collectChange(state) {
      var ret = [], operation = state.lines[state.index][0];
      while (state.index < state.lines.length) {
        var line = state.lines[state.index];
        if (operation === "-" && line[0] === "+") {
          operation = "+";
        }
        if (operation === line[0]) {
          ret.push(line);
          state.index++;
        } else {
          break;
        }
      }
      return ret;
    }
    function collectContext(state, matchChanges) {
      var changes = [], merged = [], matchIndex = 0, contextChanges = false, conflicted = false;
      while (matchIndex < matchChanges.length && state.index < state.lines.length) {
        var change = state.lines[state.index], match = matchChanges[matchIndex];
        if (match[0] === "+") {
          break;
        }
        contextChanges = contextChanges || change[0] !== " ";
        merged.push(match);
        matchIndex++;
        if (change[0] === "+") {
          conflicted = true;
          while (change[0] === "+") {
            changes.push(change);
            change = state.lines[++state.index];
          }
        }
        if (match.substr(1) === change.substr(1)) {
          changes.push(change);
          state.index++;
        } else {
          conflicted = true;
        }
      }
      if ((matchChanges[matchIndex] || "")[0] === "+" && contextChanges) {
        conflicted = true;
      }
      if (conflicted) {
        return changes;
      }
      while (matchIndex < matchChanges.length) {
        merged.push(matchChanges[matchIndex++]);
      }
      return {
        merged,
        changes
      };
    }
    function allRemoves(changes) {
      return changes.reduce(function(prev, change) {
        return prev && change[0] === "-";
      }, true);
    }
    function skipRemoveSuperset(state, removeChanges, delta) {
      for (var i = 0; i < delta; i++) {
        var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);
        if (state.lines[state.index + i] !== " " + changeContent) {
          return false;
        }
      }
      state.index += delta;
      return true;
    }
    function calcOldNewLineCount(lines) {
      var oldLines = 0;
      var newLines = 0;
      lines.forEach(function(line) {
        if (typeof line !== "string") {
          var myCount = calcOldNewLineCount(line.mine);
          var theirCount = calcOldNewLineCount(line.theirs);
          if (oldLines !== void 0) {
            if (myCount.oldLines === theirCount.oldLines) {
              oldLines += myCount.oldLines;
            } else {
              oldLines = void 0;
            }
          }
          if (newLines !== void 0) {
            if (myCount.newLines === theirCount.newLines) {
              newLines += myCount.newLines;
            } else {
              newLines = void 0;
            }
          }
        } else {
          if (newLines !== void 0 && (line[0] === "+" || line[0] === " ")) {
            newLines++;
          }
          if (oldLines !== void 0 && (line[0] === "-" || line[0] === " ")) {
            oldLines++;
          }
        }
      });
      return {
        oldLines,
        newLines
      };
    }
  }
});

// ../../../node_modules/diff/lib/convert/dmp.js
var require_dmp = __commonJS({
  "../../../node_modules/diff/lib/convert/dmp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.convertChangesToDMP = convertChangesToDMP;
    function convertChangesToDMP(changes) {
      var ret = [], change, operation;
      for (var i = 0; i < changes.length; i++) {
        change = changes[i];
        if (change.added) {
          operation = 1;
        } else if (change.removed) {
          operation = -1;
        } else {
          operation = 0;
        }
        ret.push([operation, change.value]);
      }
      return ret;
    }
  }
});

// ../../../node_modules/diff/lib/convert/xml.js
var require_xml = __commonJS({
  "../../../node_modules/diff/lib/convert/xml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.convertChangesToXML = convertChangesToXML;
    function convertChangesToXML(changes) {
      var ret = [];
      for (var i = 0; i < changes.length; i++) {
        var change = changes[i];
        if (change.added) {
          ret.push("<ins>");
        } else if (change.removed) {
          ret.push("<del>");
        }
        ret.push(escapeHTML(change.value));
        if (change.added) {
          ret.push("</ins>");
        } else if (change.removed) {
          ret.push("</del>");
        }
      }
      return ret.join("");
    }
    function escapeHTML(s) {
      var n = s;
      n = n.replace(/&/g, "&amp;");
      n = n.replace(/</g, "&lt;");
      n = n.replace(/>/g, "&gt;");
      n = n.replace(/"/g, "&quot;");
      return n;
    }
  }
});

// ../../../node_modules/diff/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/diff/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Diff", {
      enumerable: true,
      get: function get() {
        return _base.default;
      }
    });
    Object.defineProperty(exports2, "diffChars", {
      enumerable: true,
      get: function get() {
        return _character.diffChars;
      }
    });
    Object.defineProperty(exports2, "diffWords", {
      enumerable: true,
      get: function get() {
        return _word.diffWords;
      }
    });
    Object.defineProperty(exports2, "diffWordsWithSpace", {
      enumerable: true,
      get: function get() {
        return _word.diffWordsWithSpace;
      }
    });
    Object.defineProperty(exports2, "diffLines", {
      enumerable: true,
      get: function get() {
        return _line.diffLines;
      }
    });
    Object.defineProperty(exports2, "diffTrimmedLines", {
      enumerable: true,
      get: function get() {
        return _line.diffTrimmedLines;
      }
    });
    Object.defineProperty(exports2, "diffSentences", {
      enumerable: true,
      get: function get() {
        return _sentence.diffSentences;
      }
    });
    Object.defineProperty(exports2, "diffCss", {
      enumerable: true,
      get: function get() {
        return _css.diffCss;
      }
    });
    Object.defineProperty(exports2, "diffJson", {
      enumerable: true,
      get: function get() {
        return _json.diffJson;
      }
    });
    Object.defineProperty(exports2, "canonicalize", {
      enumerable: true,
      get: function get() {
        return _json.canonicalize;
      }
    });
    Object.defineProperty(exports2, "diffArrays", {
      enumerable: true,
      get: function get() {
        return _array.diffArrays;
      }
    });
    Object.defineProperty(exports2, "applyPatch", {
      enumerable: true,
      get: function get() {
        return _apply.applyPatch;
      }
    });
    Object.defineProperty(exports2, "applyPatches", {
      enumerable: true,
      get: function get() {
        return _apply.applyPatches;
      }
    });
    Object.defineProperty(exports2, "parsePatch", {
      enumerable: true,
      get: function get() {
        return _parse.parsePatch;
      }
    });
    Object.defineProperty(exports2, "merge", {
      enumerable: true,
      get: function get() {
        return _merge.merge;
      }
    });
    Object.defineProperty(exports2, "structuredPatch", {
      enumerable: true,
      get: function get() {
        return _create.structuredPatch;
      }
    });
    Object.defineProperty(exports2, "createTwoFilesPatch", {
      enumerable: true,
      get: function get() {
        return _create.createTwoFilesPatch;
      }
    });
    Object.defineProperty(exports2, "createPatch", {
      enumerable: true,
      get: function get() {
        return _create.createPatch;
      }
    });
    Object.defineProperty(exports2, "convertChangesToDMP", {
      enumerable: true,
      get: function get() {
        return _dmp.convertChangesToDMP;
      }
    });
    Object.defineProperty(exports2, "convertChangesToXML", {
      enumerable: true,
      get: function get() {
        return _xml.convertChangesToXML;
      }
    });
    var _base = _interopRequireDefault(require_base());
    var _character = require_character();
    var _word = require_word();
    var _line = require_line();
    var _sentence = require_sentence();
    var _css = require_css();
    var _json = require_json2();
    var _array = require_array();
    var _apply = require_apply();
    var _parse = require_parse2();
    var _merge = require_merge();
    var _create = require_create2();
    var _dmp = require_dmp();
    var _xml = require_xml();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// ../../../node_modules/ts-node/dist/repl.js
var require_repl = __commonJS({
  "../../../node_modules/ts-node/dist/repl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setupContext = exports2.createEvalAwarePartialHost = exports2.EvalState = exports2.createRepl = exports2.REPL_NAME = exports2.REPL_FILENAME = exports2.STDIN_NAME = exports2.STDIN_FILENAME = exports2.EVAL_NAME = exports2.EVAL_FILENAME = void 0;
    var os_1 = require("os");
    var path_1 = require("path");
    var repl_1 = require("repl");
    var vm_1 = require("vm");
    var index_1 = require_dist2();
    var fs_1 = require("fs");
    var console_1 = require("console");
    var assert = require("assert");
    var module_1 = require("module");
    var _processTopLevelAwait;
    function getProcessTopLevelAwait() {
      if (_processTopLevelAwait === void 0) {
        ({
          processTopLevelAwait: _processTopLevelAwait
        } = require_node_internal_repl_await());
      }
      return _processTopLevelAwait;
    }
    var diff;
    function getDiffLines() {
      if (diff === void 0) {
        diff = require_lib2();
      }
      return diff.diffLines;
    }
    exports2.EVAL_FILENAME = `[eval].ts`;
    exports2.EVAL_NAME = `[eval]`;
    exports2.STDIN_FILENAME = `[stdin].ts`;
    exports2.STDIN_NAME = `[stdin]`;
    exports2.REPL_FILENAME = "<repl>.ts";
    exports2.REPL_NAME = "<repl>";
    function createRepl(options = {}) {
      var _a2, _b2, _c2, _d, _e;
      const { ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true } = options;
      let service = options.service;
      let nodeReplServer;
      let context;
      const state = (_a2 = options.state) !== null && _a2 !== void 0 ? _a2 : new EvalState((0, path_1.join)(process.cwd(), exports2.REPL_FILENAME));
      const evalAwarePartialHost = createEvalAwarePartialHost(state, options.composeWithEvalAwarePartialHost);
      const stdin = (_b2 = options.stdin) !== null && _b2 !== void 0 ? _b2 : process.stdin;
      const stdout = (_c2 = options.stdout) !== null && _c2 !== void 0 ? _c2 : process.stdout;
      const stderr = (_d = options.stderr) !== null && _d !== void 0 ? _d : process.stderr;
      const _console = stdout === process.stdout && stderr === process.stderr ? console : new console_1.Console(stdout, stderr);
      const replService = {
        state: (_e = options.state) !== null && _e !== void 0 ? _e : new EvalState((0, path_1.join)(process.cwd(), exports2.EVAL_FILENAME)),
        setService,
        evalCode,
        evalCodeInternal,
        nodeEval,
        evalAwarePartialHost,
        start,
        startInternal,
        stdin,
        stdout,
        stderr,
        console: _console
      };
      return replService;
      function setService(_service) {
        service = _service;
        if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {
          service.addDiagnosticFilter({
            appliesToAllFiles: false,
            filenamesAbsolute: [state.path],
            diagnosticsIgnored: [
              2393,
              6133,
              7027,
              ...service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : []
            ]
          });
        }
      }
      function evalCode(code) {
        const result = appendCompileAndEvalInput({
          service,
          state,
          input: code,
          context,
          overrideIsCompletion: false
        });
        assert(result.containsTopLevelAwait === false);
        return result.value;
      }
      function evalCodeInternal(options2) {
        const { code, enableTopLevelAwait, context: context2 } = options2;
        return appendCompileAndEvalInput({
          service,
          state,
          input: code,
          enableTopLevelAwait,
          context: context2
        });
      }
      function nodeEval(code, context2, _filename, callback) {
        if (code === ".scope") {
          callback(null);
          return;
        }
        try {
          const evalResult = evalCodeInternal({
            code,
            enableTopLevelAwait: true,
            context: context2
          });
          if (evalResult.containsTopLevelAwait) {
            (async () => {
              try {
                callback(null, await evalResult.valuePromise);
              } catch (promiseError) {
                handleError(promiseError);
              }
            })();
          } else {
            callback(null, evalResult.value);
          }
        } catch (error) {
          handleError(error);
        }
        function handleError(error) {
          var _a3, _b3;
          const canLogTopLevelAwaitHint = service.options.experimentalReplAwait !== false && !service.shouldReplAwait;
          if (error instanceof index_1.TSError) {
            if (repl_1.Recoverable && isRecoverable(error)) {
              callback(new repl_1.Recoverable(error));
              return;
            } else {
              _console.error(error);
              if (canLogTopLevelAwaitHint && error.diagnosticCodes.some((dC) => topLevelAwaitDiagnosticCodes.includes(dC))) {
                _console.error(getTopLevelAwaitHint());
              }
              callback(null);
            }
          } else {
            let _error = error;
            if (canLogTopLevelAwaitHint && _error instanceof SyntaxError && ((_a3 = _error.message) === null || _a3 === void 0 ? void 0 : _a3.includes("await is only valid"))) {
              try {
                _error.message += `

${getTopLevelAwaitHint()}`;
                _error.stack = (_b3 = _error.stack) === null || _b3 === void 0 ? void 0 : _b3.replace(/(SyntaxError:.*)/, (_, $1) => `${$1}

${getTopLevelAwaitHint()}`);
              } catch {
              }
            }
            callback(_error);
          }
        }
        function getTopLevelAwaitHint() {
          return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${service.ts.version} and target ${service.ts.ScriptTarget[service.config.options.target]}.`;
        }
      }
      function start(code) {
        startInternal({ code });
      }
      function startInternal(options2) {
        const { code, forceToBeModule = true, ...optionsOverride } = options2 !== null && options2 !== void 0 ? options2 : {};
        if (code) {
          try {
            evalCode(`${code}
`);
          } catch (err) {
            _console.error(err);
            process.exit(1);
          }
        }
        service === null || service === void 0 ? void 0 : service.compile("", state.path);
        const repl = (0, repl_1.start)({
          prompt: "> ",
          input: replService.stdin,
          output: replService.stdout,
          // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30
          terminal: stdout.isTTY && !parseInt(index_1.env.NODE_NO_READLINE, 10),
          eval: nodeEval,
          useGlobal: true,
          ...optionsOverride
        });
        nodeReplServer = repl;
        context = repl.context;
        const resetEval = appendToEvalState(state, "");
        function reset() {
          resetEval();
          runInContext("exports = module.exports", state.path, context);
          if (forceToBeModule) {
            state.input += "export {};void 0;\n";
          }
          if (!(service === null || service === void 0 ? void 0 : service.transpileOnly)) {
            state.input += `// @ts-ignore
${module_1.builtinModules.filter((name) => !name.startsWith("_") && !name.includes("/") && !["console", "module", "process"].includes(name)).map((name) => `declare import ${name} = require('${name}')`).join(";")}
`;
          }
        }
        reset();
        repl.on("reset", reset);
        repl.defineCommand("type", {
          help: "Check the type of a TypeScript identifier",
          action: function(identifier) {
            if (!identifier) {
              repl.displayPrompt();
              return;
            }
            const undo = appendToEvalState(state, identifier);
            const { name, comment } = service.getTypeInfo(state.input, state.path, state.input.length);
            undo();
            if (name)
              repl.outputStream.write(`${name}
`);
            if (comment)
              repl.outputStream.write(`${comment}
`);
            repl.displayPrompt();
          }
        });
        if (repl.setupHistory) {
          const historyPath = index_1.env.TS_NODE_HISTORY || (0, path_1.join)((0, os_1.homedir)(), ".ts_node_repl_history");
          repl.setupHistory(historyPath, (err) => {
            if (!err)
              return;
            _console.error(err);
            process.exit(1);
          });
        }
        return repl;
      }
    }
    exports2.createRepl = createRepl;
    var EvalState = class {
      constructor(path5) {
        this.path = path5;
        this.input = "";
        this.output = "";
        this.version = 0;
        this.lines = 0;
      }
    };
    exports2.EvalState = EvalState;
    function createEvalAwarePartialHost(state, composeWith) {
      function readFile2(path5) {
        if (path5 === state.path)
          return state.input;
        if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.readFile)
          return composeWith.readFile(path5);
        try {
          return (0, fs_1.readFileSync)(path5, "utf8");
        } catch (err) {
        }
      }
      function fileExists(path5) {
        if (path5 === state.path)
          return true;
        if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.fileExists)
          return composeWith.fileExists(path5);
        try {
          const stats = (0, fs_1.statSync)(path5);
          return stats.isFile() || stats.isFIFO();
        } catch (err) {
          return false;
        }
      }
      return { readFile: readFile2, fileExists };
    }
    exports2.createEvalAwarePartialHost = createEvalAwarePartialHost;
    var sourcemapCommentRe = /\/\/# ?sourceMappingURL=\S+[\s\r\n]*$/;
    function appendCompileAndEvalInput(options) {
      const { service, state, wrappedErr, enableTopLevelAwait = false, context, overrideIsCompletion } = options;
      let { input } = options;
      let wrappedCmd = false;
      if (!wrappedErr && /^\s*{/.test(input) && !/;\s*$/.test(input)) {
        input = `(${input.trim()})
`;
        wrappedCmd = true;
      }
      const lines = state.lines;
      const isCompletion = overrideIsCompletion !== null && overrideIsCompletion !== void 0 ? overrideIsCompletion : !/\n$/.test(input);
      const undo = appendToEvalState(state, input);
      let output37;
      function adjustUseStrict(code) {
        return code.replace(/^"use strict";/, '"use strict"; void 0;');
      }
      try {
        output37 = service.compile(state.input, state.path, -lines);
      } catch (err) {
        undo();
        if (wrappedCmd) {
          if (err instanceof index_1.TSError && err.diagnosticCodes[0] === 2339) {
            throw err;
          }
          return appendCompileAndEvalInput({
            ...options,
            wrappedErr: err
          });
        }
        if (wrappedErr)
          throw wrappedErr;
        throw err;
      }
      output37 = adjustUseStrict(output37);
      const outputWithoutSourcemapComment = output37.replace(sourcemapCommentRe, "");
      const oldOutputWithoutSourcemapComment = state.output.replace(sourcemapCommentRe, "");
      const changes = getDiffLines()(oldOutputWithoutSourcemapComment, outputWithoutSourcemapComment);
      if (isCompletion) {
        undo();
      } else {
        state.output = output37;
        state.input = state.input.replace(/([^\n\s])([\n\s]*)$/, (all, lastChar, whitespace) => {
          if (lastChar !== ";")
            return `${lastChar};${whitespace}`;
          return all;
        });
      }
      let commands = [];
      let containsTopLevelAwait = false;
      for (const change of changes) {
        if (change.added) {
          if (enableTopLevelAwait && service.shouldReplAwait && change.value.indexOf("await") > -1) {
            const processTopLevelAwait = getProcessTopLevelAwait();
            const wrappedResult = processTopLevelAwait(change.value + "\n");
            if (wrappedResult !== null) {
              containsTopLevelAwait = true;
              commands.push({
                mustAwait: true,
                execCommand: () => runInContext(wrappedResult, state.path, context)
              });
              continue;
            }
          }
          commands.push({
            execCommand: () => runInContext(change.value, state.path, context)
          });
        }
      }
      if (containsTopLevelAwait) {
        return {
          containsTopLevelAwait,
          valuePromise: (async () => {
            let value2;
            for (const command of commands) {
              const r = command.execCommand();
              value2 = command.mustAwait ? await r : r;
            }
            return value2;
          })()
        };
      } else {
        return {
          containsTopLevelAwait: false,
          value: commands.reduce((_, c) => c.execCommand(), void 0)
        };
      }
    }
    function runInContext(code, filename, context) {
      const script = new vm_1.Script(code, { filename });
      if (context === void 0 || context === global) {
        return script.runInThisContext();
      } else {
        return script.runInContext(context);
      }
    }
    function appendToEvalState(state, input) {
      const undoInput = state.input;
      const undoVersion = state.version;
      const undoOutput = state.output;
      const undoLines = state.lines;
      state.input += input;
      state.lines += lineCount(input);
      state.version++;
      return function() {
        state.input = undoInput;
        state.output = undoOutput;
        state.version = undoVersion;
        state.lines = undoLines;
      };
    }
    function lineCount(value2) {
      let count = 0;
      for (const char of value2) {
        if (char === "\n") {
          count++;
        }
      }
      return count;
    }
    var RECOVERY_CODES = /* @__PURE__ */ new Map([
      [1003, null],
      [1005, null],
      [1109, null],
      [1126, null],
      [
        1136,
        /* @__PURE__ */ new Set([1005])
        // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'
      ],
      [1160, null],
      [1161, null],
      [2355, null],
      [2391, null],
      [
        7010,
        /* @__PURE__ */ new Set([1005])
        // happens when fn signature spread across multiple lines: 'function a(\nb: any\n) {'
      ]
    ]);
    var topLevelAwaitDiagnosticCodes = [
      1375,
      1378,
      1431,
      1432
      // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.
    ];
    function isRecoverable(error) {
      return error.diagnosticCodes.every((code) => {
        const deps = RECOVERY_CODES.get(code);
        return deps === null || deps && error.diagnosticCodes.some((code2) => deps.has(code2));
      });
    }
    function setupContext(context, module3, filenameAndDirname) {
      if (filenameAndDirname) {
        context.__dirname = ".";
        context.__filename = `[${filenameAndDirname}]`;
      }
      context.module = module3;
      context.exports = module3.exports;
      context.require = module3.require.bind(module3);
    }
    exports2.setupContext = setupContext;
  }
});

// ../../../node_modules/ts-node/package.json
var require_package = __commonJS({
  "../../../node_modules/ts-node/package.json"(exports2, module2) {
    module2.exports = {
      name: "ts-node",
      version: "10.9.1",
      description: "TypeScript execution environment and REPL for node.js, with source map support",
      main: "dist/index.js",
      exports: {
        ".": "./dist/index.js",
        "./package": "./package.json",
        "./package.json": "./package.json",
        "./dist/bin": "./dist/bin.js",
        "./dist/bin.js": "./dist/bin.js",
        "./dist/bin-transpile": "./dist/bin-transpile.js",
        "./dist/bin-transpile.js": "./dist/bin-transpile.js",
        "./dist/bin-script": "./dist/bin-script.js",
        "./dist/bin-script.js": "./dist/bin-script.js",
        "./dist/bin-cwd": "./dist/bin-cwd.js",
        "./dist/bin-cwd.js": "./dist/bin-cwd.js",
        "./dist/bin-esm": "./dist/bin-esm.js",
        "./dist/bin-esm.js": "./dist/bin-esm.js",
        "./register": "./register/index.js",
        "./register/files": "./register/files.js",
        "./register/transpile-only": "./register/transpile-only.js",
        "./register/type-check": "./register/type-check.js",
        "./esm": "./esm.mjs",
        "./esm.mjs": "./esm.mjs",
        "./esm/transpile-only": "./esm/transpile-only.mjs",
        "./esm/transpile-only.mjs": "./esm/transpile-only.mjs",
        "./child-loader.mjs": "./child-loader.mjs",
        "./transpilers/swc": "./transpilers/swc.js",
        "./transpilers/swc-experimental": "./transpilers/swc-experimental.js",
        "./node10/tsconfig.json": "./node10/tsconfig.json",
        "./node12/tsconfig.json": "./node12/tsconfig.json",
        "./node14/tsconfig.json": "./node14/tsconfig.json",
        "./node16/tsconfig.json": "./node16/tsconfig.json"
      },
      types: "dist/index.d.ts",
      bin: {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      files: [
        "/transpilers/",
        "/dist/",
        "!/dist/test",
        "/dist-raw/NODE-LICENSE.md",
        "/dist-raw/**.js",
        "/register/",
        "/esm/",
        "/esm.mjs",
        "/child-loader.mjs",
        "/LICENSE",
        "/tsconfig.schema.json",
        "/tsconfig.schemastore-schema.json",
        "/node10/",
        "/node12/",
        "/node14/",
        "/node16/"
      ],
      scripts: {
        lint: "dprint check",
        "lint-fix": "dprint fmt",
        clean: "rimraf temp dist tsconfig.schema.json tsconfig.schemastore-schema.json tsconfig.tsbuildinfo tests/ts-node-packed.tgz tests/node_modules tests/tmp",
        rebuild: "npm run clean && npm run build",
        build: "npm run build-nopack && npm run build-pack",
        "build-nopack": "npm run build-tsc && npm run build-configSchema",
        "build-tsc": "tsc -b ./tsconfig.build-dist.json",
        "build-configSchema": "typescript-json-schema --topRef --refs --validationKeywords allOf --out tsconfig.schema.json tsconfig.build-schema.json TsConfigSchema && node --require ./register ./scripts/create-merged-schema",
        "build-pack": "node ./scripts/build-pack.js",
        "test-spec": "ava",
        "test-cov": "nyc ava",
        test: "npm run build && npm run lint && npm run test-cov --",
        "test-local": "npm run lint-fix && npm run build-tsc && npm run build-pack && npm run test-spec --",
        "pre-debug": "npm run build-tsc && npm run build-pack",
        "coverage-report": "nyc report --reporter=lcov",
        prepare: "npm run clean && npm run build-nopack",
        "api-extractor": "api-extractor run --local --verbose",
        "esm-usage-example": "npm run build-tsc && cd esm-usage-example && node --experimental-specifier-resolution node --loader ../esm.mjs ./index",
        "esm-usage-example2": "npm run build-tsc && cd tests && TS_NODE_PROJECT=./module-types/override-to-cjs/tsconfig.json node --loader ../esm.mjs ./module-types/override-to-cjs/test.cjs"
      },
      repository: {
        type: "git",
        url: "git://github.com/TypeStrong/ts-node.git"
      },
      keywords: [
        "typescript",
        "node",
        "runtime",
        "environment",
        "ts",
        "compiler"
      ],
      author: {
        name: "Blake Embrey",
        email: "hello@blakeembrey.com",
        url: "http://blakeembrey.me"
      },
      contributors: [
        {
          name: "Andrew Bradley",
          email: "cspotcode@gmail.com",
          url: "https://github.com/cspotcode"
        }
      ],
      license: "MIT",
      bugs: {
        url: "https://github.com/TypeStrong/ts-node/issues"
      },
      homepage: "https://typestrong.org/ts-node",
      devDependencies: {
        "@microsoft/api-extractor": "^7.19.4",
        "@swc/core": ">=1.2.205",
        "@swc/wasm": ">=1.2.205",
        "@types/diff": "^4.0.2",
        "@types/lodash": "^4.14.151",
        "@types/node": "13.13.5",
        "@types/proper-lockfile": "^4.1.2",
        "@types/proxyquire": "^1.3.28",
        "@types/react": "^16.14.19",
        "@types/rimraf": "^3.0.0",
        "@types/semver": "^7.1.0",
        "@yarnpkg/fslib": "^2.4.0",
        ava: "^3.15.0",
        axios: "^0.21.1",
        dprint: "^0.25.0",
        expect: "^27.0.2",
        "get-stream": "^6.0.0",
        lodash: "^4.17.15",
        ntypescript: "^1.201507091536.1",
        nyc: "^15.0.1",
        outdent: "^0.8.0",
        "proper-lockfile": "^4.1.2",
        proxyquire: "^2.0.0",
        react: "^16.14.0",
        rimraf: "^3.0.0",
        semver: "^7.1.3",
        throat: "^6.0.1",
        typedoc: "^0.22.10",
        typescript: "4.7.4",
        "typescript-json-schema": "^0.53.0",
        "util.promisify": "^1.0.1"
      },
      peerDependencies: {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        typescript: ">=2.7"
      },
      peerDependenciesMeta: {
        "@swc/core": {
          optional: true
        },
        "@swc/wasm": {
          optional: true
        }
      },
      dependencies: {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        acorn: "^8.4.1",
        "acorn-walk": "^8.1.1",
        arg: "^4.1.0",
        "create-require": "^1.1.0",
        diff: "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        yn: "3.1.1"
      },
      prettier: {
        singleQuote: true
      },
      volta: {
        node: "18.1.0",
        npm: "6.14.15"
      }
    };
  }
});

// ../../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "../../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports2, function(exports3) {
      "use strict";
      const comma = ",".charCodeAt(0);
      const semicolon = ";".charCodeAt(0);
      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar = new Uint8Array(64);
      const charToInt = new Uint8Array(128);
      for (let i = 0; i < chars.length; i++) {
        const c = chars.charCodeAt(i);
        intToChar[i] = c;
        charToInt[c] = i;
      }
      const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      function decode(mappings) {
        const state = new Int32Array(5);
        const decoded = [];
        let index = 0;
        do {
          const semi = indexOf(mappings, index);
          const line = [];
          let sorted = true;
          let lastCol = 0;
          state[0] = 0;
          for (let i = index; i < semi; i++) {
            let seg;
            i = decodeInteger(mappings, i, state, 0);
            const col = state[0];
            if (col < lastCol)
              sorted = false;
            lastCol = col;
            if (hasMoreVlq(mappings, i, semi)) {
              i = decodeInteger(mappings, i, state, 1);
              i = decodeInteger(mappings, i, state, 2);
              i = decodeInteger(mappings, i, state, 3);
              if (hasMoreVlq(mappings, i, semi)) {
                i = decodeInteger(mappings, i, state, 4);
                seg = [col, state[1], state[2], state[3], state[4]];
              } else {
                seg = [col, state[1], state[2], state[3]];
              }
            } else {
              seg = [col];
            }
            line.push(seg);
          }
          if (!sorted)
            sort(line);
          decoded.push(line);
          index = semi + 1;
        } while (index <= mappings.length);
        return decoded;
      }
      function indexOf(mappings, index) {
        const idx = mappings.indexOf(";", index);
        return idx === -1 ? mappings.length : idx;
      }
      function decodeInteger(mappings, pos, state, j) {
        let value2 = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = mappings.charCodeAt(pos++);
          integer = charToInt[c];
          value2 |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value2 & 1;
        value2 >>>= 1;
        if (shouldNegate) {
          value2 = -2147483648 | -value2;
        }
        state[j] += value2;
        return pos;
      }
      function hasMoreVlq(mappings, i, length) {
        if (i >= length)
          return false;
        return mappings.charCodeAt(i) !== comma;
      }
      function sort(line) {
        line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[0] - b[0];
      }
      function encode(decoded) {
        const state = new Int32Array(5);
        const bufLength = 1024 * 16;
        const subLength = bufLength - 36;
        const buf = new Uint8Array(bufLength);
        const sub = buf.subarray(0, subLength);
        let pos = 0;
        let out = "";
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0) {
            if (pos === bufLength) {
              out += td.decode(buf);
              pos = 0;
            }
            buf[pos++] = semicolon;
          }
          if (line.length === 0)
            continue;
          state[0] = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (pos > subLength) {
              out += td.decode(sub);
              buf.copyWithin(0, subLength, pos);
              pos -= subLength;
            }
            if (j > 0)
              buf[pos++] = comma;
            pos = encodeInteger(buf, pos, state, segment, 0);
            if (segment.length === 1)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 1);
            pos = encodeInteger(buf, pos, state, segment, 2);
            pos = encodeInteger(buf, pos, state, segment, 3);
            if (segment.length === 4)
              continue;
            pos = encodeInteger(buf, pos, state, segment, 4);
          }
        }
        return out + td.decode(buf.subarray(0, pos));
      }
      function encodeInteger(buf, pos, state, segment, j) {
        const next = segment[j];
        let num = next - state[j];
        state[j] = next;
        num = num < 0 ? -num << 1 | 1 : num << 1;
        do {
          let clamped = num & 31;
          num >>>= 5;
          if (num > 0)
            clamped |= 32;
          buf[pos++] = intToChar[clamped];
        } while (num > 0);
        return pos;
      }
      exports3.decode = decode;
      exports3.encode = encode;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "../../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports2, function() {
      "use strict";
      const schemeRegex = /^[\w+.-]+:\/\//;
      const urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      var UrlType;
      (function(UrlType2) {
        UrlType2[UrlType2["Empty"] = 1] = "Empty";
        UrlType2[UrlType2["Hash"] = 2] = "Hash";
        UrlType2[UrlType2["Query"] = 3] = "Query";
        UrlType2[UrlType2["RelativePath"] = 4] = "RelativePath";
        UrlType2[UrlType2["AbsolutePath"] = 5] = "AbsolutePath";
        UrlType2[UrlType2["SchemeRelative"] = 6] = "SchemeRelative";
        UrlType2[UrlType2["Absolute"] = 7] = "Absolute";
      })(UrlType || (UrlType = {}));
      function isAbsoluteUrl(input) {
        return schemeRegex.test(input);
      }
      function isSchemeRelativeUrl(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath(input) {
        return input.startsWith("/");
      }
      function isFileUrl(input) {
        return input.startsWith("file:");
      }
      function isRelative(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl(input) {
        const match = urlRegex.exec(input);
        return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
      }
      function parseFileUrl(input) {
        const match = fileRegex.exec(input);
        const path5 = match[2];
        return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path5) ? path5 : "/" + path5, match[3] || "", match[4] || "");
      }
      function makeUrl(scheme, user, host, port, path5, query, hash) {
        return {
          scheme,
          user,
          host,
          port,
          path: path5,
          query,
          hash,
          type: UrlType.Absolute
        };
      }
      function parseUrl(input) {
        if (isSchemeRelativeUrl(input)) {
          const url2 = parseAbsoluteUrl("http:" + input);
          url2.scheme = "";
          url2.type = UrlType.SchemeRelative;
          return url2;
        }
        if (isAbsolutePath(input)) {
          const url2 = parseAbsoluteUrl("http://foo.com" + input);
          url2.scheme = "";
          url2.host = "";
          url2.type = UrlType.AbsolutePath;
          return url2;
        }
        if (isFileUrl(input))
          return parseFileUrl(input);
        if (isAbsoluteUrl(input))
          return parseAbsoluteUrl(input);
        const url = parseAbsoluteUrl("http://foo.com/" + input);
        url.scheme = "";
        url.host = "";
        url.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
        return url;
      }
      function stripPathFilename(path5) {
        if (path5.endsWith("/.."))
          return path5;
        const index = path5.lastIndexOf("/");
        return path5.slice(0, index + 1);
      }
      function mergePaths(url, base) {
        normalizePath2(base, base.type);
        if (url.path === "/") {
          url.path = base.path;
        } else {
          url.path = stripPathFilename(base.path) + url.path;
        }
      }
      function normalizePath2(url, type) {
        const rel = type <= UrlType.RelativePath;
        const pieces = url.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path5 = "";
        for (let i = 1; i < pointer; i++) {
          path5 += "/" + pieces[i];
        }
        if (!path5 || addTrailingSlash && !path5.endsWith("/..")) {
          path5 += "/";
        }
        url.path = path5;
      }
      function resolve2(input, base) {
        if (!input && !base)
          return "";
        const url = parseUrl(input);
        let inputType = url.type;
        if (base && inputType !== UrlType.Absolute) {
          const baseUrl = parseUrl(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case UrlType.Empty:
              url.hash = baseUrl.hash;
            case UrlType.Hash:
              url.query = baseUrl.query;
            case UrlType.Query:
            case UrlType.RelativePath:
              mergePaths(url, baseUrl);
            case UrlType.AbsolutePath:
              url.user = baseUrl.user;
              url.host = baseUrl.host;
              url.port = baseUrl.port;
            case UrlType.SchemeRelative:
              url.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath2(url, inputType);
        const queryHash = url.query + url.hash;
        switch (inputType) {
          case UrlType.Hash:
          case UrlType.Query:
            return queryHash;
          case UrlType.RelativePath: {
            const path5 = url.path.slice(1);
            if (!path5)
              return queryHash || ".";
            if (isRelative(base || input) && !isRelative(path5)) {
              return "./" + path5 + queryHash;
            }
            return path5 + queryHash;
          }
          case UrlType.AbsolutePath:
            return url.path + queryHash;
          default:
            return url.scheme + "//" + url.user + url.host + url.port + url.path + queryHash;
        }
      }
      return resolve2;
    });
  }
});

// ../../../node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "../../../node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
    })(exports2, function(exports3, sourcemapCodec, resolveUri) {
      "use strict";
      function _interopDefaultLegacy(e) {
        return e && typeof e === "object" && "default" in e ? e : { "default": e };
      }
      var resolveUri__default = /* @__PURE__ */ _interopDefaultLegacy(resolveUri);
      function resolve2(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri__default["default"](input, base);
      }
      function stripFilename(path5) {
        if (!path5)
          return "";
        const index = path5.lastIndexOf("/");
        return path5.slice(0, index + 1);
      }
      const COLUMN = 0;
      const SOURCES_INDEX = 1;
      const SOURCE_LINE = 2;
      const SOURCE_COLUMN = 3;
      const NAMES_INDEX = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
          mappings[i] = sortSegments(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN] < line[j - 1][COLUMN]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator);
      }
      function sortComparator(a, b) {
        return a[COLUMN] - b[COLUMN];
      }
      let found = false;
      function binarySearch(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN] - needle;
          if (cmp === 0) {
            found = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found = false;
        return low - 1;
      }
      function upperBound(haystack, needle, index) {
        for (let i = index + 1; i < haystack.length; i++, index++) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function lowerBound(haystack, needle, index) {
        for (let i = index - 1; i >= 0; i--, index--) {
          if (haystack[i][COLUMN] !== needle)
            break;
        }
        return index;
      }
      function memoizedState() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex = seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            const originalSource = sources[sourceIndex];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex];
            const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));
            insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);
          }
        }
        return sources;
      }
      function insert(array, index, value2) {
        for (let i = array.length; i > index; i--) {
          array[i] = array[i - 1];
        }
        array[index] = value2;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = typeof map === "string" ? JSON.parse(map) : map;
        if (!("sections" in parsed))
          return new TraceMap(parsed, mapUrl);
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const { sections } = parsed;
        let i = 0;
        for (; i < sections.length - 1; i++) {
          const no = sections[i + 1].offset;
          addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, no.line, no.column);
        }
        if (sections.length > 0) {
          addSection(sections[i], mapUrl, mappings, sources, sourcesContent, names, Infinity, Infinity);
        }
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings
        };
        return exports3.presortedDecodedMap(joined);
      };
      function addSection(section, mapUrl, mappings, sources, sourcesContent, names, stopLine, stopColumn) {
        const map = AnyMap(section.map, mapUrl);
        const { line: lineOffset, column: columnOffset } = section.offset;
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = exports3.decodedMappings(map);
        const { resolvedSources } = map;
        append(sources, resolvedSources);
        append(sourcesContent, map.sourcesContent || fillSourcesContent(resolvedSources.length));
        append(names, map.names);
        for (let i = mappings.length; i <= lineOffset; i++)
          mappings.push([]);
        const stopI = stopLine - lineOffset;
        const len = Math.min(decoded.length, stopI + 1);
        for (let i = 0; i < len; i++) {
          const line = decoded[i];
          const out = i === 0 ? mappings[lineOffset] : mappings[lineOffset + i] = [];
          const cOffset = i === 0 ? columnOffset : 0;
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN];
            if (i === stopI && column >= stopColumn)
              break;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];
            const sourceLine = seg[SOURCE_LINE];
            const sourceColumn = seg[SOURCE_COLUMN];
            if (seg.length === 4) {
              out.push([column, sourcesIndex, sourceLine, sourceColumn]);
              continue;
            }
            out.push([column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);
          }
        }
      }
      function append(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function fillSourcesContent(len) {
        const sourcesContent = [];
        for (let i = 0; i < len; i++)
          sourcesContent[i] = null;
        return sourcesContent;
      }
      const INVALID_ORIGINAL_MAPPING = Object.freeze({
        source: null,
        line: null,
        column: null,
        name: null
      });
      const INVALID_GENERATED_MAPPING = Object.freeze({
        line: null,
        column: null
      });
      const LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND = -1;
      const GREATEST_LOWER_BOUND = 1;
      exports3.encodedMappings = void 0;
      exports3.decodedMappings = void 0;
      exports3.traceSegment = void 0;
      exports3.originalPositionFor = void 0;
      exports3.generatedPositionFor = void 0;
      exports3.eachMapping = void 0;
      exports3.presortedDecodedMap = void 0;
      exports3.decodedMap = void 0;
      exports3.encodedMap = void 0;
      class TraceMap {
        constructor(map, mapUrl) {
          this._decodedMemo = memoizedState();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
          const isString = typeof map === "string";
          if (!isString && map.constructor === TraceMap)
            return map;
          const parsed = isString ? JSON.parse(map) : map;
          const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version;
          this.file = file;
          this.names = names;
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          if (sourceRoot || mapUrl) {
            const from = resolve2(sourceRoot || "", stripFilename(mapUrl));
            this.resolvedSources = sources.map((s) => resolve2(s || "", from));
          } else {
            this.resolvedSources = sources.map((s) => s || "");
          }
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort(mappings, isString);
          }
        }
      }
      (() => {
        exports3.encodedMappings = (map) => {
          var _a2;
          return (_a2 = map._encoded) !== null && _a2 !== void 0 ? _a2 : map._encoded = sourcemapCodec.encode(map._decoded);
        };
        exports3.decodedMappings = (map) => {
          return map._decoded || (map._decoded = sourcemapCodec.decode(map._encoded));
        };
        exports3.traceSegment = (map, line, column) => {
          const decoded = exports3.decodedMappings(map);
          if (line >= decoded.length)
            return null;
          return traceSegmentInternal(decoded[line], map._decodedMemo, line, column, GREATEST_LOWER_BOUND);
        };
        exports3.originalPositionFor = (map, { line, column, bias }) => {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const decoded = exports3.decodedMappings(map);
          if (line >= decoded.length)
            return INVALID_ORIGINAL_MAPPING;
          const segment = traceSegmentInternal(decoded[line], map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
          if (segment == null)
            return INVALID_ORIGINAL_MAPPING;
          if (segment.length == 1)
            return INVALID_ORIGINAL_MAPPING;
          const { names, resolvedSources } = map;
          return {
            source: resolvedSources[segment[SOURCES_INDEX]],
            line: segment[SOURCE_LINE] + 1,
            column: segment[SOURCE_COLUMN],
            name: segment.length === 5 ? names[segment[NAMES_INDEX]] : null
          };
        };
        exports3.generatedPositionFor = (map, { source, line, column, bias }) => {
          line--;
          if (line < 0)
            throw new Error(LINE_GTR_ZERO);
          if (column < 0)
            throw new Error(COL_GTR_EQ_ZERO);
          const { sources, resolvedSources } = map;
          let sourceIndex = sources.indexOf(source);
          if (sourceIndex === -1)
            sourceIndex = resolvedSources.indexOf(source);
          if (sourceIndex === -1)
            return INVALID_GENERATED_MAPPING;
          const generated = map._bySources || (map._bySources = buildBySources(exports3.decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));
          const memos = map._bySourceMemos;
          const segments = generated[sourceIndex][line];
          if (segments == null)
            return INVALID_GENERATED_MAPPING;
          const segment = traceSegmentInternal(segments, memos[sourceIndex], line, column, bias || GREATEST_LOWER_BOUND);
          if (segment == null)
            return INVALID_GENERATED_MAPPING;
          return {
            line: segment[REV_GENERATED_LINE] + 1,
            column: segment[REV_GENERATED_COLUMN]
          };
        };
        exports3.eachMapping = (map, cb) => {
          const decoded = exports3.decodedMappings(map);
          const { names, resolvedSources } = map;
          for (let i = 0; i < decoded.length; i++) {
            const line = decoded[i];
            for (let j = 0; j < line.length; j++) {
              const seg = line[j];
              const generatedLine = i + 1;
              const generatedColumn = seg[0];
              let source = null;
              let originalLine = null;
              let originalColumn = null;
              let name = null;
              if (seg.length !== 1) {
                source = resolvedSources[seg[1]];
                originalLine = seg[2] + 1;
                originalColumn = seg[3];
              }
              if (seg.length === 5)
                name = names[seg[4]];
              cb({
                generatedLine,
                generatedColumn,
                source,
                originalLine,
                originalColumn,
                name
              });
            }
          }
        };
        exports3.presortedDecodedMap = (map, mapUrl) => {
          const clone = Object.assign({}, map);
          clone.mappings = [];
          const tracer = new TraceMap(clone, mapUrl);
          tracer._decoded = map.mappings;
          return tracer;
        };
        exports3.decodedMap = (map) => {
          return {
            version: 3,
            file: map.file,
            names: map.names,
            sourceRoot: map.sourceRoot,
            sources: map.sources,
            sourcesContent: map.sourcesContent,
            mappings: exports3.decodedMappings(map)
          };
        };
        exports3.encodedMap = (map) => {
          return {
            version: 3,
            file: map.file,
            names: map.names,
            sourceRoot: map.sourceRoot,
            sources: map.sources,
            sourcesContent: map.sourcesContent,
            mappings: exports3.encodedMappings(map)
          };
        };
      })();
      function traceSegmentInternal(segments, memo, line, column, bias) {
        let index = memoizedBinarySearch(segments, column, memo, line);
        if (found) {
          index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);
        } else if (bias === LEAST_UPPER_BOUND)
          index++;
        if (index === -1 || index === segments.length)
          return null;
        return segments[index];
      }
      exports3.AnyMap = AnyMap;
      exports3.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;
      exports3.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;
      exports3.TraceMap = TraceMap;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../../../node_modules/@cspotcode/source-map-support/source-map-support.js
var require_source_map_support = __commonJS({
  "../../../node_modules/@cspotcode/source-map-support/source-map-support.js"(exports2, module2) {
    "use strict";
    var { TraceMap, originalPositionFor, AnyMap } = require_trace_mapping_umd();
    var path5 = require("path");
    var { fileURLToPath, pathToFileURL } = require("url");
    var util = require("util");
    var fs;
    try {
      fs = require("fs");
      if (!fs.existsSync || !fs.readFileSync) {
        fs = null;
      }
    } catch (err) {
    }
    function dynamicRequire(mod, request) {
      return mod.require(request);
    }
    var sharedDataVersion = 1;
    function initializeSharedData(defaults) {
      var sharedDataKey = "source-map-support/sharedData";
      if (typeof Symbol !== "undefined") {
        sharedDataKey = Symbol.for(sharedDataKey);
      }
      var sharedData2 = this[sharedDataKey];
      if (!sharedData2) {
        sharedData2 = { version: sharedDataVersion };
        if (Object.defineProperty) {
          Object.defineProperty(this, sharedDataKey, { value: sharedData2 });
        } else {
          this[sharedDataKey] = sharedData2;
        }
      }
      if (sharedDataVersion !== sharedData2.version) {
        throw new Error("Multiple incompatible instances of source-map-support were loaded");
      }
      for (var key in defaults) {
        if (!(key in sharedData2)) {
          sharedData2[key] = defaults[key];
        }
      }
      return sharedData2;
    }
    var sharedData = initializeSharedData({
      // Only install once if called multiple times
      // Remember how the environment looked before installation so we can restore if able
      /** @type {HookState} */
      errorPrepareStackTraceHook: void 0,
      /** @type {HookState} */
      processEmitHook: void 0,
      /** @type {HookState} */
      moduleResolveFilenameHook: void 0,
      /** @type {Array<(request: string, parent: any, isMain: boolean, options: any, redirectedRequest: string) => void>} */
      onConflictingLibraryRedirectArr: [],
      // If true, the caches are reset before a stack trace formatting operation
      emptyCacheBetweenOperations: false,
      // Maps a file path to a string containing the file contents
      fileContentsCache: /* @__PURE__ */ Object.create(null),
      // Maps a file path to a source map for that file
      /** @type {Record<string, {url: string, map: TraceMap}} */
      sourceMapCache: /* @__PURE__ */ Object.create(null),
      // Priority list of retrieve handlers
      retrieveFileHandlers: [],
      retrieveMapHandlers: [],
      // Priority list of internally-implemented handlers.
      // When resetting state, we must keep these.
      internalRetrieveFileHandlers: [],
      internalRetrieveMapHandlers: []
    });
    var environment = "auto";
    var reSourceMap = /^data:application\/json[^,]+base64,/;
    function isInBrowser() {
      if (environment === "browser")
        return true;
      if (environment === "node")
        return false;
      return typeof window !== "undefined" && typeof XMLHttpRequest === "function" && !(window.require && window.module && window.process && window.process.type === "renderer");
    }
    function hasGlobalProcessEventEmitter() {
      return typeof process === "object" && process !== null && typeof process.on === "function";
    }
    function tryFileURLToPath(v) {
      if (isFileUrl(v)) {
        return fileURLToPath(v);
      }
      return v;
    }
    function isFileUrl(input) {
      return input.startsWith("file:");
    }
    function isAbsoluteUrl(input) {
      return schemeRegex.test(input);
    }
    var schemeRegex = /^[\w+.-]+:\/\//;
    function isSchemeRelativeUrl(input) {
      return input.startsWith("//");
    }
    function getCacheKey(pathOrFileUrl) {
      if (pathOrFileUrl.startsWith("node:"))
        return pathOrFileUrl;
      if (isFileUrl(pathOrFileUrl)) {
        return new URL(pathOrFileUrl).toString();
      } else {
        try {
          return pathToFileURL(pathOrFileUrl).toString();
        } catch {
          return pathOrFileUrl;
        }
      }
    }
    function getFileContentsCache(key) {
      return sharedData.fileContentsCache[getCacheKey(key)];
    }
    function hasFileContentsCacheFromKey(key) {
      return Object.prototype.hasOwnProperty.call(sharedData.fileContentsCache, key);
    }
    function getFileContentsCacheFromKey(key) {
      return sharedData.fileContentsCache[key];
    }
    function setFileContentsCache(key, value2) {
      return sharedData.fileContentsCache[getCacheKey(key)] = value2;
    }
    function getSourceMapCache(key) {
      return sharedData.sourceMapCache[getCacheKey(key)];
    }
    function setSourceMapCache(key, value2) {
      return sharedData.sourceMapCache[getCacheKey(key)] = value2;
    }
    function clearCaches() {
      sharedData.fileContentsCache = /* @__PURE__ */ Object.create(null);
      sharedData.sourceMapCache = /* @__PURE__ */ Object.create(null);
    }
    function handlerExec(list, internalList) {
      return function(arg) {
        for (var i = 0; i < list.length; i++) {
          var ret = list[i](arg);
          if (ret) {
            return ret;
          }
        }
        for (var i = 0; i < internalList.length; i++) {
          var ret = internalList[i](arg);
          if (ret) {
            return ret;
          }
        }
        return null;
      };
    }
    var retrieveFile = handlerExec(sharedData.retrieveFileHandlers, sharedData.internalRetrieveFileHandlers);
    sharedData.internalRetrieveFileHandlers.push(function(path6) {
      path6 = path6.trim();
      if (/^file:/.test(path6)) {
        path6 = path6.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
          return drive ? "" : (
            // file:///C:/dir/file -> C:/dir/file
            "/"
          );
        });
      }
      const key = getCacheKey(path6);
      if (hasFileContentsCacheFromKey(key)) {
        return getFileContentsCacheFromKey(key);
      }
      var contents = "";
      try {
        if (!fs) {
          var xhr = new XMLHttpRequest();
          xhr.open(
            "GET",
            path6,
            /** async */
            false
          );
          xhr.send(null);
          if (xhr.readyState === 4 && xhr.status === 200) {
            contents = xhr.responseText;
          }
        } else if (fs.existsSync(path6)) {
          contents = fs.readFileSync(path6, "utf8");
        }
      } catch (er) {
      }
      return setFileContentsCache(path6, contents);
    });
    function supportRelativeURL(file, url) {
      if (!file)
        return url;
      try {
        if (isAbsoluteUrl(file) || isSchemeRelativeUrl(file)) {
          if (isAbsoluteUrl(url) || isSchemeRelativeUrl(url)) {
            return new URL(url, file).toString();
          }
          if (path5.isAbsolute(url)) {
            return new URL(pathToFileURL(url), file).toString();
          }
          return new URL(url.replace(/\\/g, "/"), file).toString();
        }
        if (path5.isAbsolute(file)) {
          if (isFileUrl(url)) {
            return fileURLToPath(url);
          }
          if (isSchemeRelativeUrl(url)) {
            return fileURLToPath(new URL(url, "file://"));
          }
          if (isAbsoluteUrl(url)) {
            return url;
          }
          if (path5.isAbsolute(url)) {
            return path5.normalize(url);
          }
          return path5.join(file, "..", decodeURI(url));
        }
        if (isAbsoluteUrl(url) || isSchemeRelativeUrl(url)) {
          return url;
        }
        return path5.join(file, "..", url);
      } catch (e) {
        return url;
      }
    }
    function matchStyleOfPathOrUrl(matchStyleOf, pathOrUrl) {
      try {
        if (isAbsoluteUrl(matchStyleOf) || isSchemeRelativeUrl(matchStyleOf)) {
          if (isAbsoluteUrl(pathOrUrl) || isSchemeRelativeUrl(pathOrUrl))
            return pathOrUrl;
          if (path5.isAbsolute(pathOrUrl))
            return pathToFileURL(pathOrUrl).toString();
        } else if (path5.isAbsolute(matchStyleOf)) {
          if (isAbsoluteUrl(pathOrUrl) || isSchemeRelativeUrl(pathOrUrl)) {
            return fileURLToPath(new URL(pathOrUrl, "file://"));
          }
        }
        return pathOrUrl;
      } catch (e) {
        return pathOrUrl;
      }
    }
    function retrieveSourceMapURL(source) {
      var fileData;
      if (isInBrowser()) {
        try {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", source, false);
          xhr.send(null);
          fileData = xhr.readyState === 4 ? xhr.responseText : null;
          var sourceMapHeader = xhr.getResponseHeader("SourceMap") || xhr.getResponseHeader("X-SourceMap");
          if (sourceMapHeader) {
            return sourceMapHeader;
          }
        } catch (e) {
        }
      }
      fileData = retrieveFile(tryFileURLToPath(source));
      var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
      var lastMatch, match;
      while (match = re.exec(fileData))
        lastMatch = match;
      if (!lastMatch)
        return null;
      return lastMatch[1];
    }
    var retrieveSourceMap = handlerExec(sharedData.retrieveMapHandlers, sharedData.internalRetrieveMapHandlers);
    sharedData.internalRetrieveMapHandlers.push(function(source) {
      var sourceMappingURL = retrieveSourceMapURL(source);
      if (!sourceMappingURL)
        return null;
      var sourceMapData;
      if (reSourceMap.test(sourceMappingURL)) {
        var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
        sourceMapData = Buffer.from(rawData, "base64").toString();
        sourceMappingURL = source;
      } else {
        sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
        sourceMapData = retrieveFile(tryFileURLToPath(sourceMappingURL));
      }
      if (!sourceMapData) {
        return null;
      }
      return {
        url: sourceMappingURL,
        map: sourceMapData
      };
    });
    function mapSourcePosition(position) {
      var sourceMap = getSourceMapCache(position.source);
      if (!sourceMap) {
        var urlAndMap = retrieveSourceMap(position.source);
        if (urlAndMap) {
          sourceMap = setSourceMapCache(position.source, {
            url: urlAndMap.url,
            map: new AnyMap(urlAndMap.map, urlAndMap.url)
          });
          sourceMap.map.resolvedSources = sourceMap.map.sources.map((s) => supportRelativeURL(sourceMap.url, s));
          if (sourceMap.map.sourcesContent) {
            sourceMap.map.resolvedSources.forEach(function(resolvedSource, i) {
              var contents = sourceMap.map.sourcesContent[i];
              if (contents) {
                setFileContentsCache(resolvedSource, contents);
              }
            });
          }
        } else {
          sourceMap = setSourceMapCache(position.source, {
            url: null,
            map: null
          });
        }
      }
      if (sourceMap && sourceMap.map) {
        var originalPosition = originalPositionFor(sourceMap.map, position);
        if (originalPosition.source !== null) {
          originalPosition.source = matchStyleOfPathOrUrl(
            position.source,
            originalPosition.source
          );
          return originalPosition;
        }
      }
      return position;
    }
    function mapEvalOrigin(origin) {
      var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      if (match) {
        var position = mapSourcePosition({
          source: match[2],
          line: +match[3],
          column: match[4] - 1
        });
        return "eval at " + match[1] + " (" + position.source + ":" + position.line + ":" + (position.column + 1) + ")";
      }
      match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
      if (match) {
        return "eval at " + match[1] + " (" + mapEvalOrigin(match[2]) + ")";
      }
      return origin;
    }
    function CallSiteToString() {
      var fileName;
      var fileLocation = "";
      if (this.isNative()) {
        fileLocation = "native";
      } else {
        fileName = this.getScriptNameOrSourceURL();
        if (!fileName && this.isEval()) {
          fileLocation = this.getEvalOrigin();
          fileLocation += ", ";
        }
        if (fileName) {
          fileLocation += fileName;
        } else {
          fileLocation += "<anonymous>";
        }
        var lineNumber = this.getLineNumber();
        if (lineNumber != null) {
          fileLocation += ":" + lineNumber;
          var columnNumber = this.getColumnNumber();
          if (columnNumber) {
            fileLocation += ":" + columnNumber;
          }
        }
      }
      var line = "";
      var isAsync = this.isAsync ? this.isAsync() : false;
      if (isAsync) {
        line += "async ";
        var isPromiseAll = this.isPromiseAll ? this.isPromiseAll() : false;
        var isPromiseAny = this.isPromiseAny ? this.isPromiseAny() : false;
        if (isPromiseAny || isPromiseAll) {
          line += isPromiseAll ? "Promise.all (index " : "Promise.any (index ";
          var promiseIndex = this.getPromiseIndex();
          line += promiseIndex + ")";
        }
      }
      var functionName = this.getFunctionName();
      var addSuffix = true;
      var isConstructor = this.isConstructor();
      var isMethodCall = !(this.isToplevel() || isConstructor);
      if (isMethodCall) {
        var typeName = this.getTypeName();
        if (typeName === "[object Object]") {
          typeName = "null";
        }
        var methodName = this.getMethodName();
        if (functionName) {
          if (typeName && functionName.indexOf(typeName) != 0) {
            line += typeName + ".";
          }
          line += functionName;
          if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
            line += " [as " + methodName + "]";
          }
        } else {
          line += typeName + "." + (methodName || "<anonymous>");
        }
      } else if (isConstructor) {
        line += "new " + (functionName || "<anonymous>");
      } else if (functionName) {
        line += functionName;
      } else {
        line += fileLocation;
        addSuffix = false;
      }
      if (addSuffix) {
        line += " (" + fileLocation + ")";
      }
      return line;
    }
    function cloneCallSite(frame) {
      var object = {};
      Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
        object[name] = /^(?:is|get)/.test(name) ? function() {
          return frame[name].call(frame);
        } : frame[name];
      });
      object.toString = CallSiteToString;
      return object;
    }
    function wrapCallSite(frame, state) {
      if (state === void 0) {
        state = { nextPosition: null, curPosition: null };
      }
      if (frame.isNative()) {
        state.curPosition = null;
        return frame;
      }
      var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      if (source) {
        if (source.startsWith("wasm://")) {
          state.curPosition = null;
          return frame;
        }
        var line = frame.getLineNumber();
        var column = frame.getColumnNumber() - 1;
        var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
        var headerLength = noHeader.test(process.version) ? 0 : 62;
        if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
          column -= headerLength;
        }
        var position = mapSourcePosition({
          source,
          line,
          column
        });
        state.curPosition = position;
        frame = cloneCallSite(frame);
        var originalFunctionName = frame.getFunctionName;
        frame.getFunctionName = function() {
          if (state.nextPosition == null) {
            return originalFunctionName();
          }
          return state.nextPosition.name || originalFunctionName();
        };
        frame.getFileName = function() {
          return position.source;
        };
        frame.getLineNumber = function() {
          return position.line;
        };
        frame.getColumnNumber = function() {
          return position.column + 1;
        };
        frame.getScriptNameOrSourceURL = function() {
          return position.source;
        };
        return frame;
      }
      var origin = frame.isEval() && frame.getEvalOrigin();
      if (origin) {
        origin = mapEvalOrigin(origin);
        frame = cloneCallSite(frame);
        frame.getEvalOrigin = function() {
          return origin;
        };
        return frame;
      }
      return frame;
    }
    var kIsNodeError = void 0;
    try {
      path5.resolve(123);
    } catch (e) {
      const symbols = Object.getOwnPropertySymbols(e);
      const symbol = symbols.find(function(s) {
        return s.toString().indexOf("kIsNodeError") >= 0;
      });
      if (symbol)
        kIsNodeError = symbol;
    }
    var ErrorPrototypeToString = (err) => Error.prototype.toString.call(err);
    function createPrepareStackTrace(hookState) {
      return prepareStackTrace;
      function prepareStackTrace(error, stack) {
        if (!hookState.enabled)
          return hookState.originalValue.apply(this, arguments);
        if (sharedData.emptyCacheBetweenOperations) {
          clearCaches();
        }
        var errorString;
        if (kIsNodeError) {
          if (kIsNodeError in error) {
            errorString = `${error.name} [${error.code}]: ${error.message}`;
          } else {
            errorString = ErrorPrototypeToString(error);
          }
        } else {
          var name = error.name || "Error";
          var message = error.message || "";
          errorString = message ? name + ": " + message : name;
        }
        var state = { nextPosition: null, curPosition: null };
        var processedStack = [];
        for (var i = stack.length - 1; i >= 0; i--) {
          processedStack.push("\n    at " + wrapCallSite(stack[i], state));
          state.nextPosition = state.curPosition;
        }
        state.curPosition = state.nextPosition = null;
        return errorString + processedStack.reverse().join("");
      }
    }
    function getErrorSource(error) {
      var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
      if (match) {
        var source = match[1];
        var line = +match[2];
        var column = +match[3];
        var contents = getFileContentsCache(source);
        const sourceAsPath = tryFileURLToPath(source);
        if (!contents && fs && fs.existsSync(sourceAsPath)) {
          try {
            contents = fs.readFileSync(sourceAsPath, "utf8");
          } catch (er) {
            contents = "";
          }
        }
        if (contents) {
          var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
          if (code) {
            return source + ":" + line + "\n" + code + "\n" + new Array(column).join(" ") + "^";
          }
        }
      }
      return null;
    }
    function printFatalErrorUponExit(error) {
      var source = getErrorSource(error);
      if (process.stderr._handle && process.stderr._handle.setBlocking) {
        process.stderr._handle.setBlocking(true);
      }
      if (source) {
        console.error(source);
      }
      console.error(
        util.inspect(error, {
          customInspect: false,
          colors: process.stderr.isTTY
        })
      );
    }
    function shimEmitUncaughtException() {
      const originalValue = process.emit;
      var hook = sharedData.processEmitHook = {
        enabled: true,
        originalValue,
        installedValue: void 0
      };
      var isTerminatingDueToFatalException = false;
      var fatalException;
      process.emit = sharedData.processEmitHook.installedValue = function(type) {
        const hadListeners = originalValue.apply(this, arguments);
        if (hook.enabled) {
          if (type === "uncaughtException" && !hadListeners) {
            isTerminatingDueToFatalException = true;
            fatalException = arguments[1];
            process.exit(1);
          }
          if (type === "exit" && isTerminatingDueToFatalException) {
            printFatalErrorUponExit(fatalException);
          }
        }
        return hadListeners;
      };
    }
    var originalRetrieveFileHandlers = sharedData.retrieveFileHandlers.slice(0);
    var originalRetrieveMapHandlers = sharedData.retrieveMapHandlers.slice(0);
    exports2.wrapCallSite = wrapCallSite;
    exports2.getErrorSource = getErrorSource;
    exports2.mapSourcePosition = mapSourcePosition;
    exports2.retrieveSourceMap = retrieveSourceMap;
    exports2.install = function(options) {
      options = options || {};
      if (options.environment) {
        environment = options.environment;
        if (["node", "browser", "auto"].indexOf(environment) === -1) {
          throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}");
        }
      }
      var Module = dynamicRequire(module2, "module");
      const { redirectConflictingLibrary = true, onConflictingLibraryRedirect } = options;
      if (redirectConflictingLibrary) {
        if (!sharedData.moduleResolveFilenameHook) {
          const originalValue = Module._resolveFilename;
          const moduleResolveFilenameHook = sharedData.moduleResolveFilenameHook = {
            enabled: true,
            originalValue,
            installedValue: void 0
          };
          Module._resolveFilename = sharedData.moduleResolveFilenameHook.installedValue = function(request, parent, isMain, options2) {
            if (moduleResolveFilenameHook.enabled) {
              let requestRedirect;
              if (request === "source-map-support") {
                requestRedirect = "./";
              } else if (request === "source-map-support/register") {
                requestRedirect = "./register";
              }
              if (requestRedirect !== void 0) {
                const newRequest = require.resolve(requestRedirect);
                for (const cb of sharedData.onConflictingLibraryRedirectArr) {
                  cb(request, parent, isMain, options2, newRequest);
                }
                request = newRequest;
              }
            }
            return originalValue.call(this, request, parent, isMain, options2);
          };
        }
        if (onConflictingLibraryRedirect) {
          sharedData.onConflictingLibraryRedirectArr.push(onConflictingLibraryRedirect);
        }
      }
      if (options.retrieveFile) {
        if (options.overrideRetrieveFile) {
          sharedData.retrieveFileHandlers.length = 0;
        }
        sharedData.retrieveFileHandlers.unshift(options.retrieveFile);
      }
      if (options.retrieveSourceMap) {
        if (options.overrideRetrieveSourceMap) {
          sharedData.retrieveMapHandlers.length = 0;
        }
        sharedData.retrieveMapHandlers.unshift(options.retrieveSourceMap);
      }
      if (options.hookRequire && !isInBrowser()) {
        var $compile = Module.prototype._compile;
        if (!$compile.__sourceMapSupport) {
          Module.prototype._compile = function(content, filename) {
            setFileContentsCache(filename, content);
            setSourceMapCache(filename, void 0);
            return $compile.call(this, content, filename);
          };
          Module.prototype._compile.__sourceMapSupport = true;
        }
      }
      if (!sharedData.emptyCacheBetweenOperations) {
        sharedData.emptyCacheBetweenOperations = "emptyCacheBetweenOperations" in options ? options.emptyCacheBetweenOperations : false;
      }
      if (!sharedData.errorPrepareStackTraceHook) {
        const originalValue = Error.prepareStackTrace;
        sharedData.errorPrepareStackTraceHook = {
          enabled: true,
          originalValue,
          installedValue: void 0
        };
        Error.prepareStackTrace = sharedData.errorPrepareStackTraceHook.installedValue = createPrepareStackTrace(sharedData.errorPrepareStackTraceHook);
      }
      if (!sharedData.processEmitHook) {
        var installHandler = "handleUncaughtExceptions" in options ? options.handleUncaughtExceptions : true;
        try {
          var worker_threads = dynamicRequire(module2, "worker_threads");
          if (worker_threads.isMainThread === false) {
            installHandler = false;
          }
        } catch (e) {
        }
        if (installHandler && hasGlobalProcessEventEmitter()) {
          shimEmitUncaughtException();
        }
      }
    };
    exports2.uninstall = function() {
      if (sharedData.processEmitHook) {
        sharedData.processEmitHook.enabled = false;
        if (process.emit === sharedData.processEmitHook.installedValue) {
          process.emit = sharedData.processEmitHook.originalValue;
        }
        sharedData.processEmitHook = void 0;
      }
      if (sharedData.errorPrepareStackTraceHook) {
        sharedData.errorPrepareStackTraceHook.enabled = false;
        if (Error.prepareStackTrace === sharedData.errorPrepareStackTraceHook.installedValue || typeof sharedData.errorPrepareStackTraceHook.originalValue !== "function") {
          Error.prepareStackTrace = sharedData.errorPrepareStackTraceHook.originalValue;
        }
        sharedData.errorPrepareStackTraceHook = void 0;
      }
      if (sharedData.moduleResolveFilenameHook) {
        sharedData.moduleResolveFilenameHook.enabled = false;
        var Module = dynamicRequire(module2, "module");
        if (Module._resolveFilename === sharedData.moduleResolveFilenameHook.installedValue) {
          Module._resolveFilename = sharedData.moduleResolveFilenameHook.originalValue;
        }
        sharedData.moduleResolveFilenameHook = void 0;
      }
      sharedData.onConflictingLibraryRedirectArr.length = 0;
    };
    exports2.resetRetrieveHandlers = function() {
      sharedData.retrieveFileHandlers.length = 0;
      sharedData.retrieveMapHandlers.length = 0;
    };
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internal-modules-esm-resolve.js
var require_node_internal_modules_esm_resolve = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internal-modules-esm-resolve.js"(exports2, module2) {
    "use strict";
    var { versionGteLt } = require_util();
    var builtinModuleProtocol = versionGteLt(process.versions.node, "14.13.1") || versionGteLt(process.versions.node, "12.20.0", "13.0.0") ? "node:" : "nodejs:";
    var {
      ArrayIsArray,
      ArrayPrototypeJoin,
      ArrayPrototypeShift,
      JSONParse,
      JSONStringify,
      ObjectFreeze,
      ObjectGetOwnPropertyNames,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeTest,
      SafeMap,
      SafeSet,
      StringPrototypeEndsWith,
      StringPrototypeIndexOf,
      StringPrototypeLastIndexOf,
      StringPrototypeReplace,
      StringPrototypeSlice,
      StringPrototypeSplit,
      StringPrototypeStartsWith,
      StringPrototypeSubstr
    } = require_node_primordials();
    var Module = require("module");
    var { NativeModule } = require_node_nativemodule();
    var {
      realpathSync,
      statSync,
      Stats
    } = require("fs");
    var { getOptionValue } = require_node_options();
    var policy = null;
    var { sep, relative } = require("path");
    var preserveSymlinks = getOptionValue("--preserve-symlinks");
    var preserveSymlinksMain = getOptionValue("--preserve-symlinks-main");
    var typeFlag = getOptionValue("--input-type");
    var { URL: URL2, pathToFileURL, fileURLToPath } = require("url");
    var {
      ERR_INPUT_TYPE_NOT_ALLOWED,
      ERR_INVALID_ARG_VALUE: ERR_INVALID_ARG_VALUE2,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MANIFEST_DEPENDENCY_MISSING,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_ESM_URL_SCHEME
      // } = require('internal/errors').codes;
    } = require_node_internal_errors().codes;
    var CJSModule = Module;
    var packageJsonReader = require_node_internal_modules_package_json_reader();
    var userConditions = getOptionValue("--conditions");
    var DEFAULT_CONDITIONS = ObjectFreeze(["node", "import", ...userConditions]);
    var DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);
    var pendingDeprecation = getOptionValue("--pending-deprecation");
    function createResolve(opts) {
      const { preferTsExts, tsNodeExperimentalSpecifierResolution, extensions } = opts;
      const esrnExtensions = extensions.experimentalSpecifierResolutionAddsIfOmitted;
      const { legacyMainResolveAddsIfOmitted, replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx } = extensions;
      const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue("--experimental-specifier-resolution");
      const emittedPackageWarnings = new SafeSet();
      function emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {
        const pjsonPath = fileURLToPath(pjsonUrl);
        if (!pendingDeprecation) {
          const nodeModulesIndex = StringPrototypeLastIndexOf(
            pjsonPath,
            "/node_modules/"
          );
          if (nodeModulesIndex !== -1) {
            const afterNodeModulesPath = StringPrototypeSlice(
              pjsonPath,
              nodeModulesIndex + 14,
              -13
            );
            try {
              const { packageSubpath } = parsePackageName(afterNodeModulesPath);
              if (packageSubpath === ".")
                return;
            } catch {
            }
          }
        }
        if (emittedPackageWarnings.has(pjsonPath + "|" + match))
          return;
        emittedPackageWarnings.add(pjsonPath + "|" + match);
        process.emitWarning(
          `Use of deprecated folder mapping "${match}" in the ${isExports ? '"exports"' : '"imports"'} field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ""}.
Update this package.json to use a subpath pattern like "${match}*".`,
          "DeprecationWarning",
          "DEP0148"
        );
      }
      function getConditionsSet(conditions) {
        if (conditions !== void 0 && conditions !== DEFAULT_CONDITIONS) {
          if (!ArrayIsArray(conditions)) {
            throw new ERR_INVALID_ARG_VALUE2(
              "conditions",
              conditions,
              "expected an array"
            );
          }
          return new SafeSet(conditions);
        }
        return DEFAULT_CONDITIONS_SET;
      }
      const realpathCache = new SafeMap();
      const packageJSONCache = new SafeMap();
      const statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, "15.3.0") || versionGteLt(process.versions.node, "14.17.0", "15.0.0");
      const tryStatSync = statSupportsThrowIfNoEntry ? tryStatSyncWithoutErrors : tryStatSyncWithErrors;
      const statsIfNotFound = new Stats();
      function tryStatSyncWithoutErrors(path5) {
        const stats = statSync(path5, { throwIfNoEntry: false });
        if (stats != null)
          return stats;
        return statsIfNotFound;
      }
      function tryStatSyncWithErrors(path5) {
        try {
          return statSync(path5);
        } catch {
          return statsIfNotFound;
        }
      }
      function getPackageConfig(path5, specifier, base) {
        const existing = packageJSONCache.get(path5);
        if (existing !== void 0) {
          return existing;
        }
        const source = packageJsonReader.read(path5).string;
        if (source === void 0) {
          const packageConfig2 = {
            pjsonPath: path5,
            exists: false,
            main: void 0,
            name: void 0,
            type: "none",
            exports: void 0,
            imports: void 0
          };
          packageJSONCache.set(path5, packageConfig2);
          return packageConfig2;
        }
        let packageJSON;
        try {
          packageJSON = JSONParse(source);
        } catch (error) {
          throw new ERR_INVALID_PACKAGE_CONFIG(
            path5,
            (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier),
            error.message
          );
        }
        let { imports, main, name, type } = packageJSON;
        const { exports: exports3 } = packageJSON;
        if (typeof imports !== "object" || imports === null)
          imports = void 0;
        if (typeof main !== "string")
          main = void 0;
        if (typeof name !== "string")
          name = void 0;
        if (type !== "module" && type !== "commonjs")
          type = "none";
        const packageConfig = {
          pjsonPath: path5,
          exists: true,
          main,
          name,
          type,
          exports: exports3,
          imports
        };
        packageJSONCache.set(path5, packageConfig);
        return packageConfig;
      }
      function getPackageScopeConfig(resolved) {
        let packageJSONUrl = new URL2("./package.json", resolved);
        while (true) {
          const packageJSONPath2 = packageJSONUrl.pathname;
          if (StringPrototypeEndsWith(packageJSONPath2, "node_modules/package.json"))
            break;
          const packageConfig2 = getPackageConfig(
            fileURLToPath(packageJSONUrl),
            resolved
          );
          if (packageConfig2.exists)
            return packageConfig2;
          const lastPackageJSONUrl = packageJSONUrl;
          packageJSONUrl = new URL2("../package.json", packageJSONUrl);
          if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname)
            break;
        }
        const packageJSONPath = fileURLToPath(packageJSONUrl);
        const packageConfig = {
          pjsonPath: packageJSONPath,
          exists: false,
          main: void 0,
          name: void 0,
          type: "none",
          exports: void 0,
          imports: void 0
        };
        packageJSONCache.set(packageJSONPath, packageConfig);
        return packageConfig;
      }
      function fileExists(url) {
        return tryStatSync(fileURLToPath(url)).isFile();
      }
      function legacyMainResolve(packageJSONUrl, packageConfig, base) {
        let guess;
        if (packageConfig.main !== void 0) {
          if (guess = resolveReplacementExtensions(new URL2(`./${packageConfig.main}`, packageJSONUrl))) {
            return guess;
          }
          if (fileExists(guess = new URL2(
            `./${packageConfig.main}`,
            packageJSONUrl
          ))) {
            return guess;
          }
          for (const extension of legacyMainResolveAddsIfOmitted) {
            if (fileExists(guess = new URL2(
              `./${packageConfig.main}${extension}`,
              packageJSONUrl
            ))) {
              return guess;
            }
          }
          for (const extension of legacyMainResolveAddsIfOmitted) {
            if (fileExists(guess = new URL2(
              `./${packageConfig.main}/index${extension}`,
              packageJSONUrl
            ))) {
              return guess;
            }
          }
        }
        for (const extension of legacyMainResolveAddsIfOmitted) {
          if (fileExists(guess = new URL2(`./index${extension}`, packageJSONUrl))) {
            return guess;
          }
        }
        throw new ERR_MODULE_NOT_FOUND(
          fileURLToPath(new URL2(".", packageJSONUrl)),
          fileURLToPath(base)
        );
      }
      function resolveExtensionsWithTryExactName(search) {
        const resolvedReplacementExtension = resolveReplacementExtensions(search);
        if (resolvedReplacementExtension)
          return resolvedReplacementExtension;
        if (fileExists(search))
          return search;
        return resolveExtensions(search);
      }
      function resolveExtensions(search) {
        for (let i = 0; i < esrnExtensions.length; i++) {
          const extension = esrnExtensions[i];
          const guess = new URL2(`${search.pathname}${extension}`, search);
          if (fileExists(guess))
            return guess;
        }
        return void 0;
      }
      function resolveReplacementExtensions(search) {
        const lastDotIndex = search.pathname.lastIndexOf(".");
        if (lastDotIndex >= 0) {
          const ext = search.pathname.slice(lastDotIndex);
          if (ext === ".js" || ext === ".jsx" || ext === ".mjs" || ext === ".cjs") {
            const pathnameWithoutExtension = search.pathname.slice(0, lastDotIndex);
            const replacementExts = ext === ".js" ? replacementsForJs : ext === ".jsx" ? replacementsForJsx : ext === ".mjs" ? replacementsForMjs : replacementsForCjs;
            const guess = new URL2(search.toString());
            for (let i = 0; i < replacementExts.length; i++) {
              const extension = replacementExts[i];
              guess.pathname = `${pathnameWithoutExtension}${extension}`;
              if (fileExists(guess))
                return guess;
            }
          }
        }
        return void 0;
      }
      function resolveIndex(search) {
        return resolveExtensions(new URL2("index", search));
      }
      const encodedSepRegEx = /%2F|%2C/i;
      function finalizeResolution(resolved, base) {
        if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))
          throw new ERR_INVALID_MODULE_SPECIFIER(
            resolved.pathname,
            'must not include encoded "/" or "\\" characters',
            fileURLToPath(base)
          );
        if (experimentalSpecifierResolution === "node") {
          const path6 = fileURLToPath(resolved);
          let file2 = resolveExtensionsWithTryExactName(resolved);
          if (file2 !== void 0)
            return file2;
          if (!StringPrototypeEndsWith(path6, "/")) {
            file2 = resolveIndex(new URL2(`${resolved}/`));
            if (file2 !== void 0)
              return file2;
          } else {
            return resolveIndex(resolved) || resolved;
          }
          throw new ERR_MODULE_NOT_FOUND(
            resolved.pathname,
            fileURLToPath(base),
            "module"
          );
        }
        const file = resolveReplacementExtensions(resolved) || resolved;
        const path5 = fileURLToPath(file);
        const stats = tryStatSync(StringPrototypeEndsWith(path5, "/") ? StringPrototypeSlice(path5, -1) : path5);
        if (stats.isDirectory()) {
          const err = new ERR_UNSUPPORTED_DIR_IMPORT(path5, fileURLToPath(base));
          err.url = String(resolved);
          throw err;
        } else if (!stats.isFile()) {
          throw new ERR_MODULE_NOT_FOUND(
            path5 || resolved.pathname,
            fileURLToPath(base),
            "module"
          );
        }
        return file;
      }
      function throwImportNotDefined(specifier, packageJSONUrl, base) {
        throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(
          specifier,
          packageJSONUrl && fileURLToPath(new URL2(".", packageJSONUrl)),
          fileURLToPath(base)
        );
      }
      function throwExportsNotFound(subpath, packageJSONUrl, base) {
        throw new ERR_PACKAGE_PATH_NOT_EXPORTED(
          fileURLToPath(new URL2(".", packageJSONUrl)),
          subpath,
          base && fileURLToPath(base)
        );
      }
      function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {
        const reason = `request is not a valid subpath for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath(packageJSONUrl)}`;
        throw new ERR_INVALID_MODULE_SPECIFIER(
          subpath,
          reason,
          base && fileURLToPath(base)
        );
      }
      function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {
        if (typeof target === "object" && target !== null) {
          target = JSONStringify(target, null, "");
        } else {
          target = `${target}`;
        }
        throw new ERR_INVALID_PACKAGE_TARGET(
          fileURLToPath(new URL2(".", packageJSONUrl)),
          subpath,
          target,
          internal,
          base && fileURLToPath(base)
        );
      }
      const invalidSegmentRegEx = /(^|\\|\/)(\.\.?|node_modules)(\\|\/|$)/;
      const patternRegEx = /\*/g;
      function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {
        if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
          throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
        if (!StringPrototypeStartsWith(target, "./")) {
          if (internal && !StringPrototypeStartsWith(target, "../") && !StringPrototypeStartsWith(target, "/")) {
            let isURL = false;
            try {
              new URL2(target);
              isURL = true;
            } catch {
            }
            if (!isURL) {
              const exportTarget = pattern ? StringPrototypeReplace(target, patternRegEx, subpath) : target + subpath;
              return packageResolve(exportTarget, packageJSONUrl, conditions);
            }
          }
          throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
        }
        if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2)))
          throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
        const resolved = new URL2(target, packageJSONUrl);
        const resolvedPath = resolved.pathname;
        const packagePath = new URL2(".", packageJSONUrl).pathname;
        if (!StringPrototypeStartsWith(resolvedPath, packagePath))
          throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);
        if (subpath === "")
          return resolved;
        if (RegExpPrototypeTest(invalidSegmentRegEx, subpath))
          throwInvalidSubpath(match + subpath, packageJSONUrl, internal, base);
        if (pattern)
          return new URL2(StringPrototypeReplace(
            resolved.href,
            patternRegEx,
            subpath
          ));
        return new URL2(subpath, resolved);
      }
      function isArrayIndex(key) {
        const keyNum = +key;
        if (`${keyNum}` !== key)
          return false;
        return keyNum >= 0 && keyNum < 4294967295;
      }
      function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {
        if (typeof target === "string") {
          return resolvePackageTargetString(
            target,
            subpath,
            packageSubpath,
            packageJSONUrl,
            base,
            pattern,
            internal,
            conditions
          );
        } else if (ArrayIsArray(target)) {
          if (target.length === 0)
            return null;
          let lastException;
          for (let i = 0; i < target.length; i++) {
            const targetItem = target[i];
            let resolved;
            try {
              resolved = resolvePackageTarget(
                packageJSONUrl,
                targetItem,
                subpath,
                packageSubpath,
                base,
                pattern,
                internal,
                conditions
              );
            } catch (e) {
              lastException = e;
              if (e.code === "ERR_INVALID_PACKAGE_TARGET")
                continue;
              throw e;
            }
            if (resolved === void 0)
              continue;
            if (resolved === null) {
              lastException = null;
              continue;
            }
            return resolved;
          }
          if (lastException === void 0 || lastException === null)
            return lastException;
          throw lastException;
        } else if (typeof target === "object" && target !== null) {
          const keys = ObjectGetOwnPropertyNames(target);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (isArrayIndex(key)) {
              throw new ERR_INVALID_PACKAGE_CONFIG(
                fileURLToPath(packageJSONUrl),
                base,
                '"exports" cannot contain numeric property keys.'
              );
            }
          }
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            if (key === "default" || conditions.has(key)) {
              const conditionalTarget = target[key];
              const resolved = resolvePackageTarget(
                packageJSONUrl,
                conditionalTarget,
                subpath,
                packageSubpath,
                base,
                pattern,
                internal,
                conditions
              );
              if (resolved === void 0)
                continue;
              return resolved;
            }
          }
          return void 0;
        } else if (target === null) {
          return null;
        }
        throwInvalidPackageTarget(
          packageSubpath,
          target,
          packageJSONUrl,
          internal,
          base
        );
      }
      function isConditionalExportsMainSugar(exports3, packageJSONUrl, base) {
        if (typeof exports3 === "string" || ArrayIsArray(exports3))
          return true;
        if (typeof exports3 !== "object" || exports3 === null)
          return false;
        const keys = ObjectGetOwnPropertyNames(exports3);
        let isConditionalSugar = false;
        let i = 0;
        for (let j = 0; j < keys.length; j++) {
          const key = keys[j];
          const curIsConditionalSugar = key === "" || key[0] !== ".";
          if (i++ === 0) {
            isConditionalSugar = curIsConditionalSugar;
          } else if (isConditionalSugar !== curIsConditionalSugar) {
            throw new ERR_INVALID_PACKAGE_CONFIG(
              fileURLToPath(packageJSONUrl),
              base,
              `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
            );
          }
        }
        return isConditionalSugar;
      }
      function packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions) {
        let exports3 = packageConfig.exports;
        if (isConditionalExportsMainSugar(exports3, packageJSONUrl, base))
          exports3 = { ".": exports3 };
        if (ObjectPrototypeHasOwnProperty(exports3, packageSubpath)) {
          const target = exports3[packageSubpath];
          const resolved = resolvePackageTarget(
            packageJSONUrl,
            target,
            "",
            packageSubpath,
            base,
            false,
            false,
            conditions
          );
          if (resolved === null || resolved === void 0)
            throwExportsNotFound(packageSubpath, packageJSONUrl, base);
          return { resolved, exact: true };
        }
        let bestMatch = "";
        const keys = ObjectGetOwnPropertyNames(exports3);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          if (key[key.length - 1] === "*" && StringPrototypeStartsWith(
            packageSubpath,
            StringPrototypeSlice(key, 0, -1)
          ) && packageSubpath.length >= key.length && key.length > bestMatch.length) {
            bestMatch = key;
          } else if (key[key.length - 1] === "/" && StringPrototypeStartsWith(packageSubpath, key) && key.length > bestMatch.length) {
            bestMatch = key;
          }
        }
        if (bestMatch) {
          const target = exports3[bestMatch];
          const pattern = bestMatch[bestMatch.length - 1] === "*";
          const subpath = StringPrototypeSubstr(packageSubpath, bestMatch.length - (pattern ? 1 : 0));
          const resolved = resolvePackageTarget(
            packageJSONUrl,
            target,
            subpath,
            bestMatch,
            base,
            pattern,
            false,
            conditions
          );
          if (resolved === null || resolved === void 0)
            throwExportsNotFound(packageSubpath, packageJSONUrl, base);
          if (!pattern)
            emitFolderMapDeprecation(bestMatch, packageJSONUrl, true, base);
          return { resolved, exact: pattern };
        }
        throwExportsNotFound(packageSubpath, packageJSONUrl, base);
      }
      function packageImportsResolve(name, base, conditions) {
        if (name === "#" || StringPrototypeStartsWith(name, "#/")) {
          const reason = "is not a valid internal imports specifier name";
          throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));
        }
        let packageJSONUrl;
        const packageConfig = getPackageScopeConfig(base);
        if (packageConfig.exists) {
          packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);
          const imports = packageConfig.imports;
          if (imports) {
            if (ObjectPrototypeHasOwnProperty(imports, name)) {
              const resolved = resolvePackageTarget(
                packageJSONUrl,
                imports[name],
                "",
                name,
                base,
                false,
                true,
                conditions
              );
              if (resolved !== null)
                return { resolved, exact: true };
            } else {
              let bestMatch = "";
              const keys = ObjectGetOwnPropertyNames(imports);
              for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                if (key[key.length - 1] === "*" && StringPrototypeStartsWith(
                  name,
                  StringPrototypeSlice(key, 0, -1)
                ) && name.length >= key.length && key.length > bestMatch.length) {
                  bestMatch = key;
                } else if (key[key.length - 1] === "/" && StringPrototypeStartsWith(name, key) && key.length > bestMatch.length) {
                  bestMatch = key;
                }
              }
              if (bestMatch) {
                const target = imports[bestMatch];
                const pattern = bestMatch[bestMatch.length - 1] === "*";
                const subpath = StringPrototypeSubstr(name, bestMatch.length - (pattern ? 1 : 0));
                const resolved = resolvePackageTarget(
                  packageJSONUrl,
                  target,
                  subpath,
                  bestMatch,
                  base,
                  pattern,
                  true,
                  conditions
                );
                if (resolved !== null) {
                  if (!pattern)
                    emitFolderMapDeprecation(bestMatch, packageJSONUrl, false, base);
                  return { resolved, exact: pattern };
                }
              }
            }
          }
        }
        throwImportNotDefined(name, packageJSONUrl, base);
      }
      function getPackageType(url) {
        const packageConfig = getPackageScopeConfig(url);
        return packageConfig.type;
      }
      function parsePackageName(specifier, base) {
        let separatorIndex = StringPrototypeIndexOf(specifier, "/");
        let validPackageName = true;
        let isScoped = false;
        if (specifier[0] === "@") {
          isScoped = true;
          if (separatorIndex === -1 || specifier.length === 0) {
            validPackageName = false;
          } else {
            separatorIndex = StringPrototypeIndexOf(
              specifier,
              "/",
              separatorIndex + 1
            );
          }
        }
        const packageName = separatorIndex === -1 ? specifier : StringPrototypeSlice(specifier, 0, separatorIndex);
        for (let i = 0; i < packageName.length; i++) {
          if (packageName[i] === "%" || packageName[i] === "\\") {
            validPackageName = false;
            break;
          }
        }
        if (!validPackageName) {
          throw new ERR_INVALID_MODULE_SPECIFIER(
            specifier,
            "is not a valid package name",
            fileURLToPath(base)
          );
        }
        const packageSubpath = "." + (separatorIndex === -1 ? "" : StringPrototypeSlice(specifier, separatorIndex));
        return { packageName, packageSubpath, isScoped };
      }
      function packageResolve(specifier, base, conditions) {
        const { packageName, packageSubpath, isScoped } = parsePackageName(specifier, base);
        const packageConfig = getPackageScopeConfig(base);
        if (packageConfig.exists) {
          const packageJSONUrl2 = pathToFileURL(packageConfig.pjsonPath);
          if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
            return packageExportsResolve(
              packageJSONUrl2,
              packageSubpath,
              packageConfig,
              base,
              conditions
            ).resolved;
          }
        }
        let packageJSONUrl = new URL2("./node_modules/" + packageName + "/package.json", base);
        let packageJSONPath = fileURLToPath(packageJSONUrl);
        let lastPath;
        do {
          const stat = tryStatSync(StringPrototypeSlice(
            packageJSONPath,
            0,
            packageJSONPath.length - 13
          ));
          if (!stat.isDirectory()) {
            lastPath = packageJSONPath;
            packageJSONUrl = new URL2((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json", packageJSONUrl);
            packageJSONPath = fileURLToPath(packageJSONUrl);
            continue;
          }
          const packageConfig2 = getPackageConfig(packageJSONPath, specifier, base);
          if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null)
            return packageExportsResolve(
              packageJSONUrl,
              packageSubpath,
              packageConfig2,
              base,
              conditions
            ).resolved;
          if (packageSubpath === ".")
            return legacyMainResolve(packageJSONUrl, packageConfig2, base);
          return new URL2(packageSubpath, packageJSONUrl);
        } while (packageJSONPath.length !== lastPath.length);
        throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));
      }
      function isBareSpecifier(specifier) {
        return specifier[0] && specifier[0] !== "/" && specifier[0] !== ".";
      }
      function isRelativeSpecifier(specifier) {
        if (specifier[0] === ".") {
          if (specifier.length === 1 || specifier[1] === "/")
            return true;
          if (specifier[1] === ".") {
            if (specifier.length === 2 || specifier[2] === "/")
              return true;
          }
        }
        return false;
      }
      function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
        if (specifier === "")
          return false;
        if (specifier[0] === "/")
          return true;
        return isRelativeSpecifier(specifier);
      }
      function moduleResolve(specifier, base, conditions) {
        let resolved;
        if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
          resolved = new URL2(specifier, base);
        } else if (specifier[0] === "#") {
          ({ resolved } = packageImportsResolve(specifier, base, conditions));
        } else {
          try {
            resolved = new URL2(specifier);
          } catch {
            resolved = packageResolve(specifier, base, conditions);
          }
        }
        return finalizeResolution(resolved, base);
      }
      function resolveAsCommonJS(specifier, parentURL) {
        try {
          const parent = fileURLToPath(parentURL);
          const tmpModule = new CJSModule(parent, null);
          tmpModule.paths = CJSModule._nodeModulePaths(parent);
          let found = CJSModule._resolveFilename(specifier, tmpModule, false);
          if (isRelativeSpecifier(specifier)) {
            found = relative(parent, found);
            if (!StringPrototypeStartsWith(found, `..${sep}`)) {
              found = `.${sep}${found}`;
            }
          } else if (isBareSpecifier(specifier)) {
            const pkg = StringPrototypeSplit(specifier, "/")[0];
            const index = StringPrototypeIndexOf(found, pkg);
            if (index !== -1) {
              found = StringPrototypeSlice(found, index);
            }
          }
          if (process.platform === "win32") {
            found = StringPrototypeReplace(found, new RegExp(`\\${sep}`, "g"), "/");
          }
          return found;
        } catch {
          return false;
        }
      }
      function defaultResolve(specifier, context = {}, defaultResolveUnused) {
        let { parentURL, conditions } = context;
        if (parentURL && policy != null && policy.manifest) {
          const redirects = policy.manifest.getDependencyMapper(parentURL);
          if (redirects) {
            const { resolve: resolve2, reaction } = redirects;
            const destination = resolve2(specifier, new SafeSet(conditions));
            let missing = true;
            if (destination === true) {
              missing = false;
            } else if (destination) {
              const href = destination.href;
              return { url: href };
            }
            if (missing) {
              reaction(
                new ERR_MANIFEST_DEPENDENCY_MISSING(
                  parentURL,
                  specifier,
                  ArrayPrototypeJoin([...conditions], ", ")
                )
              );
            }
          }
        }
        let parsed;
        try {
          parsed = new URL2(specifier);
          if (parsed.protocol === "data:") {
            return {
              url: specifier
            };
          }
        } catch {
        }
        if (parsed && parsed.protocol === builtinModuleProtocol)
          return { url: specifier };
        if (parsed && parsed.protocol !== "file:" && parsed.protocol !== "data:")
          throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);
        if (NativeModule.canBeRequiredByUsers(specifier)) {
          return {
            url: builtinModuleProtocol + specifier
          };
        }
        if (parentURL && StringPrototypeStartsWith(parentURL, "data:")) {
          new URL2(specifier, parentURL);
        }
        const isMain = parentURL === void 0;
        if (isMain) {
          parentURL = pathToFileURL(`${process.cwd()}/`).href;
          if (typeFlag)
            throw new ERR_INPUT_TYPE_NOT_ALLOWED();
        }
        conditions = getConditionsSet(conditions);
        let url;
        try {
          url = moduleResolve(specifier, parentURL, conditions);
        } catch (error) {
          if (error.code === "ERR_MODULE_NOT_FOUND" || error.code === "ERR_UNSUPPORTED_DIR_IMPORT") {
            if (StringPrototypeStartsWith(specifier, "file://")) {
              specifier = fileURLToPath(specifier);
            }
            const found = resolveAsCommonJS(specifier, parentURL);
            if (found) {
              const lines = StringPrototypeSplit(error.stack, "\n");
              const hint = `Did you mean to import ${found}?`;
              error.stack = ArrayPrototypeShift(lines) + "\n" + hint + "\n" + ArrayPrototypeJoin(lines, "\n");
              error.message += `
${hint}`;
            }
          }
          throw error;
        }
        if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {
          const urlPath = fileURLToPath(url);
          const real = realpathSync(urlPath, {
            // [internalFS.realpathCacheKey]: realpathCache
          });
          const old = url;
          url = pathToFileURL(
            real + (StringPrototypeEndsWith(urlPath, sep) ? "/" : "")
          );
          url.search = old.search;
          url.hash = old.hash;
        }
        return { url: `${url}` };
      }
      return {
        DEFAULT_CONDITIONS,
        defaultResolve,
        encodedSepRegEx,
        getPackageType,
        packageExportsResolve,
        packageImportsResolve
      };
    }
    module2.exports = {
      createResolve
    };
  }
});

// ../../../node_modules/ts-node/dist-raw/node-internal-modules-esm-get_format.js
var require_node_internal_modules_esm_get_format = __commonJS({
  "../../../node_modules/ts-node/dist-raw/node-internal-modules-esm-get_format.js"(exports2, module2) {
    "use strict";
    var {
      RegExpPrototypeExec,
      StringPrototypeStartsWith
    } = require_node_primordials();
    var { extname } = require("path");
    var { getOptionValue } = require_node_options();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((s) => parseInt(s, 10));
    var experimentalJsonModules = nodeMajor > 17 || nodeMajor === 17 && nodeMinor >= 5 || nodeMajor === 16 && nodeMinor >= 15 || getOptionValue("--experimental-json-modules");
    var experimentalWasmModules = getOptionValue("--experimental-wasm-modules");
    var { URL: URL2, fileURLToPath } = require("url");
    var { ERR_UNKNOWN_FILE_EXTENSION } = require_node_internal_errors().codes;
    var extensionFormatMap = {
      "__proto__": null,
      ".cjs": "commonjs",
      ".js": "module",
      ".mjs": "module"
    };
    var legacyExtensionFormatMap = {
      "__proto__": null,
      ".cjs": "commonjs",
      ".js": "commonjs",
      ".json": "commonjs",
      ".mjs": "module",
      ".node": "commonjs"
    };
    if (experimentalWasmModules)
      extensionFormatMap[".wasm"] = legacyExtensionFormatMap[".wasm"] = "wasm";
    if (experimentalJsonModules)
      extensionFormatMap[".json"] = legacyExtensionFormatMap[".json"] = "json";
    function createGetFormat(tsNodeExperimentalSpecifierResolution, nodeEsmResolver) {
      let experimentalSpeciferResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue("--experimental-specifier-resolution");
      const { getPackageType } = nodeEsmResolver;
      function defaultGetFormat(url, context, defaultGetFormatUnused) {
        if (StringPrototypeStartsWith(url, "node:")) {
          return { format: "builtin" };
        }
        const parsed = new URL2(url);
        if (parsed.protocol === "data:") {
          const [, mime] = RegExpPrototypeExec(
            /^([^/]+\/[^;,]+)(?:[^,]*?)(;base64)?,/,
            parsed.pathname
          ) || [null, null, null];
          const format2 = {
            "__proto__": null,
            "text/javascript": "module",
            "application/json": experimentalJsonModules ? "json" : null,
            "application/wasm": experimentalWasmModules ? "wasm" : null
          }[mime] || null;
          return { format: format2 };
        } else if (parsed.protocol === "file:") {
          const ext = extname(parsed.pathname);
          let format2;
          if (ext === ".js") {
            format2 = getPackageType(parsed.href) === "module" ? "module" : "commonjs";
          } else {
            format2 = extensionFormatMap[ext];
          }
          if (!format2) {
            if (experimentalSpeciferResolution === "node") {
              process.emitWarning(
                "The Node.js specifier resolution in ESM is experimental.",
                "ExperimentalWarning"
              );
              format2 = legacyExtensionFormatMap[ext];
            } else {
              throw new ERR_UNKNOWN_FILE_EXTENSION(ext, fileURLToPath(url));
            }
          }
          return { format: format2 || null };
        }
        return { format: null };
      }
      return { defaultGetFormat };
    }
    module2.exports = {
      createGetFormat
    };
  }
});

// ../../../node_modules/ts-node/dist/esm.js
var require_esm = __commonJS({
  "../../../node_modules/ts-node/dist/esm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEsmHooks = exports2.registerAndCreateEsmHooks = exports2.filterHooksByAPIVersion = void 0;
    var index_1 = require_dist2();
    var url_1 = require("url");
    var path_1 = require("path");
    var assert = require("assert");
    var util_1 = require_util();
    var module_1 = require("module");
    var newHooksAPI = (0, util_1.versionGteLt)(process.versions.node, "16.12.0");
    function filterHooksByAPIVersion(hooks) {
      const { getFormat, load, resolve: resolve2, transformSource } = hooks;
      const hooksAPI = newHooksAPI ? { resolve: resolve2, load, getFormat: void 0, transformSource: void 0 } : { resolve: resolve2, getFormat, transformSource, load: void 0 };
      return hooksAPI;
    }
    exports2.filterHooksByAPIVersion = filterHooksByAPIVersion;
    function registerAndCreateEsmHooks(opts) {
      const tsNodeInstance = (0, index_1.register)(opts);
      return createEsmHooks(tsNodeInstance);
    }
    exports2.registerAndCreateEsmHooks = registerAndCreateEsmHooks;
    function createEsmHooks(tsNodeService) {
      tsNodeService.enableExperimentalEsmLoaderInterop();
      const nodeResolveImplementation = tsNodeService.getNodeEsmResolver();
      const nodeGetFormatImplementation = tsNodeService.getNodeEsmGetFormat();
      const extensions = tsNodeService.extensions;
      const hooksAPI = filterHooksByAPIVersion({
        resolve: resolve2,
        load,
        getFormat,
        transformSource
      });
      function isFileUrlOrNodeStyleSpecifier(parsed) {
        const { protocol } = parsed;
        return protocol === null || protocol === "file:";
      }
      function isProbablyEntrypoint(specifier, parentURL) {
        return parentURL === void 0 && specifier.startsWith("file://");
      }
      const rememberIsProbablyEntrypoint = /* @__PURE__ */ new Set();
      const rememberResolvedViaCommonjsFallback = /* @__PURE__ */ new Set();
      async function resolve2(specifier, context, defaultResolve) {
        const defer = async () => {
          const r = await defaultResolve(specifier, context, defaultResolve);
          return r;
        };
        async function entrypointFallback(cb) {
          try {
            const resolution = await cb();
            if ((resolution === null || resolution === void 0 ? void 0 : resolution.url) && isProbablyEntrypoint(specifier, context.parentURL))
              rememberIsProbablyEntrypoint.add(resolution.url);
            return resolution;
          } catch (esmResolverError) {
            if (!isProbablyEntrypoint(specifier, context.parentURL))
              throw esmResolverError;
            try {
              let cjsSpecifier = specifier;
              try {
                if (specifier.startsWith("file://"))
                  cjsSpecifier = (0, url_1.fileURLToPath)(specifier);
              } catch {
              }
              const resolution = (0, url_1.pathToFileURL)((0, module_1.createRequire)(process.cwd()).resolve(cjsSpecifier)).toString();
              rememberIsProbablyEntrypoint.add(resolution);
              rememberResolvedViaCommonjsFallback.add(resolution);
              return { url: resolution, format: "commonjs" };
            } catch (commonjsResolverError) {
              throw esmResolverError;
            }
          }
        }
        return addShortCircuitFlag(async () => {
          const parsed = (0, url_1.parse)(specifier);
          const { pathname, protocol, hostname } = parsed;
          if (!isFileUrlOrNodeStyleSpecifier(parsed)) {
            return entrypointFallback(defer);
          }
          if (protocol !== null && protocol !== "file:") {
            return entrypointFallback(defer);
          }
          if (hostname) {
            return entrypointFallback(defer);
          }
          return entrypointFallback(() => nodeResolveImplementation.defaultResolve(specifier, context, defaultResolve));
        });
      }
      async function load(url, context, defaultLoad) {
        return addShortCircuitFlag(async () => {
          var _a2;
          const format2 = (_a2 = context.format) !== null && _a2 !== void 0 ? _a2 : (await getFormat(url, context, nodeGetFormatImplementation.defaultGetFormat)).format;
          let source = void 0;
          if (format2 !== "builtin" && format2 !== "commonjs") {
            const { source: rawSource } = await defaultLoad(url, {
              ...context,
              format: format2
            }, defaultLoad);
            if (rawSource === void 0 || rawSource === null) {
              throw new Error(`Failed to load raw source: Format was '${format2}' and url was '${url}''.`);
            }
            const defaultTransformSource = async (source2, _context, _defaultTransformSource) => ({ source: source2 });
            const { source: transformedSource } = await transformSource(rawSource, { url, format: format2 }, defaultTransformSource);
            source = transformedSource;
          }
          return { format: format2, source };
        });
      }
      async function getFormat(url, context, defaultGetFormat) {
        const defer = (overrideUrl = url) => defaultGetFormat(overrideUrl, context, defaultGetFormat);
        async function entrypointFallback(cb) {
          try {
            return await cb();
          } catch (getFormatError) {
            if (!rememberIsProbablyEntrypoint.has(url))
              throw getFormatError;
            return { format: "commonjs" };
          }
        }
        const parsed = (0, url_1.parse)(url);
        if (!isFileUrlOrNodeStyleSpecifier(parsed)) {
          return entrypointFallback(defer);
        }
        const { pathname } = parsed;
        assert(pathname !== null, "ESM getFormat() hook: URL should never have null pathname");
        const nativePath = (0, url_1.fileURLToPath)(url);
        let nodeSays;
        const ext = (0, path_1.extname)(nativePath);
        const tsNodeIgnored = tsNodeService.ignored(nativePath);
        const nodeEquivalentExt = extensions.nodeEquivalents.get(ext);
        if (nodeEquivalentExt && !tsNodeIgnored) {
          nodeSays = await entrypointFallback(() => defer((0, url_1.format)((0, url_1.pathToFileURL)(nativePath + nodeEquivalentExt))));
        } else {
          try {
            nodeSays = await entrypointFallback(defer);
          } catch (e) {
            if (e instanceof Error && tsNodeIgnored && extensions.nodeDoesNotUnderstand.includes(ext)) {
              e.message += `

Hint:
ts-node is configured to ignore this file.
If you want ts-node to handle this file, consider enabling the "skipIgnore" option or adjusting your "ignore" patterns.
https://typestrong.org/ts-node/docs/scope
`;
            }
            throw e;
          }
        }
        if (!tsNodeService.ignored(nativePath) && (nodeSays.format === "commonjs" || nodeSays.format === "module")) {
          const { moduleType } = tsNodeService.moduleTypeClassifier.classifyModuleByModuleTypeOverrides((0, util_1.normalizeSlashes)(nativePath));
          if (moduleType === "cjs") {
            return { format: "commonjs" };
          } else if (moduleType === "esm") {
            return { format: "module" };
          }
        }
        return nodeSays;
      }
      async function transformSource(source, context, defaultTransformSource) {
        if (source === null || source === void 0) {
          throw new Error("No source");
        }
        const defer = () => defaultTransformSource(source, context, defaultTransformSource);
        const sourceAsString = typeof source === "string" ? source : source.toString("utf8");
        const { url } = context;
        const parsed = (0, url_1.parse)(url);
        if (!isFileUrlOrNodeStyleSpecifier(parsed)) {
          return defer();
        }
        const nativePath = (0, url_1.fileURLToPath)(url);
        if (tsNodeService.ignored(nativePath)) {
          return defer();
        }
        const emittedJs = tsNodeService.compile(sourceAsString, nativePath);
        return { source: emittedJs };
      }
      return hooksAPI;
    }
    exports2.createEsmHooks = createEsmHooks;
    async function addShortCircuitFlag(fn) {
      const ret = await fn();
      if (ret == null)
        return ret;
      return {
        ...ret,
        shortCircuit: true
      };
    }
  }
});

// ../../../node_modules/ts-node/dist/index.js
var require_dist2 = __commonJS({
  "../../../node_modules/ts-node/dist/index.js"(exports2) {
    "use strict";
    var _a2;
    var _b2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createEsmHooks = exports2.createFromPreloadedConfig = exports2.create = exports2.register = exports2.TSError = exports2.DEFAULTS = exports2.VERSION = exports2.debug = exports2.INSPECT_CUSTOM = exports2.env = exports2.REGISTER_INSTANCE = exports2.createRepl = void 0;
    var path_1 = require("path");
    var module_1 = require("module");
    var util = require("util");
    var url_1 = require("url");
    var make_error_1 = require_make_error();
    var util_1 = require_util();
    var configuration_1 = require_configuration();
    var module_type_classifier_1 = require_module_type_classifier();
    var resolver_functions_1 = require_resolver_functions();
    var cjs_resolve_hooks_1 = require_cjs_resolve_hooks();
    var node_module_type_classifier_1 = require_node_module_type_classifier();
    var file_extensions_1 = require_file_extensions();
    var ts_transpile_module_1 = require_ts_transpile_module();
    var repl_1 = require_repl();
    Object.defineProperty(exports2, "createRepl", { enumerable: true, get: function() {
      return repl_1.createRepl;
    } });
    var engineSupportsPackageTypeField = parseInt(process.versions.node.split(".")[0], 10) >= 12;
    var assertScriptCanLoadAsCJS = engineSupportsPackageTypeField ? require_node_internal_modules_cjs_loader().assertScriptCanLoadAsCJSImpl : () => {
    };
    exports2.REGISTER_INSTANCE = Symbol.for("ts-node.register.instance");
    exports2.env = process.env;
    exports2.INSPECT_CUSTOM = util.inspect.custom || "inspect";
    var shouldDebug = (0, util_1.yn)(exports2.env.TS_NODE_DEBUG);
    exports2.debug = shouldDebug ? (...args5) => console.log(`[ts-node ${(/* @__PURE__ */ new Date()).toISOString()}]`, ...args5) : () => void 0;
    var debugFn = shouldDebug ? (key, fn) => {
      let i = 0;
      return (x) => {
        (0, exports2.debug)(key, x, ++i);
        return fn(x);
      };
    } : (_, fn) => fn;
    exports2.VERSION = require_package().version;
    exports2.DEFAULTS = {
      cwd: (_a2 = exports2.env.TS_NODE_CWD) !== null && _a2 !== void 0 ? _a2 : exports2.env.TS_NODE_DIR,
      emit: (0, util_1.yn)(exports2.env.TS_NODE_EMIT),
      scope: (0, util_1.yn)(exports2.env.TS_NODE_SCOPE),
      scopeDir: exports2.env.TS_NODE_SCOPE_DIR,
      files: (0, util_1.yn)(exports2.env.TS_NODE_FILES),
      pretty: (0, util_1.yn)(exports2.env.TS_NODE_PRETTY),
      compiler: exports2.env.TS_NODE_COMPILER,
      compilerOptions: (0, util_1.parse)(exports2.env.TS_NODE_COMPILER_OPTIONS),
      ignore: (0, util_1.split)(exports2.env.TS_NODE_IGNORE),
      project: exports2.env.TS_NODE_PROJECT,
      skipProject: (0, util_1.yn)(exports2.env.TS_NODE_SKIP_PROJECT),
      skipIgnore: (0, util_1.yn)(exports2.env.TS_NODE_SKIP_IGNORE),
      preferTsExts: (0, util_1.yn)(exports2.env.TS_NODE_PREFER_TS_EXTS),
      ignoreDiagnostics: (0, util_1.split)(exports2.env.TS_NODE_IGNORE_DIAGNOSTICS),
      transpileOnly: (0, util_1.yn)(exports2.env.TS_NODE_TRANSPILE_ONLY),
      typeCheck: (0, util_1.yn)(exports2.env.TS_NODE_TYPE_CHECK),
      compilerHost: (0, util_1.yn)(exports2.env.TS_NODE_COMPILER_HOST),
      logError: (0, util_1.yn)(exports2.env.TS_NODE_LOG_ERROR),
      experimentalReplAwait: (_b2 = (0, util_1.yn)(exports2.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && _b2 !== void 0 ? _b2 : void 0,
      tsTrace: console.log.bind(console)
    };
    var TSError = class extends make_error_1.BaseError {
      constructor(diagnosticText, diagnosticCodes, diagnostics = []) {
        super(`\u2A2F Unable to compile TypeScript:
${diagnosticText}`);
        this.diagnosticCodes = diagnosticCodes;
        this.name = "TSError";
        Object.defineProperty(this, "diagnosticText", {
          configurable: true,
          writable: true,
          value: diagnosticText
        });
        Object.defineProperty(this, "diagnostics", {
          configurable: true,
          writable: true,
          value: diagnostics
        });
      }
      /**
       * @internal
       */
      [exports2.INSPECT_CUSTOM]() {
        return this.diagnosticText;
      }
    };
    exports2.TSError = TSError;
    var TS_NODE_SERVICE_BRAND = Symbol("TS_NODE_SERVICE_BRAND");
    function register(serviceOrOpts) {
      let service = serviceOrOpts;
      if (!(serviceOrOpts === null || serviceOrOpts === void 0 ? void 0 : serviceOrOpts[TS_NODE_SERVICE_BRAND])) {
        service = create(serviceOrOpts !== null && serviceOrOpts !== void 0 ? serviceOrOpts : {});
      }
      const originalJsHandler = require.extensions[".js"];
      process[exports2.REGISTER_INSTANCE] = service;
      registerExtensions(service.options.preferTsExts, service.extensions.compiled, service, originalJsHandler);
      (0, cjs_resolve_hooks_1.installCommonjsResolveHooksIfNecessary)(service);
      module_1.Module._preloadModules(service.options.require);
      return service;
    }
    exports2.register = register;
    function create(rawOptions = {}) {
      const foundConfigResult = (0, configuration_1.findAndReadConfig)(rawOptions);
      return createFromPreloadedConfig(foundConfigResult);
    }
    exports2.create = create;
    function createFromPreloadedConfig(foundConfigResult) {
      var _a3, _b3, _c2, _d;
      const { configFilePath, cwd, options, config, compiler, projectLocalResolveDir, optionBasePaths } = foundConfigResult;
      const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(projectLocalResolveDir);
      const ts = (0, configuration_1.loadCompiler)(compiler);
      const targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;
      if (options.experimentalReplAwait === true && !targetSupportsTla) {
        throw new Error("Experimental REPL await is not compatible with targets lower than ES2018");
      }
      const tsVersionSupportsTla = (0, util_1.versionGteLt)(ts.version, "3.8.0");
      if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {
        throw new Error("Experimental REPL await is not compatible with TypeScript versions older than 3.8");
      }
      const shouldReplAwait = options.experimentalReplAwait !== false && tsVersionSupportsTla && targetSupportsTla;
      if (options.swc && !options.typeCheck) {
        if (options.transpileOnly === false) {
          throw new Error("Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.");
        }
        if (options.transpiler) {
          throw new Error("Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.");
        }
      }
      const readFile2 = options.readFile || ts.sys.readFile;
      const fileExists = options.fileExists || ts.sys.fileExists;
      const transpileOnly = (options.transpileOnly === true || options.swc === true) && options.typeCheck !== true;
      let transpiler = void 0;
      let transpilerBasePath = void 0;
      if (options.transpiler) {
        transpiler = options.transpiler;
        transpilerBasePath = optionBasePaths.transpiler;
      } else if (options.swc) {
        transpiler = require.resolve("./transpilers/swc.js");
        transpilerBasePath = optionBasePaths.swc;
      }
      const transformers = options.transformers || void 0;
      const diagnosticFilters = [
        {
          appliesToAllFiles: true,
          filenamesAbsolute: [],
          diagnosticsIgnored: [
            6059,
            18002,
            18003,
            ...options.experimentalTsImportSpecifiers ? [
              2691
              // "An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead."
            ] : [],
            ...options.ignoreDiagnostics || []
          ].map(Number)
        }
      ];
      const configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);
      const outputCache = /* @__PURE__ */ new Map();
      const configFileDirname = configFilePath ? (0, path_1.dirname)(configFilePath) : null;
      const scopeDir = (_c2 = (_b3 = (_a3 = options.scopeDir) !== null && _a3 !== void 0 ? _a3 : config.options.rootDir) !== null && _b3 !== void 0 ? _b3 : configFileDirname) !== null && _c2 !== void 0 ? _c2 : cwd;
      const ignoreBaseDir = configFileDirname !== null && configFileDirname !== void 0 ? configFileDirname : cwd;
      const isScoped = options.scope ? (fileName) => (0, path_1.relative)(scopeDir, fileName).charAt(0) !== "." : () => true;
      const shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore ? [] : (options.ignore || ["(?:^|/)node_modules/"]).map((str) => new RegExp(str)));
      const diagnosticHost = {
        getNewLine: () => ts.sys.newLine,
        getCurrentDirectory: () => cwd,
        // TODO switch to getCanonicalFileName we already create later in scope
        getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? (x) => x : (x) => x.toLowerCase()
      };
      if (options.transpileOnly && typeof transformers === "function") {
        throw new TypeError('Transformers function is unavailable in "--transpile-only"');
      }
      let createTranspiler = initializeTranspilerFactory();
      function initializeTranspilerFactory() {
        var _a4;
        if (transpiler) {
          let createTranspiler2 = function(compilerOptions, nodeModuleEmitKind) {
            return transpilerFactory === null || transpilerFactory === void 0 ? void 0 : transpilerFactory({
              service: {
                options,
                config: {
                  ...config,
                  options: compilerOptions
                },
                projectLocalResolveHelper
              },
              transpilerConfigLocalResolveHelper,
              nodeModuleEmitKind,
              ...transpilerOptions
            });
          };
          if (!transpileOnly)
            throw new Error("Custom transpiler can only be used when transpileOnly is enabled.");
          const transpilerName = typeof transpiler === "string" ? transpiler : transpiler[0];
          const transpilerOptions = typeof transpiler === "string" ? {} : (_a4 = transpiler[1]) !== null && _a4 !== void 0 ? _a4 : {};
          const transpilerConfigLocalResolveHelper = transpilerBasePath ? (0, util_1.createProjectLocalResolveHelper)(transpilerBasePath) : projectLocalResolveHelper;
          const transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);
          const transpilerFactory = require(transpilerPath).create;
          return createTranspiler2;
        }
      }
      let experimentalEsmLoader = false;
      function enableExperimentalEsmLoaderInterop() {
        experimentalEsmLoader = true;
      }
      installSourceMapSupport();
      function installSourceMapSupport() {
        const sourceMapSupport = require_source_map_support();
        sourceMapSupport.install({
          environment: "node",
          retrieveFile(pathOrUrl) {
            var _a4;
            let path5 = pathOrUrl;
            if (experimentalEsmLoader && path5.startsWith("file://")) {
              try {
                path5 = (0, url_1.fileURLToPath)(path5);
              } catch (e) {
              }
            }
            path5 = (0, util_1.normalizeSlashes)(path5);
            return ((_a4 = outputCache.get(path5)) === null || _a4 === void 0 ? void 0 : _a4.content) || "";
          },
          redirectConflictingLibrary: true,
          onConflictingLibraryRedirect(request, parent, isMain, options2, redirectedRequest) {
            (0, exports2.debug)(`Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  "${parent.filename}" attempted to require or resolve "${request}" and was redirected to "${redirectedRequest}".`);
          }
        });
      }
      const shouldHavePrettyErrors = options.pretty === void 0 ? process.stdout.isTTY : options.pretty;
      const formatDiagnostics = shouldHavePrettyErrors ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;
      function createTSError(diagnostics) {
        const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);
        const diagnosticCodes = diagnostics.map((x) => x.code);
        return new TSError(diagnosticText, diagnosticCodes, diagnostics);
      }
      function reportTSError(configDiagnosticList2) {
        const error = createTSError(configDiagnosticList2);
        if (options.logError) {
          console.error("\x1B[31m%s\x1B[0m", error);
        } else {
          throw error;
        }
      }
      if (configDiagnosticList.length)
        reportTSError(configDiagnosticList);
      const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;
      function getEmitExtension(path5) {
        const lastDotIndex = path5.lastIndexOf(".");
        if (lastDotIndex >= 0) {
          const ext = path5.slice(lastDotIndex);
          switch (ext) {
            case ".js":
            case ".ts":
              return ".js";
            case ".jsx":
            case ".tsx":
              return jsxEmitPreserve ? ".jsx" : ".js";
            case ".mjs":
            case ".mts":
              return ".mjs";
            case ".cjs":
            case ".cts":
              return ".cjs";
          }
        }
        return ".js";
      }
      let getOutput;
      let getTypeInfo;
      const getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);
      const moduleTypeClassifier = (0, module_type_classifier_1.createModuleTypeClassifier)({
        basePath: (_d = options.optionBasePaths) === null || _d === void 0 ? void 0 : _d.moduleTypes,
        patterns: options.moduleTypes
      });
      const extensions = (0, file_extensions_1.getExtensions)(config, options, ts.version);
      if (!transpileOnly) {
        const fileContents = /* @__PURE__ */ new Map();
        const rootFileNames = new Set(config.fileNames);
        const cachedReadFile = (0, util_1.cachedLookup)(debugFn("readFile", readFile2));
        if (!options.compilerHost) {
          let projectVersion = 1;
          const fileVersions = new Map(Array.from(rootFileNames).map((fileName) => [fileName, 0]));
          const getCustomTransformers = () => {
            if (typeof transformers === "function") {
              const program = service.getProgram();
              return program ? transformers(program) : void 0;
            }
            return transformers;
          };
          const serviceHost = {
            getProjectVersion: () => String(projectVersion),
            getScriptFileNames: () => Array.from(rootFileNames),
            getScriptVersion: (fileName) => {
              const version = fileVersions.get(fileName);
              return version ? version.toString() : "";
            },
            getScriptSnapshot(fileName) {
              let contents = fileContents.get(fileName);
              if (contents === void 0) {
                contents = cachedReadFile(fileName);
                if (contents === void 0)
                  return;
                fileVersions.set(fileName, 1);
                fileContents.set(fileName, contents);
                projectVersion++;
              }
              return ts.ScriptSnapshot.fromString(contents);
            },
            readFile: cachedReadFile,
            readDirectory: ts.sys.readDirectory,
            getDirectories: (0, util_1.cachedLookup)(debugFn("getDirectories", ts.sys.getDirectories)),
            fileExists: (0, util_1.cachedLookup)(debugFn("fileExists", fileExists)),
            directoryExists: (0, util_1.cachedLookup)(debugFn("directoryExists", ts.sys.directoryExists)),
            realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn("realpath", ts.sys.realpath)) : void 0,
            getNewLine: () => ts.sys.newLine,
            useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,
            getCurrentDirectory: () => cwd,
            getCompilationSettings: () => config.options,
            getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),
            getCustomTransformers,
            trace: options.tsTrace
          };
          const { resolveModuleNames, getResolvedModuleWithFailedLookupLocationsFromCache, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal } = (0, resolver_functions_1.createResolverFunctions)({
            host: serviceHost,
            getCanonicalFileName,
            ts,
            cwd,
            config,
            projectLocalResolveHelper,
            options,
            extensions
          });
          serviceHost.resolveModuleNames = resolveModuleNames;
          serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;
          serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;
          const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);
          const service = ts.createLanguageService(serviceHost, registry);
          const updateMemoryCache = (contents, fileName) => {
            if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {
              markBucketOfFilenameInternal(fileName);
              rootFileNames.add(fileName);
              projectVersion++;
            }
            const previousVersion = fileVersions.get(fileName) || 0;
            const previousContents = fileContents.get(fileName);
            if (contents !== previousContents) {
              fileVersions.set(fileName, previousVersion + 1);
              fileContents.set(fileName, contents);
              projectVersion++;
            }
          };
          let previousProgram = void 0;
          getOutput = (code, fileName) => {
            updateMemoryCache(code, fileName);
            const programBefore = service.getProgram();
            if (programBefore !== previousProgram) {
              (0, exports2.debug)(`compiler rebuilt Program instance when getting output for ${fileName}`);
            }
            const output37 = service.getEmitOutput(fileName);
            const diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));
            const programAfter = service.getProgram();
            (0, exports2.debug)("invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ", programBefore === programAfter);
            previousProgram = programAfter;
            const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
            if (diagnosticList.length)
              reportTSError(diagnosticList);
            if (output37.emitSkipped) {
              return [void 0, void 0, true];
            }
            if (output37.outputFiles.length === 0) {
              throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}
This is usually the result of a faulty configuration or import. Make sure there is a \`.js\`, \`.json\` or other executable extension with loader attached before \`ts-node\` available.`);
            }
            return [output37.outputFiles[1].text, output37.outputFiles[0].text, false];
          };
          getTypeInfo = (code, fileName, position) => {
            const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
            updateMemoryCache(code, normalizedFileName);
            const info = service.getQuickInfoAtPosition(normalizedFileName, position);
            const name = ts.displayPartsToString(info ? info.displayParts : []);
            const comment = ts.displayPartsToString(info ? info.documentation : []);
            return { name, comment };
          };
        } else {
          const sys = {
            ...ts.sys,
            ...diagnosticHost,
            readFile: (fileName) => {
              const cacheContents = fileContents.get(fileName);
              if (cacheContents !== void 0)
                return cacheContents;
              const contents = cachedReadFile(fileName);
              if (contents)
                fileContents.set(fileName, contents);
              return contents;
            },
            readDirectory: ts.sys.readDirectory,
            getDirectories: (0, util_1.cachedLookup)(debugFn("getDirectories", ts.sys.getDirectories)),
            fileExists: (0, util_1.cachedLookup)(debugFn("fileExists", fileExists)),
            directoryExists: (0, util_1.cachedLookup)(debugFn("directoryExists", ts.sys.directoryExists)),
            resolvePath: (0, util_1.cachedLookup)(debugFn("resolvePath", ts.sys.resolvePath)),
            realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn("realpath", ts.sys.realpath)) : void 0
          };
          const host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : {
            ...sys,
            getSourceFile: (fileName, languageVersion) => {
              const contents = sys.readFile(fileName);
              if (contents === void 0)
                return;
              return ts.createSourceFile(fileName, contents, languageVersion);
            },
            getDefaultLibLocation: () => (0, util_1.normalizeSlashes)((0, path_1.dirname)(compiler)),
            getDefaultLibFileName: () => (0, util_1.normalizeSlashes)((0, path_1.join)((0, path_1.dirname)(compiler), ts.getDefaultLibFileName(config.options))),
            useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames
          };
          host.trace = options.tsTrace;
          const { resolveModuleNames, resolveTypeReferenceDirectives, isFileKnownToBeInternal, markBucketOfFilenameInternal } = (0, resolver_functions_1.createResolverFunctions)({
            host,
            cwd,
            config,
            ts,
            getCanonicalFileName,
            projectLocalResolveHelper,
            options,
            extensions
          });
          host.resolveModuleNames = resolveModuleNames;
          host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;
          let builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({
            rootNames: Array.from(rootFileNames),
            options: config.options,
            host,
            configFileParsingDiagnostics: config.errors,
            projectReferences: config.projectReferences
          }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, void 0, config.errors, config.projectReferences);
          const customTransformers = typeof transformers === "function" ? transformers(builderProgram.getProgram()) : transformers;
          const updateMemoryCache = (contents, fileName) => {
            const previousContents = fileContents.get(fileName);
            const contentsChanged = previousContents !== contents;
            if (contentsChanged) {
              fileContents.set(fileName, contents);
            }
            let addedToRootFileNames = false;
            if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {
              markBucketOfFilenameInternal(fileName);
              rootFileNames.add(fileName);
              addedToRootFileNames = true;
            }
            if (addedToRootFileNames || contentsChanged) {
              builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);
            }
          };
          getOutput = (code, fileName) => {
            let outText = "";
            let outMap = "";
            updateMemoryCache(code, fileName);
            const sourceFile = builderProgram.getSourceFile(fileName);
            if (!sourceFile)
              throw new TypeError(`Unable to read file: ${fileName}`);
            const program = builderProgram.getProgram();
            const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
            const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
            if (diagnosticList.length)
              reportTSError(diagnosticList);
            const result = builderProgram.emit(sourceFile, (path5, file, writeByteOrderMark) => {
              if (path5.endsWith(".map")) {
                outMap = file;
              } else {
                outText = file;
              }
              if (options.emit)
                sys.writeFile(path5, file, writeByteOrderMark);
            }, void 0, void 0, customTransformers);
            if (result.emitSkipped) {
              return [void 0, void 0, true];
            }
            if (outText === "") {
              if (program.isSourceFileFromExternalLibrary(sourceFile)) {
                throw new TypeError(`Unable to compile file from external library: ${(0, path_1.relative)(cwd, fileName)}`);
              }
              throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}
This is usually the result of a faulty configuration or import. Make sure there is a \`.js\`, \`.json\` or other executable extension with loader attached before \`ts-node\` available.`);
            }
            return [outText, outMap, false];
          };
          getTypeInfo = (code, fileName, position) => {
            const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
            updateMemoryCache(code, normalizedFileName);
            const sourceFile = builderProgram.getSourceFile(normalizedFileName);
            if (!sourceFile)
              throw new TypeError(`Unable to read file: ${fileName}`);
            const node = getTokenAtPosition(ts, sourceFile, position);
            const checker = builderProgram.getProgram().getTypeChecker();
            const symbol = checker.getSymbolAtLocation(node);
            if (!symbol)
              return { name: "", comment: "" };
            const type = checker.getTypeOfSymbolAtLocation(symbol, node);
            const signatures = [
              ...type.getConstructSignatures(),
              ...type.getCallSignatures()
            ];
            return {
              name: signatures.length ? signatures.map((x) => checker.signatureToString(x)).join("\n") : checker.typeToString(type),
              comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])
            };
          };
          if (options.emit && config.options.incremental) {
            process.on("exit", () => {
              builderProgram.getProgram().emitBuildInfo();
            });
          }
        }
      } else {
        getTypeInfo = () => {
          throw new TypeError('Type information is unavailable in "--transpile-only"');
        };
      }
      function createTranspileOnlyGetOutputFunction(overrideModuleType, nodeModuleEmitKind) {
        const compilerOptions = { ...config.options };
        if (overrideModuleType !== void 0)
          compilerOptions.module = overrideModuleType;
        let customTranspiler = createTranspiler === null || createTranspiler === void 0 ? void 0 : createTranspiler(compilerOptions, nodeModuleEmitKind);
        let tsTranspileModule = (0, util_1.versionGteLt)(ts.version, "4.7.0") ? (0, ts_transpile_module_1.createTsTranspileModule)(ts, {
          compilerOptions,
          reportDiagnostics: true,
          transformers
        }) : void 0;
        return (code, fileName) => {
          let result;
          if (customTranspiler) {
            result = customTranspiler.transpile(code, {
              fileName
            });
          } else if (tsTranspileModule) {
            result = tsTranspileModule(code, {
              fileName
            }, nodeModuleEmitKind === "nodeesm" ? "module" : "commonjs");
          } else {
            result = ts.transpileModule(code, {
              fileName,
              compilerOptions,
              reportDiagnostics: true,
              transformers
            });
          }
          const diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);
          if (diagnosticList.length)
            reportTSError(diagnosticList);
          return [result.outputText, result.sourceMapText, false];
        };
      }
      const shouldOverwriteEmitWhenForcingCommonJS = config.options.module !== ts.ModuleKind.CommonJS;
      const shouldOverwriteEmitWhenForcingEsm = !(config.options.module === ts.ModuleKind.ES2015 || ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020 || ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022 || config.options.module === ts.ModuleKind.ESNext);
      const isNodeModuleType = ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16 || ts.ModuleKind.NodeNext && config.options.module === ts.ModuleKind.NodeNext;
      const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS);
      const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, "nodecjs");
      const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, "nodeesm");
      const getOutputForceESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);
      const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();
      function compile(code, fileName, lineOffset = 0) {
        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
        const classification = moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizedFileName);
        let value2 = "";
        let sourceMap = "";
        let emitSkipped = true;
        if (getOutput) {
          [value2, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);
        }
        if (classification.moduleType === "cjs" && (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)) {
          [value2, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);
        } else if (classification.moduleType === "esm" && (shouldOverwriteEmitWhenForcingEsm || emitSkipped)) {
          [value2, sourceMap] = getOutputForceESM(code, normalizedFileName);
        } else if (emitSkipped) {
          const classification2 = (0, node_module_type_classifier_1.classifyModule)(fileName, isNodeModuleType);
          [value2, sourceMap] = classification2 === "nodecjs" ? getOutputForceNodeCommonJS(code, normalizedFileName) : classification2 === "nodeesm" ? getOutputForceNodeESM(code, normalizedFileName) : classification2 === "cjs" ? getOutputForceCommonJS(code, normalizedFileName) : classification2 === "esm" ? getOutputForceESM(code, normalizedFileName) : getOutputTranspileOnly(code, normalizedFileName);
        }
        const output37 = updateOutput(value2, normalizedFileName, sourceMap, getEmitExtension);
        outputCache.set(normalizedFileName, { content: output37 });
        return output37;
      }
      let active = true;
      const enabled = (enabled2) => enabled2 === void 0 ? active : active = !!enabled2;
      const ignored = (fileName) => {
        if (!active)
          return true;
        const ext = (0, path_1.extname)(fileName);
        if (extensions.compiled.includes(ext)) {
          return !isScoped(fileName) || shouldIgnore(fileName);
        }
        return true;
      };
      function addDiagnosticFilter(filter) {
        diagnosticFilters.push({
          ...filter,
          filenamesAbsolute: filter.filenamesAbsolute.map((f) => (0, util_1.normalizeSlashes)(f))
        });
      }
      const getNodeEsmResolver = (0, util_1.once)(() => require_node_internal_modules_esm_resolve().createResolve({
        extensions,
        preferTsExts: options.preferTsExts,
        tsNodeExperimentalSpecifierResolution: options.experimentalSpecifierResolution
      }));
      const getNodeEsmGetFormat = (0, util_1.once)(() => require_node_internal_modules_esm_get_format().createGetFormat(options.experimentalSpecifierResolution, getNodeEsmResolver()));
      const getNodeCjsLoader = (0, util_1.once)(() => require_node_internal_modules_cjs_loader().createCjsLoader({
        extensions,
        preferTsExts: options.preferTsExts,
        nodeEsmResolver: getNodeEsmResolver()
      }));
      return {
        [TS_NODE_SERVICE_BRAND]: true,
        ts,
        compilerPath: compiler,
        config,
        compile,
        getTypeInfo,
        ignored,
        enabled,
        options,
        configFilePath,
        moduleTypeClassifier,
        shouldReplAwait,
        addDiagnosticFilter,
        installSourceMapSupport,
        enableExperimentalEsmLoaderInterop,
        transpileOnly,
        projectLocalResolveHelper,
        getNodeEsmResolver,
        getNodeEsmGetFormat,
        getNodeCjsLoader,
        extensions
      };
    }
    exports2.createFromPreloadedConfig = createFromPreloadedConfig;
    function createIgnore(ignoreBaseDir, ignore) {
      return (fileName) => {
        const relname = (0, path_1.relative)(ignoreBaseDir, fileName);
        const path5 = (0, util_1.normalizeSlashes)(relname);
        return ignore.some((x) => x.test(path5));
      };
    }
    function registerExtensions(preferTsExts, extensions, service, originalJsHandler) {
      const exts = new Set(extensions);
      for (const cannotAdd of [".mts", ".cts", ".mjs", ".cjs"]) {
        if (exts.has(cannotAdd) && !(0, util_1.hasOwnProperty)(require.extensions, cannotAdd)) {
          exts.add(".js");
          exts.delete(cannotAdd);
        }
      }
      for (const ext of exts) {
        registerExtension(ext, service, originalJsHandler);
      }
      if (preferTsExts) {
        const preferredExtensions = /* @__PURE__ */ new Set([
          ...exts,
          ...Object.keys(require.extensions)
        ]);
        for (const ext of preferredExtensions) {
          const old = Object.getOwnPropertyDescriptor(require.extensions, ext);
          delete require.extensions[ext];
          Object.defineProperty(require.extensions, ext, old);
        }
      }
    }
    function registerExtension(ext, service, originalHandler) {
      const old = require.extensions[ext] || originalHandler;
      require.extensions[ext] = function(m, filename) {
        if (service.ignored(filename))
          return old(m, filename);
        assertScriptCanLoadAsCJS(service, m, filename);
        const _compile = m._compile;
        m._compile = function(code, fileName) {
          (0, exports2.debug)("module._compile", fileName);
          const result = service.compile(code, fileName);
          return _compile.call(this, result, fileName);
        };
        return old(m, filename);
      };
    }
    function updateOutput(outputText, fileName, sourceMap, getEmitExtension) {
      const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), "utf8").toString("base64");
      const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;
      const prefix = "//# sourceMappingURL=";
      const prefixLength = prefix.length;
      const baseName = (
        /*foo.tsx*/
        (0, path_1.basename)(fileName)
      );
      const extName = (
        /*.tsx*/
        (0, path_1.extname)(fileName)
      );
      const extension = (
        /*.js*/
        getEmitExtension(fileName)
      );
      const sourcemapFilename = baseName.slice(0, -extName.length) + extension + ".map";
      const sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;
      if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) === prefix) {
        return outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) + sourceMapContent;
      }
      const sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;
      if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) === prefix) {
        return outputText.slice(0, -sourceMapLengthWithPercentEncoding) + sourceMapContent;
      }
      return `${outputText}
${sourceMapContent}`;
    }
    function updateSourceMap(sourceMapText, fileName) {
      const sourceMap = JSON.parse(sourceMapText);
      sourceMap.file = fileName;
      sourceMap.sources = [fileName];
      delete sourceMap.sourceRoot;
      return JSON.stringify(sourceMap);
    }
    function filterDiagnostics(diagnostics, filters) {
      return diagnostics.filter((d) => filters.every((f) => {
        var _a3;
        return !f.appliesToAllFiles && f.filenamesAbsolute.indexOf((_a3 = d.file) === null || _a3 === void 0 ? void 0 : _a3.fileName) === -1 || f.diagnosticsIgnored.indexOf(d.code) === -1;
      }));
    }
    function getTokenAtPosition(ts, sourceFile, position) {
      let current = sourceFile;
      outer:
        while (true) {
          for (const child of current.getChildren(sourceFile)) {
            const start = child.getFullStart();
            if (start > position)
              break;
            const end = child.getEnd();
            if (position <= end) {
              current = child;
              continue outer;
            }
          }
          return current;
        }
    }
    var createEsmHooks = (tsNodeService) => require_esm().createEsmHooks(tsNodeService);
    exports2.createEsmHooks = createEsmHooks;
  }
});

// src/lib/core/runners/distributed-agent/v1/distributed-agent.impl.ts
var distributed_agent_impl_exports = {};
__export(distributed_agent_impl_exports, {
  startAgent: () => startAgent
});
async function startAgent() {
  try {
    require_dist2();
  } catch (e) {
  }
  const branch = getBranch();
  const runGroup = getRunGroup();
  const ciExecutionId = getCIExecutionId();
  const ciExecutionEnv = getCIExecutionEnv();
  const agentName = getAgentName();
  process.env.NX_CLOUD_CLIENT_INSTANCE_ID = import_uuid3.default.v4();
  const taskRunnerConfiguration = args.runner ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? "default";
  if (!canDetectRunGroup(runGroup, ciExecutionId)) {
    printRunGroupError();
    process.exit(1);
  }
  if (args.targets && args.targets.length) {
    output28.note({
      title: `Starting an agent for running Nx target(s) [${args.targets.join(
        ", "
      )}]`
    });
  } else {
    output28.note({
      title: `Starting Agent '${agentName}' for running Nx tasks`
    });
  }
  const { nxCloudOptions: options } = getCloudOptions(taskRunnerConfiguration);
  const workspaceEnabled = await isWorkspaceEnabled(options);
  if (!workspaceEnabled) {
    output28.error({
      title: "Nx Cloud: Workspace is disabled",
      bodyLines: [
        "Distributed Task Execution is disabled when your workspace is disabled",
        "",
        "Organization administrators can find more information on the 'Billing' page in the Nx Cloud Webapp"
      ]
    });
    process.exit(1);
  }
  const api = new DistributedAgentApi(
    options,
    branch,
    runGroup,
    ciExecutionId,
    ciExecutionEnv,
    agentName
  );
  createAgentLockfileAndSetUpListeners(api, options, agentName);
  const encryption = new E2EEncryption(ENCRYPTION_KEY || options.encryptionKey);
  const errorReporter = new ErrorReporterApi(options);
  const dteArtifactStorage = new DteArtifactStorage(
    new FileStorage(encryption, errorReporter, options, "dte-agent"),
    cacheDirectory8
  );
  const invokeTasks = initTasksRunner2 ? await invokeTasksUsingNxImperativeApi(
    options,
    cacheDirectory8,
    taskRunnerConfiguration
  ) : await invokeTasksUsingRunMany(taskRunnerConfiguration);
  return executeTasks(
    agentName,
    api,
    dteArtifactStorage,
    invokeTasks,
    args.targets
  ).then(async (res) => {
    return res;
  }).catch(async (e) => {
    await api.completeRunGroupWithError(
      `Critical Error in Agent: "${e.message}"`
    );
    process.exit(1);
  });
}
var import_uuid3, yargsParser2, output28, initTasksRunner2, cacheDirectory8, args;
var init_distributed_agent_impl = __esm({
  "src/lib/core/runners/distributed-agent/v1/distributed-agent.impl.ts"() {
    "use strict";
    import_uuid3 = __toESM(require_uuid());
    init_dte_artifact_storage();
    init_environment();
    init_get_cloud_options();
    init_is_workspace_enabled();
    init_error_reporter_api();
    init_print_run_group_error();
    init_e2e_encryption();
    init_file_storage();
    init_agent_utils();
    init_distributed_agent_api();
    init_invoke_tasks_using_nx_imperative_api();
    init_invoke_tasks_using_run_many();
    init_execute_tasks();
    yargsParser2 = require_build();
    ({ output: output28 } = require_nx_imports_light());
    ({
      initTasksRunner: initTasksRunner2,
      cacheDirectory: cacheDirectory8
    } = require_nx_imports());
    args = yargsParser2(process.argv, {
      array: ["targets"],
      string: ["runner"],
      default: {}
    });
    if (args.targets && args.targets.length === 1) {
      args.targets = args.targets[0].split(",").map((x) => x.trim());
    }
  }
});

// src/lib/core/runners/distributed-agent/v2/execute-tasks-v2.ts
async function executeTasksV2(agentName, api, dteArtifactStorage, invokeTasks, targets) {
  let completedStatusCode = 0;
  let apiResponse = null;
  const failIfSameTasksAfterTimeout = createUnchangedValueTimeout({
    title: `No new messages received after ${NO_MESSAGES_TIMEOUT / 1e3} seconds`,
    timeout: NO_MESSAGES_TIMEOUT
  });
  let completedTasks = [];
  const startTime = /* @__PURE__ */ new Date();
  let executedAnyTasks = false;
  const processedTasks = {};
  while (true) {
    if (VERBOSE_LOGGING) {
      output29.note({
        title: `${agentName} fetching tasks...`
      });
    }
    apiResponse = await api.tasksV2(
      apiResponse ? apiResponse.executionId : null,
      completedStatusCode,
      completedTasks,
      process.env.NX_CLOUD_DTE_V2_FORCE_DOWNLOAD_ALL_ARTIFACTS === "true",
      targets
    );
    const normalizedTasks = apiResponse.tasks.map(
      (t) => {
        return {
          id: t.id,
          target: t.target,
          overrides: t.overrides,
          projectRoot: t.projectRoot,
          cache: t.cache,
          outputs: t.outputs
        };
      }
    );
    if (VERBOSE_LOGGING) {
      output29.note({
        title: `${agentName} received an API Response`,
        bodyLines: [
          `completed: ${apiResponse.completed}`,
          `status: ${apiResponse.status}`,
          `retryDuring: ${apiResponse.retryDuring}`,
          `executionId: ${apiResponse.executionId}`,
          `number of tasks: ${apiResponse.tasks.length}`,
          `error: ${apiResponse.criticalErrorMessage}`,
          `maxParallel: ${apiResponse.maxParallel}`,
          `taskRunnerConfiguration: ${apiResponse.taskRunnerConfiguration}`
        ]
      });
    }
    if (apiResponse.criticalErrorMessage) {
      output29.error({
        title: "Distributed Execution Terminated",
        bodyLines: ["Error:", apiResponse.criticalErrorMessage]
      });
      process.exit(1);
    }
    if ((apiResponse == null ? void 0 : apiResponse.retryDuring) && (apiResponse == null ? void 0 : apiResponse.retryDuring) !== 0 && !executedAnyTasks && (/* @__PURE__ */ new Date()).getTime() - startTime.getTime() > apiResponse.retryDuring) {
      await wait(2e4);
      continue;
    }
    if ((apiResponse == null ? void 0 : apiResponse.status) !== void 0) {
      if (apiResponse.status === "RUN_GROUP_COMPLETED" || apiResponse.status === "NO_FURTHER_TASKS_TO_RUN") {
        return;
      }
    } else if (apiResponse.completed) {
      return;
    }
    failIfSameTasksAfterTimeout(apiResponse.tasks.map((t) => t.id).join(""));
    if (!apiResponse.executionId) {
      if (VERBOSE_LOGGING) {
        output29.note({
          title: `${agentName} waiting...`
        });
      }
      await wait(5e3);
      completedStatusCode = 0;
      completedTasks = [];
      continue;
    }
    executedAnyTasks = true;
    if (apiResponse.taskDependencies) {
      for (const t of apiResponse.taskDependencies) {
        if (processedTasks[t.taskId])
          continue;
        output29.note({
          title: `${agentName} downloading artifacts for ${t.taskId} Hash: ${t.hash}}`
        });
        const cacheFiles = [
          { remoteUrl: t.url, fileType: "artifact" }
        ];
        if (t.terminalOutputUrl) {
          cacheFiles.push({
            remoteUrl: t.terminalOutputUrl,
            fileType: "terminalOutput"
          });
        }
        await dteArtifactStorage.retrieveAndExtract(t.hash, cacheFiles);
        processedTasks[t.taskId] = true;
      }
    }
    const r = await invokeTasks(
      apiResponse.executionId,
      normalizedTasks,
      apiResponse.maxParallel,
      apiResponse.taskRunnerConfiguration
    );
    for (const t of r.completedTasks) {
      processedTasks[t.taskId] = true;
    }
    completedStatusCode = r.completedStatusCode;
    completedTasks = r.completedTasks;
  }
}
var output29;
var init_execute_tasks_v2 = __esm({
  "src/lib/core/runners/distributed-agent/v2/execute-tasks-v2.ts"() {
    "use strict";
    init_create_unchanged_value_timeout();
    init_environment();
    init_waiter();
    ({ output: output29 } = require_nx_imports_light());
  }
});

// src/lib/core/runners/distributed-agent/v2/distributed-agent-v2.impl.ts
var distributed_agent_v2_impl_exports = {};
__export(distributed_agent_v2_impl_exports, {
  startAgent: () => startAgent2
});
async function startAgent2() {
  try {
    require_dist2();
  } catch (e) {
  }
  const branch = getBranch();
  const runGroup = getRunGroup();
  const ciExecutionId = getCIExecutionId();
  const ciExecutionEnv = getCIExecutionEnv();
  const agentName = getAgentName();
  process.env.NX_CLOUD_CLIENT_INSTANCE_ID = import_uuid4.default.v4();
  const taskRunnerConfiguration = args2.runner ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? "default";
  if (!canDetectRunGroup(runGroup, ciExecutionId)) {
    printRunGroupError();
    process.exit(1);
  }
  if (args2.targets && args2.targets.length) {
    output30.note({
      title: `Starting a V2 agent for running Nx target(s) [${args2.targets.join(
        ", "
      )}]`
    });
  } else {
    output30.note({
      title: `Starting Agent '${agentName}' for running Nx tasks`
    });
  }
  const { nxCloudOptions: options } = getCloudOptions(taskRunnerConfiguration);
  const workspaceEnabled = await isWorkspaceEnabled(options);
  if (!workspaceEnabled) {
    output30.error({
      title: "Nx Cloud: Workspace is disabled",
      bodyLines: [
        "Distributed Task Execution is disabled when your workspace is disabled",
        "",
        "Organization administrators can find more information on the 'Billing' page in the Nx Cloud Webapp"
      ]
    });
    process.exit(1);
  }
  const api = new DistributedAgentApi(
    options,
    branch,
    runGroup,
    ciExecutionId,
    ciExecutionEnv,
    agentName
  );
  createAgentLockfileAndSetUpListeners(api, options, agentName);
  const encryption = new E2EEncryption(ENCRYPTION_KEY || options.encryptionKey);
  const errorReporter = new ErrorReporterApi(options);
  const dteArtifactStorage = new DteArtifactStorage(
    new FileStorage(encryption, errorReporter, options, "dte-agent"),
    cacheDirectory9
  );
  const invokeTasks = initTasksRunner3 ? await invokeTasksUsingNxImperativeApi(
    options,
    cacheDirectory9,
    taskRunnerConfiguration
  ) : await invokeTasksUsingRunMany(taskRunnerConfiguration);
  return executeTasksV2(
    agentName,
    api,
    dteArtifactStorage,
    invokeTasks,
    args2.targets
  ).then(async (res) => {
    return res;
  }).catch(async (e) => {
    await api.completeRunGroupWithError(
      `Critical Error in Agent: "${e.message}"`
    );
    process.exit(1);
  });
}
var import_uuid4, output30, initTasksRunner3, cacheDirectory9, args2;
var init_distributed_agent_v2_impl = __esm({
  "src/lib/core/runners/distributed-agent/v2/distributed-agent-v2.impl.ts"() {
    "use strict";
    import_uuid4 = __toESM(require_uuid());
    init_lib();
    init_dte_artifact_storage();
    init_environment();
    init_get_cloud_options();
    init_is_workspace_enabled();
    init_error_reporter_api();
    init_print_run_group_error();
    init_e2e_encryption();
    init_file_storage();
    init_agent_utils();
    init_distributed_agent_api();
    init_invoke_tasks_using_nx_imperative_api();
    init_invoke_tasks_using_run_many();
    init_execute_tasks_v2();
    ({ output: output30 } = require_nx_imports_light());
    ({
      initTasksRunner: initTasksRunner3,
      cacheDirectory: cacheDirectory9
    } = require_nx_imports());
    args2 = lib_default(process.argv, {
      array: ["targets"],
      string: ["runner"],
      default: {}
    });
  }
});

// src/lib/utilities/get-affected-project-ratio.ts
function getAffectedProjectRatio(touchedProjects, projectGraph) {
  if (touchedProjects.includes("*"))
    return 100;
  let projectNameToDirectDependents = {};
  let dependencies = Object.values(projectGraph.dependencies).flat();
  dependencies.forEach((item) => {
    if (projectNameToDirectDependents.hasOwnProperty(item.target)) {
      projectNameToDirectDependents[item.target].add(item.source);
    } else {
      projectNameToDirectDependents[item.target] = /* @__PURE__ */ new Set([item.source]);
    }
  });
  let affectedProjects = /* @__PURE__ */ new Set();
  let projectsToTrace = [...touchedProjects];
  while (true) {
    let currentProject = projectsToTrace.shift();
    if (!currentProject) {
      break;
    }
    if (affectedProjects.has(currentProject)) {
      continue;
    }
    affectedProjects.add(currentProject);
    let directDependentsOfCurrentProject = projectNameToDirectDependents[currentProject] || new Array();
    projectsToTrace.unshift(...directDependentsOfCurrentProject);
  }
  let affectedProjectCount = affectedProjects.size;
  let totalProjectCount = Object.keys(projectGraph.nodes).length;
  let affectedProjectRatio = Math.floor(
    affectedProjectCount / totalProjectCount * 100
  );
  if (VERBOSE_LOGGING) {
    output31.note({
      title: `Calculated affected project ratio`,
      bodyLines: [
        `based on ${touchedProjects}, the affected project ratio is ${affectedProjectRatio}`
      ]
    });
  }
  return affectedProjectRatio;
}
var output31;
var init_get_affected_project_ratio = __esm({
  "src/lib/utilities/get-affected-project-ratio.ts"() {
    "use strict";
    init_environment();
    ({ output: output31 } = require_nx_imports_light());
  }
});

// src/lib/utilities/touched-projects.ts
function normalizePath(osSpecificPath) {
  return osSpecificPath.replace(/^[A-Z]:/, "").split("\\").join("/");
}
function normalizeProjectRoot(root) {
  root = root === "" ? "." : root;
  return root && root.endsWith("/") ? root.substring(0, root.length - 1) : root;
}
function findProjectForPath(filePath, projectRootMap) {
  let currentPath = normalizePath(filePath);
  for (; currentPath != (0, import_path12.dirname)(currentPath); currentPath = (0, import_path12.dirname)(currentPath)) {
    const p = projectRootMap.get(currentPath);
    if (p) {
      return p;
    }
  }
  return projectRootMap.get(currentPath);
}
function createProjectRootMappings(nodes) {
  const projectRootMappings = /* @__PURE__ */ new Map();
  for (const projectName of Object.keys(nodes)) {
    let root = nodes[projectName].data.root;
    projectRootMappings.set(normalizeProjectRoot(root), projectName);
  }
  return projectRootMappings;
}
function getTouchedProjects(nxJson, projectGraph) {
  const globalFiles = [
    ...extractGlobalFilesFromNamedAndTargetInputs(nxJson),
    "nx.json",
    // TODO: Rely on Nx mechanism for affected instead of this approximation of lockfiles
    "package.json",
    "package-lock.json",
    "yarn.lock",
    "pnpm-lock.yaml"
  ];
  const touchedFiles = getExplicitlyTouchedFilesFromGit();
  return getTouchedProjectsFromFileList(
    projectGraph.nodes,
    globalFiles,
    touchedFiles
  );
}
function getExplicitlyTouchedFilesFromGit() {
  const base = process.env.NX_BASE || "HEAD~1";
  const head = process.env.NX_HEAD || "HEAD";
  if (VERBOSE_LOGGING) {
    console.log(`Evaluating touched files from Git`);
    console.log(`Base: ${base}`);
    console.log(`Head: ${head}`);
  }
  let touchedFiles = [];
  try {
    touchedFiles = (0, import_child_process6.execSync)(`git diff --name-only ${base} ${head}`).toString().split("\n").filter((path5) => path5.length !== 0);
  } catch (e) {
  }
  if (VERBOSE_LOGGING) {
    console.log("The following files were touched:");
    touchedFiles.forEach((file) => console.log(`- ${file}`));
  }
  return touchedFiles;
}
function getTouchedProjectsFromFileList(projectGraphNodes, globalFiles, touchedFiles) {
  const touchedProjects = /* @__PURE__ */ new Set();
  const projectRootMap = createProjectRootMappings(projectGraphNodes);
  if (VERBOSE_LOGGING) {
    console.log("Touched files result in the following affected projects");
  }
  touchedFiles.forEach((filePath) => {
    for (let i = 0; i < globalFiles.length; i++) {
      if (filePath === globalFiles[i]) {
        if (VERBOSE_LOGGING) {
          console.log(`- ${filePath} affects all projects`);
        }
        touchedProjects.add("*");
        break;
      }
    }
    const matchingProject = findProjectForPath(filePath, projectRootMap);
    if (matchingProject) {
      touchedProjects.add(matchingProject);
    }
  });
  return Array.from(touchedProjects);
}
function extractGlobalFilesFromNamedAndTargetInputs(nxJson) {
  const globalFiles = [];
  globalFiles.push(...extractFilesFromNamedInputs(nxJson.namedInputs));
  globalFiles.push(...extractFilesFromTargetInputs(nxJson.targetDefaults));
  return globalFiles;
}
function extractFilesFromNamedInputs(namedInputs) {
  const files = [];
  for (const inputs of Object.values(namedInputs || {})) {
    files.push(...extractGlobalFilesFromInputs(inputs));
  }
  return files;
}
function extractFilesFromTargetInputs(targets) {
  const globalFiles = [];
  for (const target of Object.values(targets || {})) {
    if (target.inputs) {
      globalFiles.push(...extractGlobalFilesFromInputs(target.inputs));
    }
  }
  return globalFiles;
}
function extractGlobalFilesFromInputs(inputs) {
  const globalFiles = [];
  for (const input of inputs) {
    if (typeof input === "string" && input.startsWith("{workspaceRoot}/")) {
      globalFiles.push(input.substring("{workspaceRoot}/".length));
    } else if (input.fileset && input.fileset.startsWith("{workspaceRoot}/")) {
      globalFiles.push(input.fileset.substring("{workspaceRoot}/".length));
    }
  }
  return globalFiles;
}
var import_child_process6, import_path12;
var init_touched_projects = __esm({
  "src/lib/utilities/touched-projects.ts"() {
    "use strict";
    import_child_process6 = require("child_process");
    import_path12 = require("path");
    init_environment();
  }
});

// src/lib/core/commands/start-ci-run.ts
var start_ci_run_exports = {};
__export(start_ci_run_exports, {
  startCiRun: () => startCiRun
});
async function tryFetchExistingProjectGraph(api) {
  var _a2, _b2;
  try {
    return (_b2 = (_a2 = await api.fetchProjectGraph()) == null ? void 0 : _a2.data) == null ? void 0 : _b2.projectGraph;
  } catch (e) {
    return null;
  }
}
async function startCiRun() {
  const taskRunnerConfiguration = args3.runner ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? "default";
  const { nxJson, nxCloudOptions } = getCloudOptions(taskRunnerConfiguration);
  const branch = getBranch();
  const runGroup = getRunGroup();
  const ciExecutionId = getCIExecutionId();
  const ciExecutionEnv = getCIExecutionEnv();
  const commitSha = extractGitSha();
  const commitRef = extractGitRef();
  const vcsContext = getVcsContext();
  const distributeOn = getDistributeOn(args3);
  const useDteByDefault = args3.distribution === false ? false : args3.useDteByDefault;
  const envVars = getCiEnvVars(args3.withEnvVars);
  if (!canDetectRunGroup(runGroup, ciExecutionId)) {
    printRunGroupError();
    process.exit(1);
  }
  if (!args3.force && useDteByDefault) {
    validateBranchAndVcsContextDetected(branch, vcsContext);
  }
  if (args3.distribution == null && args3.distributeOn == null) {
    printExplicitDistributionWarning();
  }
  if (VERBOSE_LOGGING) {
    output32.note({
      title: `Creating run group. branch: ${branch}, ciExecutionId: ${ciExecutionId}, ciExecutionEnv: ${ciExecutionEnv}, runGroup: ${runGroup}, commitSha: ${commitSha}, requireExplicitCompletion: ${args3.requireExplicitCompletion}`
    });
  }
  if (args3.commandCount) {
    output32.error({
      title: `--command-count is deprecated. Use --stop-agents-after instead.`,
      bodyLines: [`E.g., npx nx-cloud start-ci-run --stop-agents-after="e2e"`]
    });
    process.exit(1);
  }
  const api = new RunGroupApi(nxCloudOptions);
  let projectGraph = await tryFetchExistingProjectGraph(api);
  let touchedProjects = [];
  let affectedProjectRatio = 100;
  if (projectGraph != null) {
    touchedProjects = getTouchedProjects(nxJson, projectGraph);
    affectedProjectRatio = getAffectedProjectRatio(
      touchedProjects,
      projectGraph
    );
    if (VERBOSE_LOGGING) {
      output32.note({
        title: `The following projects were touched during recent changes`,
        bodyLines: touchedProjects
      });
    }
  } else {
    output32.warn({
      title: `Nx Cloud was unable to retrieve a project graph to compare against.`,
      bodyLines: [
        "This CI Pipeline execution may still be recoverable, but auto-sizing will",
        "not be used."
      ]
    });
  }
  await api.createRunGroup(
    branch,
    runGroup,
    ciExecutionId,
    ciExecutionEnv,
    args3.stopAgentsOnFailure,
    args3.agentCount,
    args3.stopAgentsAfter,
    distributeOn,
    commitSha,
    commitRef,
    affectedProjectRatio,
    envVars,
    args3.requireExplicitCompletion,
    touchedProjects
  );
  if (useDteByDefault) {
    storeDteMarker();
  }
}
function validateBranchAndVcsContextDetected(branch, vcsContext) {
  if (!branch || !vcsContext) {
    output32.error({
      title: `This command may not be needed in your current environment.`,
      bodyLines: [
        '- "nx-cloud start-ci-run" places a marker file on your system that will result in all commands attempting to run as distributed executions.',
        "- If you are not in a CI environment, this is unnecessary.",
        '- If you run this command locally, use "nx-cloud cleanup" to remove any generated files.',
        '- Use the "--force" flag to bypass this check.'
      ]
    });
  }
}
function printExplicitDistributionWarning() {
  output32.warn({
    title: "Nx Cloud Warning: Ambiguous Distribution Configuration",
    bodyLines: [
      "`nx-cloud start-ci-run` was invoked without either `--distribute-on` or `--no-distribution`. This can result in unexpected behavior.",
      "",
      "- To enable distribution with Nx Agents, use the `--distribute-on` with a quantity of agents and a launch template name.",
      "- To disable distribution, use the `--no-distribution` flag.",
      '- Legacy DTE setups can set `--distribute-on="manual"` to disable this warning.'
    ]
  });
}
function getDistributeOn(args5) {
  const rawValue = args5.distributeOn ? args5.distributeOn : args5.distributesOn;
  if (rawValue === "manual") {
    return void 0;
  }
  return rawValue;
}
var yargsParser3, output32, workspaceRoot6, args3;
var init_start_ci_run = __esm({
  "src/lib/core/commands/start-ci-run.ts"() {
    "use strict";
    init_distributed_task_execution_detection();
    init_environment();
    init_get_affected_project_ratio();
    init_get_cloud_options();
    init_get_vcs_context();
    init_touched_projects();
    init_run_group_api();
    init_print_run_group_error();
    yargsParser3 = require_build();
    ({ output: output32, workspaceRoot: workspaceRoot6 } = require_nx_imports_light());
    args3 = yargsParser3(process.argv, {
      boolean: [
        "stop-agents-on-failure",
        "use-dte-by-default",
        "require-explicit-completion",
        "force",
        "distribution"
      ],
      number: ["agent-count", "command-count"],
      string: [
        "stop-agents-after",
        "with-env-vars",
        "distributes-on",
        "distribute-on",
        "runner"
      ],
      default: {
        useDteByDefault: true
      }
    });
  }
});

// src/lib/core/commands/stop-all-agents.ts
var stop_all_agents_exports = {};
__export(stop_all_agents_exports, {
  stopAllAgents: () => stopAllAgents
});
async function stopAllAgents() {
  const branch = getBranch();
  const runGroup = getRunGroup();
  const ciExecutionId = getCIExecutionId();
  const ciExecutionEnv = getCIExecutionEnv();
  if (!canDetectRunGroup(runGroup, ciExecutionId)) {
    printRunGroupError();
    process.exit(1);
  }
  if (VERBOSE_LOGGING) {
    output33.note({
      title: `Stopping all agents running tasks for run group. branch: ${branch}, ciExecutionId: ${ciExecutionId}, ciExecutionEnv: ${ciExecutionEnv}, runGroup: ${runGroup}`
    });
  }
  const taskRunnerConfiguration = getTaskRunnerConfigurationFromArgs(process.argv) ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? "default";
  const { nxCloudOptions } = getCloudOptions(taskRunnerConfiguration);
  const api = new RunGroupApi(nxCloudOptions);
  await api.completeRunGroup(branch, runGroup, ciExecutionId, ciExecutionEnv);
}
var output33;
var init_stop_all_agents = __esm({
  "src/lib/core/commands/stop-all-agents.ts"() {
    "use strict";
    init_environment();
    init_get_cloud_options();
    init_task_runner_configurations();
    init_run_group_api();
    init_print_run_group_error();
    ({ output: output33 } = require_nx_imports_light());
  }
});

// node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "node_modules/is-docker/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs.statSync("/.dockerenv");
        return true;
      } catch (_) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_) {
        return false;
      }
    }
    module2.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "node_modules/is-wsl/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var fs = require("fs");
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module2.exports = isWsl;
    } else {
      module2.exports = isWsl();
    }
  }
});

// node_modules/define-lazy-prop/index.js
var require_define_lazy_prop = __commonJS({
  "node_modules/define-lazy-prop/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (object, propertyName, fn) => {
      const define2 = (value2) => Object.defineProperty(object, propertyName, { value: value2, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define2(result);
          return result;
        },
        set(value2) {
          define2(value2);
        }
      });
      return object;
    };
  }
});

// node_modules/open/index.js
var require_open = __commonJS({
  "node_modules/open/index.js"(exports2, module2) {
    "use strict";
    var path5 = require("path");
    var childProcess = require("child_process");
    var { promises: fs, constants: fsConstants } = require("fs");
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker();
    var defineLazyProperty = require_define_lazy_prop();
    var localXdgOpenPath = path5.join(__dirname, "xdg-open");
    var { platform, arch } = process;
    var hasContainerEnv = () => {
      try {
        fs.statSync("/run/.containerenv");
        return true;
      } catch {
        return false;
      }
    };
    var cachedResult;
    function isInsideContainer() {
      if (cachedResult === void 0) {
        cachedResult = hasContainerEnv() || isDocker();
      }
      return cachedResult;
    }
    var getWslDrivesMountPoint = /* @__PURE__ */ (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array, mapper) => {
      let latestError;
      for (const item of array) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    var baseOpen = async (options) => {
      options = {
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false,
        ...options
      };
      if (Array.isArray(options.app)) {
        return pTryEach(options.app, (singleApp) => baseOpen({
          ...options,
          app: singleApp
        }));
      }
      let { name: app, arguments: appArguments = [] } = options.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen({
          ...options,
          app: {
            name: appName,
            arguments: appArguments
          }
        }));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (options.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isInsideContainer() && !app) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "\u2013ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options.target) {
            appArguments.unshift(options.target);
          }
        } else if (options.target) {
          encodedArguments.push(`"${options.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options.target) {
        cliArguments.push(options.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve2, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (!options.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve2(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    var open2 = (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen({
        ...options,
        target
      });
    };
    var openApp = (name, options) => {
      if (typeof name !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen({
        ...options,
        app: {
          name,
          arguments: appArguments
        }
      });
    };
    function detectArchBinary(binary) {
      if (typeof binary === "string" || Array.isArray(binary)) {
        return binary;
      }
      const { [arch]: archBinary } = binary;
      if (!archBinary) {
        throw new Error(`${arch} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open2.apps = apps;
    open2.openApp = openApp;
    module2.exports = open2;
  }
});

// src/lib/utilities/print-cloud-connection-disabled-message.ts
function printCloudConnectionDisabledMessage() {
  const { output: output37 } = require_nx_imports_light();
  output37.error({
    title: `Connections to Nx Cloud are disabled for this workspace`,
    bodyLines: [
      `This was an intentional decision by someone on your team.`,
      `Nx Cloud cannot and will not be enabled.`,
      ``,
      `To allow connections to Nx Cloud again, remove the 'neverConnectToCloud'`,
      `property in nx.json.`
    ]
  });
}
var init_print_cloud_connection_disabled_message = __esm({
  "src/lib/utilities/print-cloud-connection-disabled-message.ts"() {
    "use strict";
  }
});

// src/lib/core/commands/upload-and-show-run-details.ts
var upload_and_show_run_details_exports = {};
__export(upload_and_show_run_details_exports, {
  uploadAndShowRunDetails: () => uploadAndShowRunDetails
});
async function uploadRunDetails(options) {
  const errors = new MessageReporter(options);
  const runContext = {};
  const machineInfo = getMachineInfo();
  const api = new CloudRunApi(errors, runContext, options, machineInfo);
  const outputObfusactor = new OutputObfuscator(options.maskedProperties);
  const runInfo = JSON.parse(
    (0, import_fs20.readFileSync)((0, import_path13.join)(cacheDirectory10, "run.json")).toString()
  );
  const tasks = runInfo.tasks.map((t) => ({
    ...t,
    terminalOutput: readTaskTerminalOutput(
      cacheDirectory10,
      outputObfusactor,
      t.hash,
      t.cacheStatus,
      t.status
    )
  }));
  const linkId = generateUniqueLinkId();
  await api.endRun(
    runInfo.run,
    tasks,
    {
      branch: null,
      runGroup: null,
      ciExecutionId: null,
      ciExecutionEnv: null
    },
    void 0,
    void 0,
    linkId
  );
  return `${removeTrailingSlash(
    options.url || "https://nx.app"
  )}/runs/${linkId}`;
}
async function uploadAndShowRunDetails() {
  const taskRunnerConfiguration = getTaskRunnerConfigurationFromArgs(process.argv) ?? process.env.NX_TASKS_RUNNER ?? process.env.NX_RUNNER ?? "default";
  const { nxJson, nxCloudOptions } = getCloudOptions(taskRunnerConfiguration);
  if (nxJson.neverConnectToCloud) {
    printCloudConnectionDisabledMessage();
    process.exit(1);
  }
  const url = await uploadRunDetails(nxCloudOptions);
  output34.success({
    title: "Successfully uploaded the run details",
    bodyLines: [`View run details at ${url}`]
  });
  (0, import_open.default)(url);
}
var import_fs20, import_open, import_path13, output34, cacheDirectory10;
var init_upload_and_show_run_details = __esm({
  "src/lib/core/commands/upload-and-show-run-details.ts"() {
    "use strict";
    import_fs20 = require("fs");
    import_open = __toESM(require_open());
    import_path13 = require("path");
    init_environment();
    init_get_cloud_options();
    init_print_cloud_connection_disabled_message();
    init_remove_trailing_slash();
    init_task_runner_configurations();
    init_cloud_run_api();
    init_id_generator();
    init_message_reporter();
    init_output_obfuscator();
    init_read_task_terminal_output();
    ({ output: output34 } = require_nx_imports_light());
    ({ cacheDirectory: cacheDirectory10 } = require_nx_imports());
  }
});

// src/lib/core/commands/cleanup.ts
var cleanup_exports = {};
__export(cleanup_exports, {
  cleanup: () => cleanup
});
async function cleanup() {
  output35.note({
    title: `Cleaning up temporary files created by Nx Cloud.`
  });
  if ((0, import_fs21.existsSync)(dteMarker)) {
    (0, import_fs21.unlinkSync)(dteMarker);
  }
}
var import_fs21, output35;
var init_cleanup = __esm({
  "src/lib/core/commands/cleanup.ts"() {
    "use strict";
    import_fs21 = require("fs");
    init_distributed_task_execution_detection();
    ({ output: output35 } = require_nx_imports_light());
  }
});

// src/lib/core/commands/validate.ts
var validate_exports = {};
__export(validate_exports, {
  validate: () => validate
});
async function validate() {
  const { stepFile, workflowFile, runner } = args4;
  if (!workflowFile) {
    output36.error({
      title: "missing --workflow-file argument"
    });
    process2.exit(1);
  }
  const taskRunnerConfiguration = runner ?? process2.env.NX_TASKS_RUNNER ?? process2.env.NX_RUNNER ?? "default";
  const { nxCloudOptions } = getCloudOptions(taskRunnerConfiguration);
  const commitSha = extractGitSha();
  const axiosInstance = createApiAxiosInstance(nxCloudOptions);
  try {
    const resp = await axiosMultipleTries(
      () => axiosInstance.post("/nx-cloud/workflows/validate", {
        workflowFile,
        stepFile: stepFile ?? false,
        commitSha: commitSha ?? "HEAD"
      })
    );
    const data = resp.data;
    const errors = data.filter((v) => v.errors.length > 0);
    if (errors.length > 0) {
      output36.error({
        title: !stepFile ? "Workflow Launch Template is invalid" : "Workflow Launch Template Step is invalid",
        bodyLines: errors.map((v) => {
          if (!v.launchTemplateName) {
            return v.errors.join("\n");
          } else {
            return `${v.launchTemplateName}:
	${v.errors.join(
              "\n	"
            )}`.trim();
          }
        })
      });
      process2.exit(1);
    } else {
      output36.success({
        title: !stepFile ? "Workflow Launch Template is valid" : "Workflow Launch Template Step is valid"
      });
      process2.exit(0);
    }
  } catch (error) {
    output36.error({
      title: error.message,
      bodyLines: error.bodyLines ?? []
    });
    process2.exit(1);
  }
}
var process2, output36, args4;
var init_validate = __esm({
  "src/lib/core/commands/validate.ts"() {
    "use strict";
    process2 = __toESM(require("process"));
    init_lib();
    init_axios();
    init_environment();
    init_get_cloud_options();
    ({ output: output36 } = require_nx_imports_light());
    args4 = lib_default(process2.argv, {
      boolean: ["step-file"],
      string: ["workflow-file", "runner"]
    });
  }
});

// src/index.ts
exports.nxCloudTasksRunner = (...args5) => (init_nx_cloud_tasks_runner(), __toCommonJS(nx_cloud_tasks_runner_exports)).default(...args5);
exports.configureLightClientRequire = () => (init_light_client_require(), __toCommonJS(light_client_require_exports)).configureLightClientRequire;
var commandMap = {
  "clean-up-agents": () => (init_clean_up_agents(), __toCommonJS(clean_up_agents_exports)).cleanUpAgents(),
  record: () => (init_record_output(), __toCommonJS(record_output_exports)).runCommandAndStoreInCloud(),
  "start-agent": () => process.env.NX_CLOUD_DTE_V1 === "true" ? (init_distributed_agent_impl(), __toCommonJS(distributed_agent_impl_exports)).startAgent() : (init_distributed_agent_v2_impl(), __toCommonJS(distributed_agent_v2_impl_exports)).startAgent(),
  "start-ci-run": () => (init_start_ci_run(), __toCommonJS(start_ci_run_exports)).startCiRun(),
  "stop-all-agents": () => (init_stop_all_agents(), __toCommonJS(stop_all_agents_exports)).stopAllAgents(),
  "complete-ci-run": () => (init_stop_all_agents(), __toCommonJS(stop_all_agents_exports)).stopAllAgents(),
  "upload-and-show-run-details": () => (init_upload_and_show_run_details(), __toCommonJS(upload_and_show_run_details_exports)).uploadAndShowRunDetails(),
  cleanup: () => (init_cleanup(), __toCommonJS(cleanup_exports)).cleanup(),
  validate: () => (init_validate(), __toCommonJS(validate_exports)).validate()
};
exports.commands = commandMap;
exports.cleanUpAgents = () => (init_clean_up_agents(), __toCommonJS(clean_up_agents_exports)).cleanUpAgents();
exports.runCommandAndStoreInCloud = () => (init_record_output(), __toCommonJS(record_output_exports)).runCommandAndStoreInCloud();
exports.startAgent = () => (init_distributed_agent_impl(), __toCommonJS(distributed_agent_impl_exports)).startAgent();
exports.startCiRun = () => (init_start_ci_run(), __toCommonJS(start_ci_run_exports)).startCiRun();
exports.stopAllAgents = () => (init_stop_all_agents(), __toCommonJS(stop_all_agents_exports)).stopAllAgents();
exports.uploadAndShowRunDetails = () => (init_upload_and_show_run_details(), __toCommonJS(upload_and_show_run_details_exports)).uploadAndShowRunDetails();
exports.cleanup = () => (init_cleanup(), __toCommonJS(cleanup_exports)).cleanup();
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

yargs-parser/build/lib/string-utils.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/tokenize-arg-string.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/yargs-parser-types.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/yargs-parser.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/index.js:
  (**
   * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
   * CJS and ESM environments.
   *
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)
*/
